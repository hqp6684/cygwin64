<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>VIM: eval</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>EVAL</h2>
<pre>
<b class="vimtag">*<a name="eval.txt">eval.txt</a>*</b>	For Vim version 7.4.  Last change: 2016 Apr 26


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


Expression evaluation			<b class="vimtag">*<a name="expression">expression</a>*</b> <b class="vimtag">*<a name="expr">expr</a>*</b> <b class="vimtag">*<a name="E15">E15</a>*</b> <b class="vimtag">*<a name="eval">eval</a>*</b>

Using expressions is introduced in chapter 41 of the user manual |<a href="usr_41.html#usr_41.txt">usr_41</a>|.

<code class="note">Note:</code> Expression evaluation can be disabled at compile time.  If this has been
done, the features in this document are not available.	See |<a href="various.html#+eval">+eval</a>| and
|<a href="eval.html#no-eval-feature">no-eval-feature</a>|.

1.  Variables			|<a href="eval.html#variables">variables</a>|
    1.1 Variable types
    1.2 Function references		|<a href="eval.html#Funcref">Funcref</a>|
    1.3 Lists				|<a href="eval.html#Lists">Lists</a>|
    1.4 Dictionaries			|<a href="eval.html#Dictionaries">Dictionaries</a>|
    1.5 More about variables		|<a href="eval.html#more-variables">more-variables</a>|
2.  Expression syntax		|<a href="eval.html#expression-syntax">expression-syntax</a>|
3.  Internal variable		|<a href="eval.html#internal-variables">internal-variables</a>|
4.  Builtin Functions		|<a href="eval.html#functions">functions</a>|
5.  Defining functions		|<a href="eval.html#user-functions">user-functions</a>|
6.  Curly braces names		|<a href="eval.html#curly-braces-names">curly-braces-names</a>|
7.  Commands			|<a href="eval.html#expression-commands">expression-commands</a>|
8.  Exception handling		|<a href="eval.html#exception-handling">exception-handling</a>|
9.  Examples			|<a href="eval.html#eval-examples">eval-examples</a>|
10. No +eval feature		|<a href="eval.html#no-eval-feature">no-eval-feature</a>|
11. The sandbox			|<a href="eval.html#eval-sandbox">eval-sandbox</a>|
12. Textlock			|<a href="eval.html#textlock">textlock</a>|

<code class="special">{Vi does not have any of these commands}</code>

</pre><hr><pre>1. Variables						<b class="vimtag">*<a name="variables">variables</a>*</b>

<code class="section">1.1 Variable types </code>
							<b class="vimtag">*<a name="E712">E712</a>*</b>
There are nine types of variables:

Number		A 32 or 64 bit signed number.  |<a href="eval.html#expr-number">expr-number</a>| <b class="vimtag">*<a name="Number">Number</a>*</b>
		Examples:  -123  0x10  0177

Float		A floating point number. |<a href="eval.html#floating-point-format">floating-point-format</a>| <b class="vimtag">*<a name="Float">Float</a>*</b>
		{only when compiled with the |<a href="various.html#+float">+float</a>| feature}
		Examples: 123.456  1.15e-6  -1.1e3

							<b class="vimtag">*<a name="E928">E928</a>*</b>
String		A NUL terminated string of 8-bit unsigned characters (bytes).
		|<a href="eval.html#expr-string">expr-string</a>| Examples: "ab\txx\"--"  'x-z''a,c'

List		An ordered sequence of items |<a href="eval.html#List">List</a>|.
		Example: [1, 2, ['a', 'b']]

Dictionary	An associative, unordered array: Each entry has a key and a
		value. |<a href="eval.html#Dictionary">Dictionary</a>|
		Example: <code class="special">{'blue': "#0000ff", 'red': "#ff0000"}</code>

Funcref		A reference to a function |<a href="eval.html#Funcref">Funcref</a>|.
		Example: function("strlen")

Special		|<a href="eval.html#v:false">v:false</a>|, |<a href="eval.html#v:true">v:true</a>|, |<a href="eval.html#v:none">v:none</a>| and |<a href="eval.html#v:null">v:null</a>|.  <b class="vimtag">*<a name="Special">Special</a>*</b>

Job		Used for a job, see |<a href="eval.html#job_start()">job_start()</a>|. <b class="vimtag">*<a name="Job">Job</a>*</b> <b class="vimtag">*<a name="Jobs">Jobs</a>*</b>

Channel		Used for a channel, see |<a href="eval.html#ch_open()">ch_open()</a>|. <b class="vimtag">*<a name="Channel">Channel</a>*</b> <b class="vimtag">*<a name="Channels">Channels</a>*</b>

The Number and String types are converted automatically, depending on how they
are used.

Conversion from a Number to a String is by making the ASCII representation of
the Number.  Examples:
<code class="section">	Number 123	--&gt;	String "123" </code>
<code class="section">	Number 0	--&gt;	String "0" </code>
<code class="section">	Number -1	--&gt;	String "-1" </code>
							<b class="vimtag">*<a name="octal">octal</a>*</b>
Conversion from a String to a Number is done by converting the first digits to
a number.  Hexadecimal "0xf9", Octal "017", and Binary "0b10" numbers are
recognized.  If the String doesn't start with digits, the result is zero.
Examples:
<code class="section">	String "456"	--&gt;	Number 456 </code>
<code class="section">	String "6bar"	--&gt;	Number 6 </code>
<code class="section">	String "foo"	--&gt;	Number 0 </code>
<code class="section">	String "0xf1"	--&gt;	Number 241 </code>
<code class="section">	String "0100"	--&gt;	Number 64 </code>
<code class="section">	String "0b101"	--&gt;	Number 5 </code>
<code class="section">	String "-8"	--&gt;	Number -8 </code>
<code class="section">	String "+8"	--&gt;	Number 0 </code>

To force conversion from String to Number, add zero to it:
<code class="example">	:echo "0100" + 0</code>
<code class="section">	64 </code>

To avoid a leading zero to cause octal conversion, or for using a different
base, use |<a href="eval.html#str2nr()">str2nr()</a>|.

For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.

<code class="note">Note</code> that in the command
<code class="example">	:if "foo"</code>
"foo" is converted to 0, which means FALSE.  To test for a non-empty string,
use empty():
<code class="example">	:if !empty("foo")</code>

		<b class="vimtag">*<a name="E745">E745</a>*</b> <b class="vimtag">*<a name="E728">E728</a>*</b> <b class="vimtag">*<a name="E703">E703</a>*</b> <b class="vimtag">*<a name="E729">E729</a>*</b> <b class="vimtag">*<a name="E730">E730</a>*</b> <b class="vimtag">*<a name="E731">E731</a>*</b> <b class="vimtag">*<a name="E908">E908</a>*</b> <b class="vimtag">*<a name="E910">E910</a>*</b> <b class="vimtag">*<a name="E913">E913</a>*</b>
List, Dictionary, Funcref and Job types are not automatically converted.

							<b class="vimtag">*<a name="E805">E805</a>*</b> <b class="vimtag">*<a name="E806">E806</a>*</b> <b class="vimtag">*<a name="E808">E808</a>*</b>
When mixing Number and Float the Number is converted to Float.	Otherwise
there is no automatic conversion of Float.  You can use str2float() for String
to Float, printf() for Float to String and float2nr() for Float to Number.

			<b class="vimtag">*<a name="E891">E891</a>*</b> <b class="vimtag">*<a name="E892">E892</a>*</b> <b class="vimtag">*<a name="E893">E893</a>*</b> <b class="vimtag">*<a name="E894">E894</a>*</b> <b class="vimtag">*<a name="E907">E907</a>*</b> <b class="vimtag">*<a name="E911">E911</a>*</b> <b class="vimtag">*<a name="E914">E914</a>*</b>
When expecting a Float a Number can also be used, but nothing else.

						<b class="vimtag">*<a name="no-type-checking">no-type-checking</a>*</b>
You will not get an error if you try to change the type of a variable.


<code class="section">1.2 Function references </code>
					<b class="vimtag">*<a name="Funcref">Funcref</a>*</b> <b class="vimtag">*<a name="E695">E695</a>*</b> <b class="vimtag">*<a name="E718">E718</a>*</b>
A Funcref variable is obtained with the |<a href="eval.html#function()">function()</a>| function.	It can be used
in an expression in the place of a function name, before the parenthesis
around the arguments, to invoke the function it refers to.  Example:
<code class="example"></code>
<code class="example">	:let Fn = function("MyFunc")</code>
<code class="example">	:echo Fn()</code>
							<b class="vimtag">*<a name="E704">E704</a>*</b> <b class="vimtag">*<a name="E705">E705</a>*</b> <b class="vimtag">*<a name="E707">E707</a>*</b>
A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
can use "g:" but the following name must still start with a capital.  You
cannot have both a Funcref variable and a function with the same name.

A special case is defining a function and directly assigning its Funcref to a
Dictionary entry.  Example:
<code class="example">	:function dict.init() dict</code>
<code class="example">	:   let self.val = 0</code>
<code class="example">	:endfunction</code>
<code class="example"></code>
The key of the Dictionary can start with a lower case letter.  The actual
function name is not used here.  Also see |<a href="eval.html#numbered-function">numbered-function</a>|.

A Funcref can also be used with the |<a href="eval.html#:call">:call</a>| command:
<code class="example">	:call Fn()</code>
<code class="example">	:call dict.init()</code>
<code class="example"></code>
The name of the referenced function can be obtained with |<a href="eval.html#string()">string()</a>|.
<code class="example">	:let func = string(Fn)</code>
<code class="example"></code>
You can use |<a href="eval.html#call()">call()</a>| to invoke a Funcref and use a list variable for the
arguments:
<code class="example">	:let r = call(Fn, mylist)</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.3 Lists </code>
						<b class="vimtag">*<a name="list">list</a>*</b> <b class="vimtag">*<a name="List">List</a>*</b> <b class="vimtag">*<a name="Lists">Lists</a>*</b> <b class="vimtag">*<a name="E686">E686</a>*</b>
A List is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.	Items can be added and removed at any
position in the sequence.


<code class="section">List creation </code>
							<b class="vimtag">*<a name="E696">E696</a>*</b> <b class="vimtag">*<a name="E697">E697</a>*</b>
A List is created with a comma separated list of items in square brackets.
Examples:
<code class="example">	:let mylist = [1, two, 3, "four"]</code>
<code class="example">	:let emptylist = []</code>
<code class="example"></code>
An item can be any expression.	Using a List for an item creates a
List of Lists:
<code class="example">	:let nestlist = [[11, 12], [21, 22], [31, 32]]</code>
<code class="example"></code>
An extra comma after the last item is ignored.


<code class="section">List index </code>
							<b class="vimtag">*<a name="list-index">list-index</a>*</b> <b class="vimtag">*<a name="E684">E684</a>*</b>
An item in the List can be accessed by putting the index in square brackets
after the List.  Indexes are zero-based, thus the first item has index zero.
<code class="example">	:let item = mylist[0]		" get the first item: 1</code>
<code class="example">	:let item = mylist[2]		" get the third item: 3</code>
<code class="example"></code>
When the resulting item is a list this can be repeated:
<code class="example">	:let item = nestlist[0][1]	" get the first list, second item: 12</code>

A negative index is counted from the end.  Index -1 refers to the last item in
the List, -2 to the last but one item, etc.
<code class="example">	:let last = mylist[-1]		" get the last item: "four"</code>
<code class="example"></code>
To avoid an error for an invalid index use the |<a href="eval.html#get()">get()</a>| function.  When an item
is not available it returns zero or the default value you specify:
<code class="example">	:echo get(mylist, idx)</code>
<code class="example">	:echo get(mylist, idx, "NONE")</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">List concatenation </code>

Two lists can be concatenated with the "+" operator:
<code class="example">	:let longlist = mylist + [5, 6]</code>
<code class="example">	:let mylist += [7, 8]</code>
<code class="example"></code>
To prepend or append an item turn the item into a list by putting [] around
it.  To change a list in-place see |<a href="eval.html#list-modification">list-modification</a>| below.


<code class="section">Sublist </code>

A part of the List can be obtained by specifying the first and last index,
separated by a colon in square brackets:
<code class="example">	:let shortlist = mylist[2:-1]	" get List [3, "four"]</code>
<code class="example"></code>
Omitting the first index is similar to zero.  Omitting the last index is
similar to -1.
<code class="example">	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]</code>
<code class="example">	:let shortlist = mylist[2:2]	" List with one item: [3]</code>
<code class="example">	:let otherlist = mylist[:]	" make a copy of the List</code>
<code class="example"></code>
If the first index is beyond the last item of the List or the second item is
before the first item, the result is an empty list.  There is no error
message.

If the second index is equal to or greater than the length of the list the
length minus one is used:
<code class="example">	:let mylist = [0, 1, 2, 3]</code>
<code class="example">	:echo mylist[2:8]		" result: [2, 3]</code>
<code class="example"></code>
<code class="note">NOTE:</code> mylist[s:e] means using the variable "s:e" as index.  Watch out for
using a single letter variable before the ":".	Insert a space when needed:
mylist[s : e].


<code class="section">List identity </code>
							<b class="vimtag">*<a name="list-identity">list-identity</a>*</b>
When variable "aa" is a list and you assign it to another variable "bb", both
variables refer to the same list.  Thus changing the list "aa" will also
change "bb":
<code class="example">	:let aa = [1, 2, 3]</code>
<code class="example">	:let bb = aa</code>
<code class="example">	:call add(aa, 4)</code>
<code class="example">	:echo bb</code>
	[1, 2, 3, 4]

Making a copy of a list is done with the |<a href="eval.html#copy()">copy()</a>| function.  Using [:] also
works, as explained above.  This creates a shallow copy of the list: Changing
a list item in the list will also change the item in the copied list:
<code class="example">	:let aa = [[1, 'a'], 2, 3]</code>
<code class="example">	:let bb = copy(aa)</code>
<code class="example">	:call add(aa, 4)</code>
<code class="example">	:let aa[0][1] = 'aaa'</code>
<code class="example">	:echo aa</code>
&lt;	[[1, aaa], 2, 3, 4]
<code class="example">	:echo bb</code>
	[[1, aaa], 2, 3]

To make a completely independent list use |<a href="eval.html#deepcopy()">deepcopy()</a>|.  This also makes a
copy of the values in the list, recursively.  Up to a hundred levels deep.

The operator "is" can be used to check if two variables refer to the same
List.  "isnot" does the opposite.  In contrast "==" compares if two lists have
the same value.
<code class="example">	:let alist = [1, 2, 3]</code>
<code class="example">	:let blist = [1, 2, 3]</code>
<code class="example">	:echo alist is blist</code>
&lt;	0
<code class="example">	:echo alist == blist</code>
	1

<code class="note">Note</code> about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, as with using "==".  There is one
exception: When comparing a number with a string they are considered
different.  There is no automatic type conversion, as with using "==" on
variables.  Example:
<code class="example">	echo 4 == "4"</code>
&lt;	1
<code class="example">	echo [4] == ["4"]</code>
	0

Thus comparing Lists is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a list:
<code class="example"></code>
<code class="example">	:let a = 5</code>
<code class="example">	:let b = "5"</code>
<code class="example">	:echo a == b</code>
&lt;	1
<code class="example">	:echo [a] == [b]</code>
	0


<code class="section">List unpack </code>

To unpack the items in a list to individual variables, put the variables in
square brackets, like list items:
<code class="example">	:let [var1, var2] = mylist</code>
<code class="example"></code>
When the number of variables does not match the number of items in the list
this produces an error.  To handle any extra items from the list append ";"
and a variable name:
<code class="example">	:let [var1, var2; rest] = mylist</code>
<code class="example"></code>
This works like:
<code class="example">	:let var1 = mylist[0]</code>
<code class="example">	:let var2 = mylist[1]</code>
<code class="example">	:let rest = mylist[2:]</code>
<code class="example"></code>
Except that there is no error if there are only two items.  "rest" will be an
empty list then.


<code class="section">List modification </code>
							<b class="vimtag">*<a name="list-modification">list-modification</a>*</b>
To change a specific item of a list use |<a href="eval.html#:let">:let</a>| this way:
<code class="example">	:let list[4] = "four"</code>
<code class="example">	:let listlist[0][3] = item</code>
<code class="example"></code>
To change part of a list you can specify the first and last item to be
modified.  The value must at least have the number of items in the range:
<code class="example">	:let list[3:5] = [3, 4, 5]</code>
<code class="example"></code>
Adding and removing items from a list is done with functions.  Here are a few
examples:
<code class="example">	:call insert(list, 'a')		" prepend item 'a'</code>
<code class="example">	:call insert(list, 'a', 3)	" insert item 'a' before list[3]</code>
<code class="example">	:call add(list, "new")		" append String item</code>
<code class="example">	:call add(list, [1, 2])		" append a List as one new item</code>
<code class="example">	:call extend(list, [1, 2])	" extend the list with two more items</code>
<code class="example">	:let i = remove(list, 3)	" remove item 3</code>
<code class="example">	:unlet list[3]			" idem</code>
<code class="example">	:let l = remove(list, 3, -1)	" remove items 3 to last item</code>
<code class="example">	:unlet list[3 : ]		" idem</code>
<code class="example">	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'</code>
<code class="example"></code>
Changing the order of items in a list:
<code class="example">	:call sort(list)		" sort a list alphabetically</code>
<code class="example">	:call reverse(list)		" reverse the order of items</code>
<code class="example">	:call uniq(sort(list))		" sort and remove duplicates</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">For loop </code>

The |<a href="eval.html#:for">:for</a>| loop executes commands for each item in a list.  A variable is set
to each item in the list in sequence.  Example:
<code class="example">	:for item in mylist</code>
<code class="example">	:   call Doit(item)</code>
<code class="example">	:endfor</code>
<code class="example"></code>
This works like:
<code class="example">	:let index = 0</code>
<code class="example">	:while index &lt; len(mylist)</code>
<code class="example">	:   let item = mylist[index]</code>
<code class="example">	:   :call Doit(item)</code>
<code class="example">	:   let index = index + 1</code>
<code class="example">	:endwhile</code>
<code class="example"></code>
If all you want to do is modify each item in the list then the |<a href="eval.html#map()">map()</a>|
function will be a simpler method than a for loop.

Just like the |<a href="eval.html#:let">:let</a>| command, |<a href="eval.html#:for">:for</a>| also accepts a list of variables.	This
requires the argument to be a list of lists.
<code class="example">	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]</code>
<code class="example">	:   call Doit(lnum, col)</code>
<code class="example">	:endfor</code>
<code class="example"></code>
This works like a |<a href="eval.html#:let">:let</a>| command is done for each list item.  Again, the types
must remain the same to avoid an error.

It is also possible to put remaining items in a List variable:
<code class="example">	:for [i, j; rest] in listlist</code>
<code class="example">	:   call Doit(i, j)</code>
<code class="example">	:   if !empty(rest)</code>
<code class="example">	:      echo "remainder: " . string(rest)</code>
<code class="example">	:   endif</code>
<code class="example">	:endfor</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">List functions </code>
						<b class="vimtag">*<a name="E714">E714</a>*</b>
Functions that are useful with a List:
<code class="example">	:let r = call(funcname, list)	" call a function with an argument list</code>
<code class="example">	:if empty(list)			" check if list is empty</code>
<code class="example">	:let l = len(list)		" number of items in list</code>
<code class="example">	:let big = max(list)		" maximum value in list</code>
<code class="example">	:let small = min(list)		" minimum value in list</code>
<code class="example">	:let xs = count(list, 'x')	" count nr of times 'x' appears in list</code>
<code class="example">	:let i = index(list, 'x')	" index of first 'x' in list</code>
<code class="example">	:let lines = getline(1, 10)	" get ten text lines from buffer</code>
<code class="example">	:call append('$', lines)	" append text lines in buffer</code>
<code class="example">	:let list = split("a b c")	" create list from items in a string</code>
<code class="example">	:let string = join(list, ', ')	" create string from list items</code>
<code class="example">	:let s = string(list)		" String representation of list</code>
<code class="example">	:call map(list, '"&gt;&gt; " . v:val')  " prepend "&gt;&gt; " to each item</code>
<code class="example"></code>
Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a list:
<code class="example">	:exe 'let sum = ' . join(nrlist, '+')</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.4 Dictionaries </code>
					<b class="vimtag">*<a name="dict">dict</a>*</b> <b class="vimtag">*<a name="Dictionaries">Dictionaries</a>*</b> <b class="vimtag">*<a name="Dictionary">Dictionary</a>*</b>
A Dictionary is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.


<code class="section">Dictionary creation </code>
						<b class="vimtag">*<a name="E720">E720</a>*</b> <b class="vimtag">*<a name="E721">E721</a>*</b> <b class="vimtag">*<a name="E722">E722</a>*</b> <b class="vimtag">*<a name="E723">E723</a>*</b>
A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples:
<code class="example">	:let mydict = <code class="special">{1: 'one', 2: 'two', 3: 'three'}</code></code>
<code class="example">	:let emptydict = <code class="special">{}</code></code>
							<b class="vimtag">*<a name="E713">E713</a>*</b> <b class="vimtag">*<a name="E716">E716</a>*</b> <b class="vimtag">*<a name="E717">E717</a>*</b>
A key is always a String.  You can use a Number, it will be converted to a
String automatically.  Thus the String '4' and the number 4 will find the same
entry.	<code class="note">Note</code> that the String '04' and the Number 04 are different, since the
Number will be converted to the String '4'.  The empty string can be used as a
key.

A value can be any expression.	Using a Dictionary for a value creates a
nested Dictionary:
<code class="example">	:let nestdict = <code class="special">{1: {11: 'a', 12: 'b'}</code>, 2: <code class="special">{21: 'c'}</code>}</code>
<code class="example"></code>
An extra comma after the last entry is ignored.


<code class="section">Accessing entries </code>

The normal way to access an entry is by putting the key in square brackets:
<code class="example">	:let val = mydict["one"]</code>
<code class="example">	:let mydict["four"] = 4</code>
<code class="example"></code>
You can add new entries to an existing Dictionary this way, unlike Lists.

For keys that consist entirely of letters, digits and underscore the following
form can be used |<a href="eval.html#expr-entry">expr-entry</a>|:
<code class="example">	:let val = mydict.one</code>
<code class="example">	:let mydict.four = 4</code>
<code class="example"></code>
Since an entry can be any type, also a List and a Dictionary, the indexing and
key lookup can be repeated:
<code class="example">	:echo dict.key[idx].key</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Dictionary to List conversion </code>

You may want to loop over the entries in a dictionary.	For this you need to
turn the Dictionary into a List and pass it to |<a href="eval.html#:for">:for</a>|.

Most often you want to loop over the keys, using the |<a href="eval.html#keys()">keys()</a>| function:
<code class="example">	:for key in keys(mydict)</code>
<code class="example">	:   echo key . ': ' . mydict[key]</code>
<code class="example">	:endfor</code>
<code class="example"></code>
The List of keys is unsorted.  You may want to sort them first:
<code class="example">	:for key in sort(keys(mydict))</code>
<code class="example"></code>
To loop over the values use the |<a href="eval.html#values()">values()</a>| function:
<code class="example">	:for v in values(mydict)</code>
<code class="example">	:   echo "value: " . v</code>
<code class="example">	:endfor</code>
<code class="example"></code>
If you want both the key and the value use the |<a href="eval.html#items()">items()</a>| function.  It returns
a List in which each item is a	List with two items, the key and the value:
<code class="example">	:for [key, value] in items(mydict)</code>
<code class="example">	:   echo key . ': ' . value</code>
<code class="example">	:endfor</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Dictionary identity </code>
							<b class="vimtag">*<a name="dict-identity">dict-identity</a>*</b>
Just like Lists you need to use |<a href="eval.html#copy()">copy()</a>| and |<a href="eval.html#deepcopy()">deepcopy()</a>| to make a copy of a
Dictionary.  Otherwise, assignment results in referring to the same
Dictionary:
<code class="example">	:let onedict = <code class="special">{'a': 1, 'b': 2}</code></code>
<code class="example">	:let adict = onedict</code>
<code class="example">	:let adict['a'] = 11</code>
<code class="example">	:echo onedict['a']</code>
<code class="example">	11</code>
<code class="example"></code>
Two Dictionaries compare equal if all the key-value pairs compare equal.  For
more info see |<a href="eval.html#list-identity">list-identity</a>|.


<code class="section">Dictionary modification </code>
							<b class="vimtag">*<a name="dict-modification">dict-modification</a>*</b>
To change an already existing entry of a Dictionary, or to add a new entry,
use |<a href="eval.html#:let">:let</a>| this way:
<code class="example">	:let dict[4] = "four"</code>
<code class="example">	:let dict['one'] = item</code>
<code class="example"></code>
Removing an entry from a Dictionary is done with |<a href="eval.html#remove()">remove()</a>| or |<a href="eval.html#:unlet">:unlet</a>|.
Three ways to remove the entry with key "aaa" from dict:
<code class="example">	:let i = remove(dict, 'aaa')</code>
<code class="example">	:unlet dict.aaa</code>
<code class="example">	:unlet dict['aaa']</code>
<code class="example"></code>
Merging a Dictionary with another is done with |<a href="eval.html#extend()">extend()</a>|:
<code class="example">	:call extend(adict, bdict)</code>
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
<code class="note">Note</code> that the order of entries in a Dictionary is irrelevant, thus don't
expect ":echo adict" to show the items from bdict after the older entries in
adict.

Weeding out entries from a Dictionary can be done with |<a href="eval.html#filter()">filter()</a>|:
<code class="example">	:call filter(dict, 'v:val =~ "x"')</code>
This removes all entries from "dict" with a value not matching 'x'.


<code class="section">Dictionary function </code>
				<b class="vimtag">*<a name="Dictionary-function">Dictionary-function</a>*</b> <b class="vimtag">*<a name="self">self</a>*</b> <b class="vimtag">*<a name="E725">E725</a>*</b> <b class="vimtag">*<a name="E862">E862</a>*</b>
When a function is defined with the "dict" attribute it can be used in a
special way with a dictionary.	Example:
<code class="example">	:function Mylen() dict</code>
<code class="example">	:   return len(self.data)</code>
<code class="example">	:endfunction</code>
<code class="example">	:let mydict = <code class="special">{'data': [0, 1, 2, 3], 'len': function("Mylen")}</code></code>
<code class="example">	:echo mydict.len()</code>
<code class="example"></code>
This is like a method in object oriented programming.  The entry in the
Dictionary is a |<a href="eval.html#Funcref">Funcref</a>|.  The local variable "self" refers to the dictionary
the function was invoked from.

It is also possible to add a function without the "dict" attribute as a
Funcref to a Dictionary, but the "self" variable is not available then.

				<b class="vimtag">*<a name="numbered-function">numbered-function</a>*</b> <b class="vimtag">*<a name="anonymous-function">anonymous-function</a>*</b>
To avoid the extra name for the function it can be defined and directly
assigned to a Dictionary in this way:
<code class="example">	:let mydict = <code class="special">{'data': [0, 1, 2, 3]}</code></code>
<code class="example">	:function mydict.len()</code>
<code class="example">	:   return len(self.data)</code>
<code class="example">	:endfunction</code>
<code class="example">	:echo mydict.len()</code>
<code class="example"></code>
The function will then get a number and the value of dict.len is a |<a href="eval.html#Funcref">Funcref</a>|
that references this function.	The function can only be used through a
|<a href="eval.html#Funcref">Funcref</a>|.  It will automatically be deleted when there is no |<a href="eval.html#Funcref">Funcref</a>|
remaining that refers to it.

It is not necessary to use the "dict" attribute for a numbered function.

If you get an error for a numbered function, you can find out what it is with
a trick.  Assuming the function is 42, the command is:
<code class="example">	:function <code class="special">{42}</code></code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Functions for Dictionaries </code>
							<b class="vimtag">*<a name="E715">E715</a>*</b>
Functions that can be used with a Dictionary:
<code class="example">	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"</code>
<code class="example">	:if empty(dict)			" TRUE if dict is empty</code>
<code class="example">	:let l = len(dict)		" number of items in dict</code>
<code class="example">	:let big = max(dict)		" maximum value in dict</code>
<code class="example">	:let small = min(dict)		" minimum value in dict</code>
<code class="example">	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict</code>
<code class="example">	:let s = string(dict)		" String representation of dict</code>
<code class="example">	:call map(dict, '"&gt;&gt; " . v:val')  " prepend "&gt;&gt; " to each item</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">1.5 More about variables </code>
							<b class="vimtag">*<a name="more-variables">more-variables</a>*</b>
If you need to know the type of a variable or expression, use the |<a href="eval.html#type()">type()</a>|
function.

When the '!' flag is included in the 'viminfo' option, global variables that
start with an uppercase letter, and don't contain a lowercase letter, are
stored in the viminfo file |<a href="starting.html#viminfo-file">viminfo-file</a>|.

When the 'sessionoptions' option contains "global", global variables that
start with an uppercase letter and contain at least one lowercase letter are
stored in the session file |<a href="starting.html#session-file">session-file</a>|.

<code class="section">variable name		can be stored where </code>
my_var_6		not
My_Var_6		session file
MY_VAR_6		viminfo file


It's possible to form a variable name with curly braces, see
|<a href="eval.html#curly-braces-names">curly-braces-names</a>|.

</pre><hr><pre>2. Expression syntax					<b class="vimtag">*<a name="expression-syntax">expression-syntax</a>*</b>

Expression syntax summary, from least to most significant:

|<a href="eval.html#expr1">expr1</a>| expr2 ? expr1 : expr1	if-then-else

|<a href="eval.html#expr2">expr2</a>|	expr3 || expr3 ..	logical OR

|<a href="eval.html#expr3">expr3</a>|	expr4 &amp;&amp; expr4 ..	logical AND

|<a href="eval.html#expr4">expr4</a>|	expr5 == expr5		equal
	expr5 != expr5		not equal
	expr5 &gt;	 expr5		greater than
	expr5 &gt;= expr5		greater than or equal
	expr5 &lt;	 expr5		smaller than
	expr5 &lt;= expr5		smaller than or equal
	expr5 =~ expr5		regexp matches
	expr5 !~ expr5		regexp doesn't match

	expr5 ==? expr5		equal, ignoring case
	expr5 ==# expr5		equal, match case
	etc.			As above, append ? for ignoring case, # for
				matching case

	expr5 is expr5		same |<a href="eval.html#List">List</a>| instance
	expr5 isnot expr5	different |<a href="eval.html#List">List</a>| instance

|<a href="eval.html#expr5">expr5</a>|	expr6 +	 expr6 ..	number addition or list concatenation
	expr6 -	 expr6 ..	number subtraction
	expr6 .	 expr6 ..	string concatenation

|<a href="eval.html#expr6">expr6</a>|	expr7 *	 expr7 ..	number multiplication
	expr7 /	 expr7 ..	number division
	expr7 %	 expr7 ..	number modulo

|<a href="eval.html#expr7">expr7</a>|	! expr7			logical NOT
	- expr7			unary minus
	+ expr7			unary plus

|<a href="eval.html#expr8">expr8</a>|	expr8[expr1]		byte of a String or item of a |<a href="eval.html#List">List</a>|
	expr8[expr1 : expr1]	substring of a String or sublist of a |<a href="eval.html#List">List</a>|
	expr8.name		entry in a |<a href="eval.html#Dictionary">Dictionary</a>|
	expr8(expr1, ...)	function call with |<a href="eval.html#Funcref">Funcref</a>| variable

|<a href="eval.html#expr9">expr9</a>| number			number constant
	"string"		string constant, backslash is special
	'string'		string constant, ' is doubled
	[expr1, ...]		|<a href="eval.html#List">List</a>|
	<code class="special">{expr1: expr1, ...}</code>	|<a href="eval.html#Dictionary">Dictionary</a>|
	&amp;option			option value
	(expr1)			nested expression
	variable		internal variable
	va<code class="special">{ria}</code>ble		internal variable with curly braces
	$VAR			environment variable
	@r			contents of register 'r'
	function(expr1, ...)	function call
	func<code class="special">{ti}</code>on(expr1, ...)	function call with curly braces


".." indicates that the operations in this level can be concatenated.
Example:
<code class="example">	&amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</code>
<code class="example"></code>
All expressions within one level are parsed from left to right.


expr1							<b class="vimtag">*<a name="expr1">expr1</a>*</b> <b class="vimtag">*<a name="E109">E109</a>*</b>
</pre><hr><pre>
expr2 ? expr1 : expr1

The expression before the '?' is evaluated to a number.  If it evaluates to
non-zero, the result is the value of the expression between the '?' and ':',
otherwise the result is the value of the expression after the ':'.
Example:
<code class="example">	:echo lnum == 1 ? "top" : lnum</code>
<code class="example"></code>
Since the first expression is an "expr2", it cannot contain another ?:.  The
other two expressions can, thus allow for recursive use of ?:.
Example:
<code class="example">	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum</code>
<code class="example"></code>
To keep this readable, using |<a href="repeat.html#line-continuation">line-continuation</a>| is suggested:
<code class="example">	:echo lnum == 1</code>
<code class="example">	:\	? "top"</code>
<code class="example">	:\	: lnum == 1000</code>
<code class="example">	:\		? "last"</code>
<code class="example">	:\		: lnum</code>
<code class="example"></code>
You should always put a space before the ':', otherwise it can be mistaken for
use in a variable such as "a:1".


expr2 and expr3						<b class="vimtag">*<a name="expr2">expr2</a>*</b> <b class="vimtag">*<a name="expr3">expr3</a>*</b>
</pre><hr><pre>
					<b class="vimtag">*<a name="expr-barbar">expr-barbar</a>*</b> <b class="vimtag">*<a name="expr-&&">expr-&amp;&amp;</a>*</b>
The "||" and "&amp;&amp;" operators take one argument on each side.  The arguments
are (converted to) Numbers.  The result is:

<code class="section">	 input				 output </code>
<code class="section">n1		n2		n1 || n2	n1 &amp;&amp; n2 </code>
zero		zero		zero		zero
zero		non-zero	non-zero	zero
non-zero	zero		non-zero	zero
non-zero	non-zero	non-zero	non-zero

The operators can be concatenated, for example:
<code class="example"></code>
<code class="example">	&amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</code>
<code class="example"></code>
<code class="note">Note</code> that "&amp;&amp;" takes precedence over "||", so this has the meaning of:
<code class="example"></code>
<code class="example">	&amp;nu || (&amp;list &amp;&amp; &amp;shell == "csh")</code>
<code class="example"></code>
Once the result is known, the expression "short-circuits", that is, further
arguments are not evaluated.  This is like what happens in C.  For example:
<code class="example"></code>
<code class="example">	let a = 1</code>
<code class="example">	echo a || b</code>
<code class="example"></code>
This is valid even if there is no variable called "b" because "a" is non-zero,
so the result must be non-zero.  Similarly below:
<code class="example"></code>
<code class="example">	echo exists("b") &amp;&amp; b == "yes"</code>
<code class="example"></code>
This is valid whether "b" has been defined or not.  The second clause will
only be evaluated if "b" has been defined.


expr4							<b class="vimtag">*<a name="expr4">expr4</a>*</b>
</pre><hr><pre>
expr5 <code class="special">{cmp}</code> expr5

Compare two expr5 expressions, resulting in a 0 if it evaluates to false, or 1
if it evaluates to true.

			<b class="vimtag">*<a name="expr-%20%20">expr-==</a>*</b>  <b class="vimtag">*<a name="expr-!%20">expr-!=</a>*</b>  <b class="vimtag">*<a name="expr-%3E">expr-&gt;</a>*</b>	 <b class="vimtag">*<a name="expr-%3E%20">expr-&gt;=</a>*</b>
			<b class="vimtag">*<a name="expr-%3C">expr-&lt;</a>*</b>   <b class="vimtag">*<a name="expr-%3C%20">expr-&lt;=</a>*</b>  <b class="vimtag">*<a name="expr-%20%7E">expr-=~</a>*</b>  <b class="vimtag">*<a name="expr-!%7E">expr-!~</a>*</b>
			<b class="vimtag">*<a name="expr-%20%20%23">expr-==#</a>*</b> <b class="vimtag">*<a name="expr-!%20%23">expr-!=#</a>*</b> <b class="vimtag">*<a name="expr-%3E%23">expr-&gt;#</a>*</b>  <b class="vimtag">*<a name="expr-%3E%20%23">expr-&gt;=#</a>*</b>
			<b class="vimtag">*<a name="expr-%3C%23">expr-&lt;#</a>*</b>  <b class="vimtag">*<a name="expr-%3C%20%23">expr-&lt;=#</a>*</b> <b class="vimtag">*<a name="expr-%20%7E%23">expr-=~#</a>*</b> <b class="vimtag">*<a name="expr-!%7E%23">expr-!~#</a>*</b>
			<b class="vimtag">*<a name="expr-%20%20?">expr-==?</a>*</b> <b class="vimtag">*<a name="expr-!%20?">expr-!=?</a>*</b> <b class="vimtag">*<a name="expr-%3E?">expr-&gt;?</a>*</b>  <b class="vimtag">*<a name="expr-%3E%20?">expr-&gt;=?</a>*</b>
			<b class="vimtag">*<a name="expr-%3C?">expr-&lt;?</a>*</b>  <b class="vimtag">*<a name="expr-%3C%20?">expr-&lt;=?</a>*</b> <b class="vimtag">*<a name="expr-%20%7E?">expr-=~?</a>*</b> <b class="vimtag">*<a name="expr-!%7E?">expr-!~?</a>*</b>
			<b class="vimtag">*<a name="expr-is">expr-is</a>*</b> <b class="vimtag">*<a name="expr-isnot">expr-isnot</a>*</b> <b class="vimtag">*<a name="expr-is%23">expr-is#</a>*</b> <b class="vimtag">*<a name="expr-isnot%23">expr-isnot#</a>*</b>
			<b class="vimtag">*<a name="expr-is?">expr-is?</a>*</b> <b class="vimtag">*<a name="expr-isnot?">expr-isnot?</a>*</b>
<code class="section">		use 'ignorecase'    match case	   ignore case </code>
equal			==		==#		==?
not equal		!=		!=#		!=?
greater than		&gt;		&gt;#		&gt;?
greater than or equal	&gt;=		&gt;=#		&gt;=?
smaller than		&lt;		&lt;#		&lt;?
smaller than or equal	&lt;=		&lt;=#		&lt;=?
regexp matches		=~		=~#		=~?
regexp doesn't match	!~		!~#		!~?
same instance		is		is#		is?
different instance	isnot		isnot#		isnot?

Examples:
"abc" ==# "Abc"	  evaluates to 0
"abc" ==? "Abc"	  evaluates to 1
"abc" == "Abc"	  evaluates to 1 if 'ignorecase' is set, 0 otherwise

							<b class="vimtag">*<a name="E691">E691</a>*</b> <b class="vimtag">*<a name="E692">E692</a>*</b>
A |<a href="eval.html#List">List</a>| can only be compared with a |<a href="eval.html#List">List</a>| and only "equal", "not equal" and
"is" can be used.  This compares the values of the list, recursively.
Ignoring case means case is ignored when comparing item values.

							<b class="vimtag">*<a name="E735">E735</a>*</b> <b class="vimtag">*<a name="E736">E736</a>*</b>
A |<a href="eval.html#Dictionary">Dictionary</a>| can only be compared with a |<a href="eval.html#Dictionary">Dictionary</a>| and only "equal", "not
equal" and "is" can be used.  This compares the key/values of the |<a href="eval.html#Dictionary">Dictionary</a>|
recursively.  Ignoring case means case is ignored when comparing item values.

							<b class="vimtag">*<a name="E694">E694</a>*</b>
A |<a href="eval.html#Funcref">Funcref</a>| can only be compared with a |<a href="eval.html#Funcref">Funcref</a>| and only "equal" and "not
equal" can be used.  Case is never ignored.  Whether arguments or a Dictionary
are bound (with a partial) is ignored.  This is so that when a function is
made a member of a Dictionary it is still considered to be the same function.
To compare partials to see if they bind the same argument and Dictionary
values use string():
<code class="example">	echo string(Partial1) == string(Partial2)</code>
<code class="example"></code>
When using "is" or "isnot" with a |<a href="eval.html#List">List</a>| or a |<a href="eval.html#Dictionary">Dictionary</a>| this checks if the
expressions are referring to the same |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| instance.  A copy
of a |<a href="eval.html#List">List</a>| is different from the original |<a href="eval.html#List">List</a>|.  When using "is" without
a |<a href="eval.html#List">List</a>| or a |<a href="eval.html#Dictionary">Dictionary</a>| it is equivalent to using "equal", using "isnot"
equivalent to using "not equal".  Except that a different type means the
values are different:
<code class="example">	echo 4 == '4'</code>
<code class="example">	1</code>
<code class="example">	echo 4 is '4'</code>
<code class="example">	0</code>
<code class="example">	echo 0 is []</code>
<code class="example">	0</code>
"is#"/"isnot#" and "is?"/"isnot?" can be used to match and ignore case.

When comparing a String with a Number, the String is converted to a Number,
and the comparison is done on Numbers.	This means that:
<code class="example">	echo 0 == 'x'</code>
<code class="example">	1</code>
because 'x' converted to a Number is zero.  However:
<code class="example">	echo [0] == ['x']</code>
<code class="example">	0</code>
Inside a List or Dictionary this conversion is not used.

When comparing two Strings, this is done with strcmp() or stricmp().  This
results in the mathematical difference (comparing byte values), not
necessarily the alphabetical difference in the local language.

When using the operators with a trailing '#', or the short version and
'ignorecase' is off, the comparing is done with strcmp(): case matters.

When using the operators with a trailing '?', or the short version and
'ignorecase' is set, the comparing is done with stricmp(): case is ignored.

'smartcase' is not used.

The "=~" and "!~" operators match the lefthand argument with the righthand
argument, which is used as a pattern.  See |<a href="pattern.html#pattern">pattern</a>| for what a pattern is.
This matching is always done like 'magic' was set and 'cpoptions' is empty, no
matter what the actual value of 'magic' or 'cpoptions' is.  This makes scripts
portable.  To avoid backslashes in the regexp pattern to be doubled, use a
single-quote string, see |<a href="eval.html#literal-string">literal-string</a>|.
Since a string is considered to be a single line, a multi-line pattern
(containing \n, backslash-n) will not match.  However, a literal NL character
can be matched like an ordinary character.  Examples:
	"foo\nbar" =~ "\n"	evaluates to 1
	"foo\nbar" =~ "\\n"	evaluates to 0


expr5 and expr6						<b class="vimtag">*<a name="expr5">expr5</a>*</b> <b class="vimtag">*<a name="expr6">expr6</a>*</b>
</pre><hr><pre>expr6 +	 expr6 ..	Number addition or |<a href="eval.html#List">List</a>| concatenation	<b class="vimtag">*<a name="expr-+">expr-+</a>*</b>
expr6 -	 expr6 ..	Number subtraction			<b class="vimtag">*<a name="expr--">expr--</a>*</b>
expr6 .	 expr6 ..	String concatenation			<b class="vimtag">*<a name="expr-.">expr-.</a>*</b>

For |<a href="eval.html#Lists">Lists</a>| only "+" is possible and then both expr6 must be a list.  The
result is a new list with the two lists Concatenated.

expr7 <b class="vimtag">*<a name="	 expr7 ..	Number multiplication			">	 expr7 ..	Number multiplication			</a>*</b>expr-star*
expr7 /	 expr7 ..	Number division				<b class="vimtag">*<a name="expr-%2F">expr-/</a>*</b>
expr7 %	 expr7 ..	Number modulo				<b class="vimtag">*<a name="expr-%">expr-%</a>*</b>

For all, except ".", Strings are converted to Numbers.
For bitwise operators see |<a href="eval.html#and()">and()</a>|, |<a href="eval.html#or()">or()</a>| and |<a href="eval.html#xor()">xor()</a>|.

<code class="note">Note</code> the difference between "+" and ".":
	"123" + "456" = 579
	"123" . "456" = "123456"

Since '.' has the same precedence as '+' and '-', you need to read:
<code class="example">	1 . 90 + 90.0</code>
As:
<code class="example">	(1 . 90) + 90.0</code>
That works, since the String "190" is automatically converted to the Number
190, which can be added to the Float 90.0.  However:
<code class="example">	1 . 90 * 90.0</code>
Should be read as:
<code class="example">	1 . (90 * 90.0)</code>
Since '.' has lower precedence than '*'.  This does NOT work, since this
attempts to concatenate a Float and a String.

When dividing a Number by zero the result depends on the value:
	  0 / 0  = -0x80000000	(like NaN for Float)
	 &gt;0 / 0  =  0x7fffffff	(like positive infinity)
	 &lt;0 / 0  = -0x7fffffff	(like negative infinity)
	(before Vim 7.2 it was always 0x7fffffff)

When the righthand side of '%' is zero, the result is 0.

None of these work for |<a href="eval.html#Funcref">Funcref</a>|s.

. and % do not work for Float. <b class="vimtag">*<a name="E804">E804</a>*</b>


expr7							<b class="vimtag">*<a name="expr7">expr7</a>*</b>
</pre><hr><pre>! expr7			logical NOT		<b class="vimtag">*<a name="expr-!">expr-!</a>*</b>
- expr7			unary minus		<b class="vimtag">*<a name="expr-unary--">expr-unary--</a>*</b>
+ expr7			unary plus		<b class="vimtag">*<a name="expr-unary-+">expr-unary-+</a>*</b>

For '!' non-zero becomes zero, zero becomes one.
For '-' the sign of the number is changed.
For '+' the number is unchanged.

A String will be converted to a Number first.

These three can be repeated and mixed.	Examples:
	!-1	    == 0
	!!8	    == 1
	--9	    == 9


expr8							<b class="vimtag">*<a name="expr8">expr8</a>*</b>
</pre><hr><pre>expr8[expr1]		item of String or |<a href="eval.html#List">List</a>|	<b class="vimtag">*<a name="expr-[]">expr-[]</a>*</b> <b class="vimtag">*<a name="E111">E111</a>*</b>
							<b class="vimtag">*<a name="E909">E909</a>*</b> <b class="vimtag">*<a name="subscript">subscript</a>*</b>
If expr8 is a Number or String this results in a String that contains the
expr1'th single byte from expr8.  expr8 is used as a String, expr1 as a
Number.  This doesn't recognize multi-byte encodings, see |<a href="eval.html#byteidx()">byteidx()</a>| for
an alternative, or use `split()` to turn the string into a list of characters.

Index zero gives the first byte.  This is like it works in C.  Careful:
text column numbers start with one!  Example, to get the byte under the
cursor:
<code class="example">	:let c = getline(".")[col(".") - 1]</code>
<code class="example"></code>
If the length of the String is less than the index, the result is an empty
String.  A negative index always results in an empty string (reason: backward
compatibility).  Use [-1:] to get the last byte.

If expr8 is a |<a href="eval.html#List">List</a>| then it results the item at index expr1.  See |<a href="eval.html#list-index">list-index</a>|
for possible index values.  If the index is out of range this results in an
error.	Example:
<code class="example">	:let item = mylist[-1]		" get last item</code>
<code class="example"></code>
Generally, if a |<a href="eval.html#List">List</a>| index is equal to or higher than the length of the
|<a href="eval.html#List">List</a>|, or more negative than the length of the |<a href="eval.html#List">List</a>|, this results in an
error.


expr8[expr1a : expr1b]	substring or sublist		<b class="vimtag">*<a name="expr-[:]">expr-[:]</a>*</b>

If expr8 is a Number or String this results in the substring with the bytes
from expr1a to and including expr1b.  expr8 is used as a String, expr1a and
expr1b are used as a Number.  This doesn't recognize multi-byte encodings, see
|<a href="eval.html#byteidx()">byteidx()</a>| for computing the indexes.

If expr1a is omitted zero is used.  If expr1b is omitted the length of the
string minus one is used.

A negative number can be used to measure from the end of the string.  -1 is
the last character, -2 the last but one, etc.

If an index goes out of range for the string characters are omitted.  If
expr1b is smaller than expr1a the result is an empty string.

Examples:
<code class="example">	:let c = name[-1:]		" last byte of a string</code>
<code class="example">	:let c = name[-2:-2]		" last but one byte of a string</code>
<code class="example">	:let s = line(".")[4:]		" from the fifth byte to the end</code>
<code class="example">	:let s = s[:-3]			" remove last two bytes</code>

							<b class="vimtag">*<a name="sublist">sublist</a>*</b> <b class="vimtag">*<a name="slice">slice</a>*</b>
If expr8 is a |<a href="eval.html#List">List</a>| this results in a new |<a href="eval.html#List">List</a>| with the items indicated by
the indexes expr1a and expr1b.	This works like with a String, as explained
just above, except that indexes out of range cause an error.  Examples:
<code class="example">	:let l = mylist[:3]		" first four items</code>
<code class="example">	:let l = mylist[4:4]		" List with one item</code>
<code class="example">	:let l = mylist[:]		" shallow copy of a List</code>
<code class="example"></code>
Using expr8[expr1] or expr8[expr1a : expr1b] on a |<a href="eval.html#Funcref">Funcref</a>| results in an
error.

Watch out for confusion between a namespace and a variable followed by a colon
for a sublist:
<code class="example">	mylist[n:]     " uses variable n</code>
<code class="example">	mylist[s:]     " uses namespace s:, error!</code>
<code class="example"></code>
<code class="example"></code>
expr8.name		entry in a |<a href="eval.html#Dictionary">Dictionary</a>|		<b class="vimtag">*<a name="expr-entry">expr-entry</a>*</b>

If expr8 is a |<a href="eval.html#Dictionary">Dictionary</a>| and it is followed by a dot, then the following
name will be used as a key in the |<a href="eval.html#Dictionary">Dictionary</a>|.  This is just like:
expr8[name].

The name must consist of alphanumeric characters, just like a variable name,
but it may start with a number.  Curly braces cannot be used.

There must not be white space before or after the dot.

Examples:
<code class="example">	:let dict = <code class="special">{"one": 1, 2: "two"}</code></code>
<code class="example">	:echo dict.one</code>
<code class="example">	:echo dict .2</code>
<code class="example"></code>
<code class="note">Note</code> that the dot is also used for String concatenation.  To avoid confusion
always put spaces around the dot for String concatenation.


expr8(expr1, ...)	|<a href="eval.html#Funcref">Funcref</a>| function call

When expr8 is a |<a href="eval.html#Funcref">Funcref</a>| type variable, invoke the function it refers to.



							<b class="vimtag">*<a name="expr9">expr9</a>*</b>
number
</pre><hr><pre>number			number constant			<b class="vimtag">*<a name="expr-number">expr-number</a>*</b>
						<b class="vimtag">*<a name="hex-number">hex-number</a>*</b> <b class="vimtag">*<a name="octal-number">octal-number</a>*</b>

Decimal, Hexadecimal (starting with 0x or 0X), or Octal (starting with 0).

						<b class="vimtag">*<a name="floating-point-format">floating-point-format</a>*</b>
Floating point numbers can be written in two forms:

	[-+]<code class="special">{N}</code>.<code class="special">{M}</code>
	[-+]<code class="special">{N}</code>.<code class="special">{M}</code>[eE][-+]<code class="special">{exp}</code>

<code class="special">{N}</code> and <code class="special">{M}</code> are numbers.  Both <code class="special">{N}</code> and <code class="special">{M}</code> must be present and can only
contain digits.
[-+] means there is an optional plus or minus sign.
<code class="special">{exp}</code> is the exponent, power of 10.
Only a decimal point is accepted, not a comma.	No matter what the current
locale is.
{only when compiled with the |<a href="various.html#+float">+float</a>| feature}

Examples:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88

These are INVALID:
	3.		empty <code class="special">{M}</code>
	1e40		missing .<code class="special">{M}</code>

							<b class="vimtag">*<a name="float-pi">float-pi</a>*</b> <b class="vimtag">*<a name="float-e">float-e</a>*</b>
A few useful values to copy&amp;paste:
<code class="example">	:let pi = 3.14159265359</code>
<code class="example">	:let e  = 2.71828182846</code>
<code class="example"></code>
Rationale:
Before floating point was introduced, the text "123.456" was interpreted as
the two numbers "123" and "456", both converted to a string and concatenated,
resulting in the string "123456".  Since this was considered pointless, and we
could not find it intentionally being used in Vim scripts, this backwards
incompatibility was accepted in favor of being able to use the normal notation
for floating point numbers.

						<b class="vimtag">*<a name="floating-point-precision">floating-point-precision</a>*</b>
The precision and range of floating points numbers depends on what "double"
means in the library Vim was compiled with.  There is no way to change this at
runtime.

The default for displaying a |<a href="eval.html#Float">Float</a>| is to use 6 decimal places, like using
printf("%g", f).  You can select something else when using the |<a href="eval.html#printf()">printf()</a>|
function.  Example:
<code class="example">	:echo printf('%.15e', atan(1))</code>
	7.853981633974483e-01



string					<b class="vimtag">*<a name="string">string</a>*</b> <b class="vimtag">*<a name="String">String</a>*</b> <b class="vimtag">*<a name="expr-string">expr-string</a>*</b> <b class="vimtag">*<a name="E114">E114</a>*</b>
</pre><hr><pre>"string"		string constant		<b class="vimtag">*<a name="expr-quote">expr-quote</a>*</b>

<code class="note">Note</code> that double quotes are used.

A string constant accepts these special characters:
\...	three-digit octal number (e.g., "\316")
\..	two-digit octal number (must be followed by non-digit)
\.	one-digit octal number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., "\x1f")
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same as \x..
\X.	same as \x.
\u....	character specified with up to 4 hex numbers, stored according to the
	current value of 'encoding' (e.g., "\u02a4")
\U....	same as \u but allows up to 8 hex numbers.
\b	backspace <code class="special">&lt;BS&gt;</code>
\e	escape <code class="special">&lt;Esc&gt;</code>
\f	formfeed <code class="special">&lt;FF&gt;</code>
\n	newline <code class="special">&lt;NL&gt;</code>
\r	return <code class="special">&lt;CR&gt;</code>
\t	tab <code class="special">&lt;Tab&gt;</code>
\\	backslash
\"	double quote
\<code class="special">&lt;xxx&gt;</code>	Special key named "xxx".  e.g. "\<code class="special">&lt;C-W&gt;</code>" for <code class="keystroke">CTRL-W</code>.  This is for use
	in mappings, the 0x80 byte is escaped.  Don't use <code class="special">&lt;Char-xxxx&gt;</code> to get a
	utf-8 character, use \uxxxx as mentioned above.

<code class="note">Note</code> that "\xff" is stored as the byte 255, which may be invalid in some
encodings.  Use "\u00ff" to store character 255 according to the current value
of 'encoding'.

<code class="note">Note</code> that "\000" and "\x00" force the end of the string.


literal-string						<b class="vimtag">*<a name="literal-string">literal-string</a>*</b> <b class="vimtag">*<a name="E115">E115</a>*</b>
</pre><hr><pre>'string'		string constant			<b class="vimtag">*<a name="expr-'">expr-'</a>*</b>

<code class="note">Note</code> that single quotes are used.

This string is taken as it is.	No backslashes are removed or have a special
meaning.  The only exception is that two quotes stand for one quote.

Single quoted strings are useful for patterns, so that backslashes do not need
to be doubled.	These two commands are equivalent:
<code class="example">	if a =~ "\\s*"</code>
<code class="example">	if a =~ '\s*'</code>
<code class="example"></code>
<code class="example"></code>
option						<b class="vimtag">*<a name="expr-option">expr-option</a>*</b> <b class="vimtag">*<a name="E112">E112</a>*</b> <b class="vimtag">*<a name="E113">E113</a>*</b>
</pre><hr><pre>&amp;option			option value, local value if possible
&amp;g:option		global option value
&amp;l:option		local option value

Examples:
<code class="example">	echo "tabstop is " . &amp;tabstop</code>
<code class="example">	if &amp;insertmode</code>
<code class="example"></code>
Any option name can be used here.  See |<a href="options.html#options">options</a>|.  When using the local value
and there is no buffer-local or window-local value, the global value is used
anyway.


register						<b class="vimtag">*<a name="expr-register">expr-register</a>*</b> <b class="vimtag">*<a name="@r">@r</a>*</b>
</pre><hr><pre>@r			contents of register 'r'

The result is the contents of the named register, as a single string.
Newlines are inserted where required.  To get the contents of the unnamed
register use @" or @@.	See |<a href="change.html#registers">registers</a>| for an explanation of the available
registers.

When using the '=' register you get the expression itself, not what it
evaluates to.  Use |<a href="eval.html#eval()">eval()</a>| to evaluate it.


nesting							<b class="vimtag">*<a name="expr-nesting">expr-nesting</a>*</b> <b class="vimtag">*<a name="E110">E110</a>*</b>
</pre><hr><pre>(expr1)			nested expression


environment variable					<b class="vimtag">*<a name="expr-env">expr-env</a>*</b>
</pre><hr><pre>$VAR			environment variable

The String value of any environment variable.  When it is not defined, the
result is an empty string.
						<b class="vimtag">*<a name="expr-env-expand">expr-env-expand</a>*</b>
<code class="note">Note</code> that there is a difference between using $VAR directly and using
expand("$VAR").  Using it directly will only expand environment variables that
are known inside the current Vim session.  Using expand() will first try using
the environment variables known inside the current Vim session.  If that
fails, a shell will be used to expand the variable.  This can be slow, but it
does expand all variables that the shell knows about.  Example:
<code class="example">	:echo $shell</code>
<code class="example">	:echo expand("$shell")</code>
The first one probably doesn't echo anything, the second echoes the $shell
variable (if your shell supports it).


internal variable					<b class="vimtag">*<a name="expr-variable">expr-variable</a>*</b>
</pre><hr><pre>variable		internal variable
See below |<a href="eval.html#internal-variables">internal-variables</a>|.


function call		<b class="vimtag">*<a name="expr-function">expr-function</a>*</b> <b class="vimtag">*<a name="E116">E116</a>*</b> <b class="vimtag">*<a name="E118">E118</a>*</b> <b class="vimtag">*<a name="E119">E119</a>*</b> <b class="vimtag">*<a name="E120">E120</a>*</b>
</pre><hr><pre>function(expr1, ...)	function call
See below |<a href="eval.html#functions">functions</a>|.


</pre><hr><pre>3. Internal variable				<b class="vimtag">*<a name="internal-variables">internal-variables</a>*</b> <b class="vimtag">*<a name="E461">E461</a>*</b>

An internal variable name can be made up of letters, digits and '_'.  But it
cannot start with a digit.  It's also possible to use curly braces, see
|<a href="eval.html#curly-braces-names">curly-braces-names</a>|.

An internal variable is created with the ":let" command |<a href="eval.html#:let">:let</a>|.
An internal variable is explicitly destroyed with the ":unlet" command
|<a href="eval.html#:unlet">:unlet</a>|.
Using a name that is not an internal variable or refers to a variable that has
been destroyed results in an error.

There are several name spaces for variables.  Which one is to be used is
specified by what is prepended:

		(nothing) In a function: local to a function; otherwise: global
|<a href="eval.html#buffer-variable">buffer-variable</a>|    b:	  Local to the current buffer.
|<a href="eval.html#window-variable">window-variable</a>|    w:	  Local to the current window.
|<a href="eval.html#tabpage-variable">tabpage-variable</a>|   t:	  Local to the current tab page.
|<a href="eval.html#global-variable">global-variable</a>|    g:	  Global.
|<a href="eval.html#local-variable">local-variable</a>|     l:	  Local to a function.
|<a href="eval.html#script-variable">script-variable</a>|    s:	  Local to a |<a href="repeat.html#:source">:source</a>|'ed Vim script.
|<a href="eval.html#function-argument">function-argument</a>|  a:	  Function argument (only inside a function).
|<a href="eval.html#vim-variable">vim-variable</a>|       v:	  Global, predefined by Vim.

The scope name by itself can be used as a |<a href="eval.html#Dictionary">Dictionary</a>|.  For example, to
delete all script-local variables:
<code class="example">	:for k in keys(s:)</code>
<code class="example">	:    unlet s:[k]</code>
<code class="example">	:endfor</code>

						<b class="vimtag">*<a name="buffer-variable">buffer-variable</a>*</b> <b class="vimtag">*<a name="b:var">b:var</a>*</b> <b class="vimtag">*<a name="b:">b:</a>*</b>
A variable name that is preceded with "b:" is local to the current buffer.
Thus you can have several "b:foo" variables, one for each buffer.
This kind of variable is deleted when the buffer is wiped out or deleted with
|<a href="windows.html#:bdelete">:bdelete</a>|.

One local buffer variable is predefined:
					<b class="vimtag">*<a name="b:changedtick">b:changedtick</a>*</b> <b class="vimtag">*<a name="changetick">changetick</a>*</b>
b:changedtick	The total number of changes to the current buffer.  It is
		incremented for each change.  An undo command is also a change
		in this case.  This can be used to perform an action only when
		the buffer has changed.  Example:
<code class="example">		    :if my_changedtick != b:changedtick</code>
<code class="example">		    :	let my_changedtick = b:changedtick</code>
<code class="example">		    :	call My_Update()</code>
<code class="example">		    :endif</code>

						<b class="vimtag">*<a name="window-variable">window-variable</a>*</b> <b class="vimtag">*<a name="w:var">w:var</a>*</b> <b class="vimtag">*<a name="w:">w:</a>*</b>
A variable name that is preceded with "w:" is local to the current window.  It
is deleted when the window is closed.

						<b class="vimtag">*<a name="tabpage-variable">tabpage-variable</a>*</b> <b class="vimtag">*<a name="t:var">t:var</a>*</b> <b class="vimtag">*<a name="t:">t:</a>*</b>
A variable name that is preceded with "t:" is local to the current tab page,
It is deleted when the tab page is closed. {not available when compiled
without the |<a href="various.html#+windows">+windows</a>| feature}

						<b class="vimtag">*<a name="global-variable">global-variable</a>*</b> <b class="vimtag">*<a name="g:var">g:var</a>*</b> <b class="vimtag">*<a name="g:">g:</a>*</b>
Inside functions global variables are accessed with "g:".  Omitting this will
access a variable local to a function.	But "g:" can also be used in any other
place if you like.

						<b class="vimtag">*<a name="local-variable">local-variable</a>*</b> <b class="vimtag">*<a name="l:var">l:var</a>*</b> <b class="vimtag">*<a name="l:">l:</a>*</b>
Inside functions local variables are accessed without prepending anything.
But you can also prepend "l:" if you like.  However, without prepending "l:"
you may run into reserved variable names.  For example "count".  By itself it
refers to "v:count".  Using "l:count" you can have a local variable with the
same name.

						<b class="vimtag">*<a name="script-variable">script-variable</a>*</b> <b class="vimtag">*<a name="s:var">s:var</a>*</b>
In a Vim script variables starting with "s:" can be used.  They cannot be
accessed from outside of the scripts, thus are local to the script.

They can be used in:
- commands executed while the script is sourced
- functions defined in the script
- autocommands defined in the script
- functions and autocommands defined in functions and autocommands which were
  defined in the script (recursively)
- user defined commands defined in the script
Thus not in:
- other scripts sourced from this one
- mappings
- menus
- etc.

Script variables can be used to avoid conflicts with global variable names.
Take this example:
<code class="example"></code>
<code class="example">	let s:counter = 0</code>
<code class="example">	function MyCounter()</code>
<code class="example">	  let s:counter = s:counter + 1</code>
<code class="example">	  echo s:counter</code>
<code class="example">	endfunction</code>
<code class="example">	command Tick call MyCounter()</code>
<code class="example"></code>
You can now invoke "Tick" from any script, and the "s:counter" variable in
that script will not be changed, only the "s:counter" in the script where
"Tick" was defined is used.

Another example that does the same:
<code class="example"></code>
<code class="example">	let s:counter = 0</code>
<code class="example">	command Tick let s:counter = s:counter + 1 | echo s:counter</code>
<code class="example"></code>
When calling a function and invoking a user-defined command, the context for
script variables is set to the script where the function or command was
defined.

The script variables are also available when a function is defined inside a
function that is defined in a script.  Example:
<code class="example"></code>
<code class="example">	let s:counter = 0</code>
<code class="example">	function StartCounting(incr)</code>
<code class="example">	  if a:incr</code>
<code class="example">	    function MyCounter()</code>
<code class="example">	      let s:counter = s:counter + 1</code>
<code class="example">	    endfunction</code>
<code class="example">	  else</code>
<code class="example">	    function MyCounter()</code>
<code class="example">	      let s:counter = s:counter - 1</code>
<code class="example">	    endfunction</code>
<code class="example">	  endif</code>
<code class="example">	endfunction</code>
<code class="example"></code>
This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().

When the same script is sourced again it will use the same script variables.
They will remain valid as long as Vim is running.  This can be used to
maintain a counter:
<code class="example"></code>
<code class="example">	if !exists("s:counter")</code>
<code class="example">	  let s:counter = 1</code>
<code class="example">	  echo "script executed for the first time"</code>
<code class="example">	else</code>
<code class="example">	  let s:counter = s:counter + 1</code>
<code class="example">	  echo "script executed " . s:counter . " times now"</code>
<code class="example">	endif</code>
<code class="example"></code>
<code class="note">Note</code> that this means that filetype plugins don't get a different set of script
variables for each buffer.  Use local buffer variables instead |<a href="eval.html#b:var">b:var</a>|.


Predefined Vim variables:			<b class="vimtag">*<a name="vim-variable">vim-variable</a>*</b> <b class="vimtag">*<a name="v:var">v:var</a>*</b> <b class="vimtag">*<a name="v:">v:</a>*</b>

					<b class="vimtag">*<a name="v:beval_col">v:beval_col</a>*</b> <b class="vimtag">*<a name="beval_col-variable">beval_col-variable</a>*</b>
v:beval_col	The number of the column, over which the mouse pointer is.
		This is the byte index in the |<a href="eval.html#v:beval_lnum">v:beval_lnum</a>| line.
		Only valid while evaluating the 'balloonexpr' option.

					<b class="vimtag">*<a name="v:beval_bufnr">v:beval_bufnr</a>*</b> <b class="vimtag">*<a name="beval_bufnr-variable">beval_bufnr-variable</a>*</b>
v:beval_bufnr	The number of the buffer, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					<b class="vimtag">*<a name="v:beval_lnum">v:beval_lnum</a>*</b> <b class="vimtag">*<a name="beval_lnum-variable">beval_lnum-variable</a>*</b>
v:beval_lnum	The number of the line, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.

					<b class="vimtag">*<a name="v:beval_text">v:beval_text</a>*</b> <b class="vimtag">*<a name="beval_text-variable">beval_text-variable</a>*</b>
v:beval_text	The text under or after the mouse pointer.  Usually a word as
		it is useful for debugging a C program.  'iskeyword' applies,
		but a dot and "-&gt;" before the position is included.  When on a
		']' the text before it is used, including the matching '[' and
		word before it.  When on a Visual area within one line the
		highlighted text is used.
		Only valid while evaluating the 'balloonexpr' option.

					<b class="vimtag">*<a name="v:beval_winnr">v:beval_winnr</a>*</b> <b class="vimtag">*<a name="beval_winnr-variable">beval_winnr-variable</a>*</b>
v:beval_winnr	The number of the window, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.  The first
		window has number zero (unlike most other places where a
		window gets a number).

					<b class="vimtag">*<a name="v:char">v:char</a>*</b> <b class="vimtag">*<a name="char-variable">char-variable</a>*</b>
v:char		Argument for evaluating 'formatexpr' and used for the typed
		character when using <code class="special">&lt;expr&gt;</code> in an abbreviation |<a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a>|.
		It is also used by the |<a href="autocmd.html#InsertCharPre">InsertCharPre</a>| and |<a href="autocmd.html#InsertEnter">InsertEnter</a>| events.

			<b class="vimtag">*<a name="v:charconvert_from">v:charconvert_from</a>*</b> <b class="vimtag">*<a name="charconvert_from-variable">charconvert_from-variable</a>*</b>
v:charconvert_from
		The name of the character encoding of a file to be converted.
		Only valid while evaluating the 'charconvert' option.

			<b class="vimtag">*<a name="v:charconvert_to">v:charconvert_to</a>*</b> <b class="vimtag">*<a name="charconvert_to-variable">charconvert_to-variable</a>*</b>
v:charconvert_to
		The name of the character encoding of a file after conversion.
		Only valid while evaluating the 'charconvert' option.

					<b class="vimtag">*<a name="v:cmdarg">v:cmdarg</a>*</b> <b class="vimtag">*<a name="cmdarg-variable">cmdarg-variable</a>*</b>
v:cmdarg	This variable is used for two purposes:
		1. The extra arguments given to a file read/write command.
		   Currently these are "++enc=" and "++ff=".  This variable is
		   set before an autocommand event for a file read/write
		   command is triggered.  There is a leading space to make it
		   possible to append this variable directly after the
		   read/write command.	<code class="note">Note:</code> The "+cmd" argument isn't
		   included here, because it will be executed anyway.
		2. When printing a PostScript file with ":hardcopy" this is
		   the argument for the ":hardcopy" command.  This can be used
		   in 'printexpr'.

					<b class="vimtag">*<a name="v:cmdbang">v:cmdbang</a>*</b> <b class="vimtag">*<a name="cmdbang-variable">cmdbang-variable</a>*</b>
v:cmdbang	Set like v:cmdarg for a file read/write command.  When a "!"
		was used the value is 1, otherwise it is 0.  <code class="note">Note</code> that this
		can only be used in autocommands.  For user commands |<a href="map.html#%3Cbang%3E">&lt;bang&gt;</a>|
		can be used.

				<b class="vimtag">*<a name="v:completed_item">v:completed_item</a>*</b> <b class="vimtag">*<a name="completed_item-variable">completed_item-variable</a>*</b>
v:completed_item
		|<a href="eval.html#Dictionary">Dictionary</a>| containing the |<a href="insert.html#complete-items">complete-items</a>| for the most
		recently completed word after |<a href="autocmd.html#CompleteDone">CompleteDone</a>|.  The
		|<a href="eval.html#Dictionary">Dictionary</a>| is empty if the completion failed.

					<b class="vimtag">*<a name="v:count">v:count</a>*</b> <b class="vimtag">*<a name="count-variable">count-variable</a>*</b>
v:count		The count given for the last Normal mode command.  Can be used
		to get the count before a mapping.  Read-only.	Example:
<code class="example">	:map _x :<code class="special">&lt;C-U&gt;</code>echo "the count is " . v:count<code class="special">&lt;CR&gt;</code></code>
		<code class="note">Note:</code> The <code class="special">&lt;C-U&gt;</code> is required to remove the line range that you
		get when typing ':' after a count.
		When there are two counts, as in "3d2w", they are multiplied,
		just like what happens in the command, "d6w" for the example.
		Also used for evaluating the 'formatexpr' option.
		"count" also works, for backwards compatibility.

					<b class="vimtag">*<a name="v:count1">v:count1</a>*</b> <b class="vimtag">*<a name="count1-variable">count1-variable</a>*</b>
v:count1	Just like "v:count", but defaults to one when no count is
		used.

						<b class="vimtag">*<a name="v:ctype">v:ctype</a>*</b> <b class="vimtag">*<a name="ctype-variable">ctype-variable</a>*</b>
v:ctype		The current locale setting for characters of the runtime
		environment.  This allows Vim scripts to be aware of the
		current locale encoding.  Technical: it's the value of
		LC_CTYPE.  When not using a locale the value is "C".
		This variable can not be set directly, use the |<a href="mlang.html#:language">:language</a>|
		command.
		See |<a href="mlang.html#multi-lang">multi-lang</a>|.

					<b class="vimtag">*<a name="v:dying">v:dying</a>*</b> <b class="vimtag">*<a name="dying-variable">dying-variable</a>*</b>
v:dying		Normally zero.	When a deadly signal is caught it's set to
		one.  When multiple signals are caught the number increases.
		Can be used in an autocommand to check if Vim didn't
		terminate normally. <code class="special">{only works on Unix}</code>
		Example:
<code class="example">	:au VimLeave * if v:dying |<code class="badlink"> echo "\nAAAAaaaarrrggghhhh!!!\n" </code>| endif</code>
		<code class="note">Note:</code> if another deadly signal is caught when v:dying is one,
		VimLeave autocommands will not be executed.

					<b class="vimtag">*<a name="v:errmsg">v:errmsg</a>*</b> <b class="vimtag">*<a name="errmsg-variable">errmsg-variable</a>*</b>
v:errmsg	Last given error message.  It's allowed to set this variable.
		Example:
<code class="example">	:let v:errmsg = ""</code>
<code class="example">	:silent! next</code>
<code class="example">	:if v:errmsg != ""</code>
<code class="example">	:  ... handle error</code>
		"errmsg" also works, for backwards compatibility.

					<b class="vimtag">*<a name="v:errors">v:errors</a>*</b> <b class="vimtag">*<a name="errors-variable">errors-variable</a>*</b>
v:errors	Errors found by assert functions, such as |<a href="eval.html#assert_true()">assert_true()</a>|.
		This is a list of strings.
		The assert functions append an item when an assert fails.
		To remove old results make it empty:
<code class="example">	:let v:errors = []</code>
		If v:errors is set to anything but a list it is made an empty
		list by the assert function.

					<b class="vimtag">*<a name="v:exception">v:exception</a>*</b> <b class="vimtag">*<a name="exception-variable">exception-variable</a>*</b>
v:exception	The value of the exception most recently caught and not
		finished.  See also |<a href="eval.html#v:throwpoint">v:throwpoint</a>| and |<a href="eval.html#throw-variables">throw-variables</a>|.
		Example:
<code class="example">	:try</code>
<code class="example">	:  throw "oops"</code>
<code class="example">	:catch /.*/</code>
<code class="example">	:  echo "caught" v:exception</code>
<code class="example">	:endtry</code>
		Output: "caught oops".

					<b class="vimtag">*<a name="v:false">v:false</a>*</b> <b class="vimtag">*<a name="false-variable">false-variable</a>*</b>
v:false		A Number with value zero. Used to put "false" in JSON.  See
		|<a href="eval.html#json_encode()">json_encode()</a>|.
		When used as a string this evaluates to "false".
<code class="example">			echo v:false</code>
<code class="section">			false </code>

					<b class="vimtag">*<a name="v:fcs_reason">v:fcs_reason</a>*</b> <b class="vimtag">*<a name="fcs_reason-variable">fcs_reason-variable</a>*</b>
v:fcs_reason	The reason why the |<a href="autocmd.html#FileChangedShell">FileChangedShell</a>| event was triggered.
		Can be used in an autocommand to decide what to do and/or what
		to set v:fcs_choice to.  Possible values:
			deleted		file no longer exists
			conflict	file contents, mode or timestamp was
					changed and buffer is modified
			changed		file contents has changed
			mode		mode of file changed
			time		only file timestamp changed

					<b class="vimtag">*<a name="v:fcs_choice">v:fcs_choice</a>*</b> <b class="vimtag">*<a name="fcs_choice-variable">fcs_choice-variable</a>*</b>
v:fcs_choice	What should happen after a |<a href="autocmd.html#FileChangedShell">FileChangedShell</a>| event was
		triggered.  Can be used in an autocommand to tell Vim what to
		do with the affected buffer:
			reload		Reload the buffer (does not work if
					the file was deleted).
			ask		Ask the user what to do, as if there
					was no autocommand.  Except that when
					only the timestamp changed nothing
					will happen.
			<code class="special">&lt;empty&gt;</code>		Nothing, the autocommand should do
					everything that needs to be done.
		The default is empty.  If another (invalid) value is used then
		Vim behaves like it is empty, there is no warning message.

					<b class="vimtag">*<a name="v:fname_in">v:fname_in</a>*</b> <b class="vimtag">*<a name="fname_in-variable">fname_in-variable</a>*</b>
v:fname_in	The name of the input file.  Valid while evaluating:
<code class="section">			option		used for </code>
			'charconvert'	file to be converted
			'diffexpr'	original file
			'patchexpr'	original file
			'printexpr'	file to be printed
		And set to the swap file name for |<a href="autocmd.html#SwapExists">SwapExists</a>|.

					<b class="vimtag">*<a name="v:fname_out">v:fname_out</a>*</b> <b class="vimtag">*<a name="fname_out-variable">fname_out-variable</a>*</b>
v:fname_out	The name of the output file.  Only valid while
		evaluating:
<code class="section">			option		used for </code>
			'charconvert'	resulting converted file (*)
			'diffexpr'	output of diff
			'patchexpr'	resulting patched file
		(*) When doing conversion for a write command (e.g., ":w
		file") it will be equal to v:fname_in.	When doing conversion
		for a read command (e.g., ":e file") it will be a temporary
		file and different from v:fname_in.

					<b class="vimtag">*<a name="v:fname_new">v:fname_new</a>*</b> <b class="vimtag">*<a name="fname_new-variable">fname_new-variable</a>*</b>
v:fname_new	The name of the new version of the file.  Only valid while
		evaluating 'diffexpr'.

					<b class="vimtag">*<a name="v:fname_diff">v:fname_diff</a>*</b> <b class="vimtag">*<a name="fname_diff-variable">fname_diff-variable</a>*</b>
v:fname_diff	The name of the diff (patch) file.  Only valid while
		evaluating 'patchexpr'.

					<b class="vimtag">*<a name="v:folddashes">v:folddashes</a>*</b> <b class="vimtag">*<a name="folddashes-variable">folddashes-variable</a>*</b>
v:folddashes	Used for 'foldtext': dashes representing foldlevel of a closed
		fold.
		Read-only in the |<a href="eval.html#sandbox">sandbox</a>|. |<a href="fold.html#fold-foldtext">fold-foldtext</a>|

					<b class="vimtag">*<a name="v:foldlevel">v:foldlevel</a>*</b> <b class="vimtag">*<a name="foldlevel-variable">foldlevel-variable</a>*</b>
v:foldlevel	Used for 'foldtext': foldlevel of closed fold.
		Read-only in the |<a href="eval.html#sandbox">sandbox</a>|. |<a href="fold.html#fold-foldtext">fold-foldtext</a>|

					<b class="vimtag">*<a name="v:foldend">v:foldend</a>*</b> <b class="vimtag">*<a name="foldend-variable">foldend-variable</a>*</b>
v:foldend	Used for 'foldtext': last line of closed fold.
		Read-only in the |<a href="eval.html#sandbox">sandbox</a>|. |<a href="fold.html#fold-foldtext">fold-foldtext</a>|

					<b class="vimtag">*<a name="v:foldstart">v:foldstart</a>*</b> <b class="vimtag">*<a name="foldstart-variable">foldstart-variable</a>*</b>
v:foldstart	Used for 'foldtext': first line of closed fold.
		Read-only in the |<a href="eval.html#sandbox">sandbox</a>|. |<a href="fold.html#fold-foldtext">fold-foldtext</a>|

					<b class="vimtag">*<a name="v:hlsearch">v:hlsearch</a>*</b> <b class="vimtag">*<a name="hlsearch-variable">hlsearch-variable</a>*</b>
v:hlsearch	Variable that indicates whether search highlighting is on.
		Setting it makes sense only if 'hlsearch' is enabled which
		requires |<a href="various.html#+extra_search">+extra_search</a>|. Setting this variable to zero acts
		like the |<a href="pattern.html#:nohlsearch">:nohlsearch</a>| command, setting it to one acts like
<code class="example">			let &amp;hlsearch = &amp;hlsearch</code>
		<code class="note">Note</code> that the value is restored when returning from a
		function. |<a href="eval.html#function-search-undo">function-search-undo</a>|.

					<b class="vimtag">*<a name="v:insertmode">v:insertmode</a>*</b> <b class="vimtag">*<a name="insertmode-variable">insertmode-variable</a>*</b>
v:insertmode	Used for the |<a href="autocmd.html#InsertEnter">InsertEnter</a>| and |<a href="autocmd.html#InsertChange">InsertChange</a>| autocommand
		events.  Values:
			i	Insert mode
			r	Replace mode
			v	Virtual Replace mode

						<b class="vimtag">*<a name="v:key">v:key</a>*</b> <b class="vimtag">*<a name="key-variable">key-variable</a>*</b>
v:key		Key of the current item of a |<a href="eval.html#Dictionary">Dictionary</a>|.  Only valid while
		evaluating the expression used with |<a href="eval.html#map()">map()</a>| and |<a href="eval.html#filter()">filter()</a>|.
		Read-only.

						<b class="vimtag">*<a name="v:lang">v:lang</a>*</b> <b class="vimtag">*<a name="lang-variable">lang-variable</a>*</b>
v:lang		The current locale setting for messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_MESSAGES.
		The value is system dependent.
		This variable can not be set directly, use the |<a href="mlang.html#:language">:language</a>|
		command.
		It can be different from |<a href="eval.html#v:ctype">v:ctype</a>| when messages are desired
		in a different language than what is used for character
		encoding.  See |<a href="mlang.html#multi-lang">multi-lang</a>|.

						<b class="vimtag">*<a name="v:lc_time">v:lc_time</a>*</b> <b class="vimtag">*<a name="lc_time-variable">lc_time-variable</a>*</b>
v:lc_time	The current locale setting for time messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_TIME.
		This variable can not be set directly, use the |<a href="mlang.html#:language">:language</a>|
		command.  See |<a href="mlang.html#multi-lang">multi-lang</a>|.

						<b class="vimtag">*<a name="v:lnum">v:lnum</a>*</b> <b class="vimtag">*<a name="lnum-variable">lnum-variable</a>*</b>
v:lnum		Line number for the 'foldexpr' |<a href="fold.html#fold-expr">fold-expr</a>|, 'formatexpr' and
		'indentexpr' expressions, tab page number for 'guitablabel'
		and 'guitabtooltip'.  Only valid while one of these
		expressions is being evaluated.  Read-only when in the
		|<a href="eval.html#sandbox">sandbox</a>|.

					<b class="vimtag">*<a name="v:mouse_win">v:mouse_win</a>*</b> <b class="vimtag">*<a name="mouse_win-variable">mouse_win-variable</a>*</b>
v:mouse_win	Window number for a mouse click obtained with |<a href="eval.html#getchar()">getchar()</a>|.
		First window has number 1, like with |<a href="eval.html#winnr()">winnr()</a>|.  The value is
		zero when there was no mouse button click.

					<b class="vimtag">*<a name="v:mouse_lnum">v:mouse_lnum</a>*</b> <b class="vimtag">*<a name="mouse_lnum-variable">mouse_lnum-variable</a>*</b>
v:mouse_lnum	Line number for a mouse click obtained with |<a href="eval.html#getchar()">getchar()</a>|.
		This is the text line number, not the screen line number.  The
		value is zero when there was no mouse button click.

					<b class="vimtag">*<a name="v:mouse_col">v:mouse_col</a>*</b> <b class="vimtag">*<a name="mouse_col-variable">mouse_col-variable</a>*</b>
v:mouse_col	Column number for a mouse click obtained with |<a href="eval.html#getchar()">getchar()</a>|.
		This is the screen column number, like with |<a href="eval.html#virtcol()">virtcol()</a>|.  The
		value is zero when there was no mouse button click.

					<b class="vimtag">*<a name="v:none">v:none</a>*</b> <b class="vimtag">*<a name="none-variable">none-variable</a>*</b>
v:none		An empty String. Used to put an empty item in JSON.  See
		|<a href="eval.html#json_encode()">json_encode()</a>|.
		When used as a number this evaluates to zero.
		When used as a string this evaluates to "none".
<code class="example">			echo v:none</code>
<code class="section">			none </code>

					<b class="vimtag">*<a name="v:null">v:null</a>*</b> <b class="vimtag">*<a name="null-variable">null-variable</a>*</b>
v:null		An empty String. Used to put "null" in JSON.  See
		|<a href="eval.html#json_encode()">json_encode()</a>|.
		When used as a number this evaluates to zero.
		When used as a string this evaluates to "null".
<code class="example">			echo v:null</code>
<code class="section">			null </code>

					<b class="vimtag">*<a name="v:oldfiles">v:oldfiles</a>*</b> <b class="vimtag">*<a name="oldfiles-variable">oldfiles-variable</a>*</b>
v:oldfiles	List of file names that is loaded from the |<a href="starting.html#viminfo">viminfo</a>| file on
		startup.  These are the files that Vim remembers marks for.
		The length of the List is limited by the ' argument of the
		'viminfo' option (default is 100).
		When the |<a href="starting.html#viminfo">viminfo</a>| file is not used the List is empty.
		Also see |<a href="starting.html#:oldfiles">:oldfiles</a>| and |<a href="cmdline.html#c_%23%3C">c_#&lt;</a>|.
		The List can be modified, but this has no effect on what is
		stored in the |<a href="starting.html#viminfo">viminfo</a>| file later.  If you use values other
		than String this will cause trouble.
		{only when compiled with the |<a href="various.html#+viminfo">+viminfo</a>| feature}

						    <b class="vimtag">*<a name="v:option_new">v:option_new</a>*</b>
v:option_new    New value of the option. Valid while executing an |<a href="autocmd.html#OptionSet">OptionSet</a>|
		autocommand.
						    <b class="vimtag">*<a name="v:option_old">v:option_old</a>*</b>
v:option_old    Old value of the option. Valid while executing an |<a href="autocmd.html#OptionSet">OptionSet</a>|
		autocommand.
						    <b class="vimtag">*<a name="v:option_type">v:option_type</a>*</b>
v:option_type   Scope of the set command. Valid while executing an
		|<a href="autocmd.html#OptionSet">OptionSet</a>| autocommand. Can be either "global" or "local"
					<b class="vimtag">*<a name="v:operator">v:operator</a>*</b> <b class="vimtag">*<a name="operator-variable">operator-variable</a>*</b>
v:operator	The last operator given in Normal mode.  This is a single
		character except for commands starting with <code class="special">&lt;g&gt;</code> or <code class="special">&lt;z&gt;</code>,
		in which case it is two characters.  Best used alongside
		|<a href="eval.html#v:prevcount">v:prevcount</a>| and |<a href="eval.html#v:register">v:register</a>|.  Useful if you want to cancel
		Operator-pending mode and then use the operator, e.g.:
<code class="example">			:omap O <code class="special">&lt;Esc&gt;</code>:call MyMotion(v:operator)<code class="special">&lt;CR&gt;</code></code>
		The value remains set until another operator is entered, thus
		don't expect it to be empty.
		v:operator is not set for |<a href="change.html#:delete">:delete</a>|, |<a href="change.html#:yank">:yank</a>| or other Ex
		commands.
		Read-only.

					<b class="vimtag">*<a name="v:prevcount">v:prevcount</a>*</b> <b class="vimtag">*<a name="prevcount-variable">prevcount-variable</a>*</b>
v:prevcount	The count given for the last but one Normal mode command.
		This is the v:count value of the previous command.  Useful if
		you want to cancel Visual or Operator-pending mode and then
		use the count, e.g.:
<code class="example">			:vmap % <code class="special">&lt;Esc&gt;</code>:call MyFilter(v:prevcount)<code class="special">&lt;CR&gt;</code></code>
		Read-only.

					<b class="vimtag">*<a name="v:profiling">v:profiling</a>*</b> <b class="vimtag">*<a name="profiling-variable">profiling-variable</a>*</b>
v:profiling	Normally zero.	Set to one after using ":profile start".
		See |<a href="repeat.html#profiling">profiling</a>|.

					<b class="vimtag">*<a name="v:progname">v:progname</a>*</b> <b class="vimtag">*<a name="progname-variable">progname-variable</a>*</b>
v:progname	Contains the name (with path removed) with which Vim was
		invoked.  Allows you to do special initialisations for |<a href="starting.html#view">view</a>|,
		|<a href="starting.html#evim">evim</a>| etc., or any other name you might symlink to Vim.
		Read-only.

					<b class="vimtag">*<a name="v:progpath">v:progpath</a>*</b> <b class="vimtag">*<a name="progpath-variable">progpath-variable</a>*</b>
v:progpath	Contains the command with which Vim was invoked, including the
		path.  Useful if you want to message a Vim server using a
		|<a href="remote.html#--remote-expr">--remote-expr</a>|.
		To get the full path use:
<code class="example">			echo exepath(v:progpath)</code>
		<code class="note">NOTE:</code> This does not work when the command is a relative path
		and the current directory has changed.
		Read-only.

					<b class="vimtag">*<a name="v:register">v:register</a>*</b> <b class="vimtag">*<a name="register-variable">register-variable</a>*</b>
v:register	The name of the register in effect for the current normal mode
		command (regardless of whether that command actually used a
		register).  Or for the currently executing normal mode mapping
		(use this in custom commands that take a register).
		If none is supplied it is the default register '"', unless
		'clipboard' contains "unnamed" or "unnamedplus", then it is
		'*' or '+'.
		Also see |<a href="eval.html#getreg()">getreg()</a>| and |<a href="eval.html#setreg()">setreg()</a>|

					<b class="vimtag">*<a name="v:scrollstart">v:scrollstart</a>*</b> <b class="vimtag">*<a name="scrollstart-variable">scrollstart-variable</a>*</b>
v:scrollstart	String describing the script or function that caused the
		screen to scroll up.  It's only set when it is empty, thus the
		first reason is remembered.  It is set to "Unknown" for a
		typed command.
		This can be used to find out why your script causes the
		hit-enter prompt.

					<b class="vimtag">*<a name="v:servername">v:servername</a>*</b> <b class="vimtag">*<a name="servername-variable">servername-variable</a>*</b>
v:servername	The resulting registered |<a href="remote.html#x11-clientserver">x11-clientserver</a>| name if any.
		Read-only.


v:searchforward			<b class="vimtag">*<a name="v:searchforward">v:searchforward</a>*</b> <b class="vimtag">*<a name="searchforward-variable">searchforward-variable</a>*</b>
		Search direction:  1 after a forward search, 0 after a
		backward search.  It is reset to forward when directly setting
		the last search pattern, see |<a href="change.html#quote%2F">quote/</a>|.
		<code class="note">Note</code> that the value is restored when returning from a
		function. |<a href="eval.html#function-search-undo">function-search-undo</a>|.
		Read-write.

					<b class="vimtag">*<a name="v:shell_error">v:shell_error</a>*</b> <b class="vimtag">*<a name="shell_error-variable">shell_error-variable</a>*</b>
v:shell_error	Result of the last shell command.  When non-zero, the last
		shell command had an error.  When zero, there was no problem.
		This only works when the shell returns the error code to Vim.
		The value -1 is often used when the command could not be
		executed.  Read-only.
		Example:
<code class="example">	:!mv foo bar</code>
<code class="example">	:if v:shell_error</code>
<code class="example">	:  echo 'could not rename "foo" to "bar"!'</code>
<code class="example">	:endif</code>
		"shell_error" also works, for backwards compatibility.

					<b class="vimtag">*<a name="v:statusmsg">v:statusmsg</a>*</b> <b class="vimtag">*<a name="statusmsg-variable">statusmsg-variable</a>*</b>
v:statusmsg	Last given status message.  It's allowed to set this variable.

					<b class="vimtag">*<a name="v:swapname">v:swapname</a>*</b> <b class="vimtag">*<a name="swapname-variable">swapname-variable</a>*</b>
v:swapname	Only valid when executing |<a href="autocmd.html#SwapExists">SwapExists</a>| autocommands: Name of
		the swap file found.  Read-only.

					<b class="vimtag">*<a name="v:swapchoice">v:swapchoice</a>*</b> <b class="vimtag">*<a name="swapchoice-variable">swapchoice-variable</a>*</b>
v:swapchoice	|<a href="autocmd.html#SwapExists">SwapExists</a>| autocommands can set this to the selected choice
		for handling an existing swap file:
			'o'	Open read-only
			'e'	Edit anyway
			'r'	Recover
			'd'	Delete swapfile
			'q'	Quit
			'a'	Abort
		The value should be a single-character string.	An empty value
		results in the user being asked, as would happen when there is
		no SwapExists autocommand.  The default is empty.

					<b class="vimtag">*<a name="v:swapcommand">v:swapcommand</a>*</b> <b class="vimtag">*<a name="swapcommand-variable">swapcommand-variable</a>*</b>
v:swapcommand	Normal mode command to be executed after a file has been
		opened.  Can be used for a |<a href="autocmd.html#SwapExists">SwapExists</a>| autocommand to have
		another Vim open the file and jump to the right place.	For
		example, when jumping to a tag the value is ":tag tagname\r".
		For ":edit +cmd file" the value is ":cmd\r".

				<b class="vimtag">*<a name="v:termresponse">v:termresponse</a>*</b> <b class="vimtag">*<a name="termresponse-variable">termresponse-variable</a>*</b>
v:termresponse	The escape sequence returned by the terminal for the |<a href="term.html#t_RV">t_RV</a>|
		termcap entry.	It is set when Vim receives an escape sequence
		that starts with ESC [ or CSI and ends in a 'c', with only
		digits, ';' and '.' in between.
		When this option is set, the TermResponse autocommand event is
		fired, so that you can react to the response from the
		terminal.
		The response from a new xterm is: "<code class="special">&lt;Esc&gt;</code>[ Pp ; Pv ; Pc c".  Pp
		is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
		patch level (since this was introduced in patch 95, it's
		always 95 or bigger).  Pc is always zero.
		{only when compiled with |<a href="various.html#+termresponse">+termresponse</a>| feature}

					<b class="vimtag">*<a name="v:testing">v:testing</a>*</b> <b class="vimtag">*<a name="testing-variable">testing-variable</a>*</b>
v:testing	Must be set before using `garbagecollect_for_testing()`.

				<b class="vimtag">*<a name="v:this_session">v:this_session</a>*</b> <b class="vimtag">*<a name="this_session-variable">this_session-variable</a>*</b>
v:this_session	Full filename of the last loaded or saved session file.  See
		|<a href="starting.html#:mksession">:mksession</a>|.  It is allowed to set this variable.  When no
		session file has been saved, this variable is empty.
		"this_session" also works, for backwards compatibility.

					<b class="vimtag">*<a name="v:throwpoint">v:throwpoint</a>*</b> <b class="vimtag">*<a name="throwpoint-variable">throwpoint-variable</a>*</b>
v:throwpoint	The point where the exception most recently caught and not
		finished was thrown.  Not set when commands are typed.	See
		also |<a href="eval.html#v:exception">v:exception</a>| and |<a href="eval.html#throw-variables">throw-variables</a>|.
		Example:
<code class="example">	:try</code>
<code class="example">	:  throw "oops"</code>
<code class="example">	:catch /.*/</code>
<code class="example">	:  echo "Exception from" v:throwpoint</code>
<code class="example">	:endtry</code>
		Output: "Exception from test.vim, line 2"

						<b class="vimtag">*<a name="v:true">v:true</a>*</b> <b class="vimtag">*<a name="true-variable">true-variable</a>*</b>
v:true		A Number with value one. Used to put "true" in JSON.  See
		|<a href="eval.html#json_encode()">json_encode()</a>|.
		When used as a string this evaluates to "true".
<code class="example">			echo v:true</code>
<code class="section">			true </code>
						<b class="vimtag">*<a name="v:val">v:val</a>*</b> <b class="vimtag">*<a name="val-variable">val-variable</a>*</b>
v:val		Value of the current item of a |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>|.	Only
		valid while evaluating the expression used with |<a href="eval.html#map()">map()</a>| and
		|<a href="eval.html#filter()">filter()</a>|.  Read-only.

					<b class="vimtag">*<a name="v:version">v:version</a>*</b> <b class="vimtag">*<a name="version-variable">version-variable</a>*</b>
v:version	Version number of Vim: Major version number times 100 plus
		minor version number.  Version 5.0 is 500.  Version 5.1 (5.01)
		is 501.  Read-only.  "version" also works, for backwards
		compatibility.
		Use |<a href="eval.html#has()">has()</a>| to check if a certain patch was included, e.g.:
<code class="example">			if has("patch-7.4.123")</code>
		<code class="note">Note</code> that patch numbers are specific to the version, thus both
		version 5.0 and 5.1 may have a patch 123, but these are
		completely different.

				<b class="vimtag">*<a name="v:vim_did_enter">v:vim_did_enter</a>*</b> <b class="vimtag">*<a name="vim_did_enter-variable">vim_did_enter-variable</a>*</b>
v:vim_did_enter	Zero until most of startup is done.  It is set to one just
		before |<a href="autocmd.html#VimEnter">VimEnter</a>| autocommands are triggered.

					<b class="vimtag">*<a name="v:warningmsg">v:warningmsg</a>*</b> <b class="vimtag">*<a name="warningmsg-variable">warningmsg-variable</a>*</b>
v:warningmsg	Last given warning message.  It's allowed to set this variable.

					<b class="vimtag">*<a name="v:windowid">v:windowid</a>*</b> <b class="vimtag">*<a name="windowid-variable">windowid-variable</a>*</b>
v:windowid	When any X11 based GUI is running or when running in a
		terminal and Vim connects to the X server (|<a href="starting.html#-X">-X</a>|) this will be
		set to the window ID.
		When an MS-Windows GUI is running this will be set to the
		window handle.
		Otherwise the value is zero.
		<code class="note">Note:</code> for windows inside Vim use |<a href="eval.html#winnr()">winnr()</a>|.

</pre><hr><pre>4. Builtin Functions					<b class="vimtag">*<a name="functions">functions</a>*</b>

See |<a href="usr_41.html#function-list">function-list</a>| for a list grouped by what the function is used for.

(Use CTRL-] on the function name to jump to the full explanation.)

<code class="section">USAGE				RESULT	DESCRIPTION	</code>

abs(<code class="special">{expr}</code>)			Float or Number  absolute value of <code class="special">{expr}</code>
acos(<code class="special">{expr}</code>)			Float	arc cosine of <code class="special">{expr}</code>
add(<code class="special">{list}</code>, <code class="special">{item}</code>)		List	append <code class="special">{item}</code> to |<a href="eval.html#List">List</a>| <code class="special">{list}</code>
alloc_fail(<code class="special">{id}</code>, <code class="special">{countdown}</code>, <code class="special">{repeat}</code>)
				none	make memory allocation fail
and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)		Number  bitwise AND
append(<code class="special">{lnum}</code>, <code class="special">{string}</code>)	Number	append <code class="special">{string}</code> below line <code class="special">{lnum}</code>
append(<code class="special">{lnum}</code>, <code class="special">{list}</code>)		Number	append lines <code class="special">{list}</code> below line <code class="special">{lnum}</code>
argc()				Number	number of files in the argument list
argidx()			Number	current index in the argument list
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]]) Number	argument list id
argv(<code class="special">{nr}</code>)			String	<code class="special">{nr}</code> entry of the argument list
argv()				List	the argument list
assert_equal(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])     none  assert <code class="special">{exp}</code> is equal to <code class="special">{act}</code>
assert_exception(<code class="special">{error}</code> [, <code class="special">{msg}</code>])      none  assert <code class="special">{error}</code> is in v:exception
assert_fails(<code class="special">{cmd}</code> [, <code class="special">{error}</code>])          none  assert <code class="special">{cmd}</code> fails
assert_false(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])         none  assert <code class="special">{actual}</code> is false
assert_match(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>])    none  assert <code class="special">{pat}</code> matches <code class="special">{text}</code>
assert_<code class="note">note</code>qual(<code class="special">{exp}</code>, <code class="special">{act}</code> [, <code class="special">{msg}</code>])  none  assert <code class="special">{exp}</code> is not equal <code class="special">{act}</code>
assert_notmatch(<code class="special">{pat}</code>, <code class="special">{text}</code> [, <code class="special">{msg}</code>]) none  assert <code class="special">{pat}</code> not matches <code class="special">{text}</code>
assert_true(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])          none  assert <code class="special">{actual}</code> is true
asin(<code class="special">{expr}</code>)			Float	arc sine of <code class="special">{expr}</code>
atan(<code class="special">{expr}</code>)			Float	arc tangent of <code class="special">{expr}</code>
atan2(<code class="special">{expr}</code>, <code class="special">{expr}</code>)		Float   arc tangent of <code class="special">{expr1}</code> / <code class="special">{expr2}</code>
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
				String	put up a file requester
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)	String	put up a directory requester
bufexists(<code class="special">{expr}</code>)		Number	TRUE if buffer <code class="special">{expr}</code> exists
buflisted(<code class="special">{expr}</code>)		Number	TRUE if buffer <code class="special">{expr}</code> is listed
bufloaded(<code class="special">{expr}</code>)		Number	TRUE if buffer <code class="special">{expr}</code> is loaded
bufname(<code class="special">{expr}</code>)			String	Name of the buffer <code class="special">{expr}</code>
bufnr(<code class="special">{expr}</code> [, <code class="special">{create}</code>])	Number	Number of the buffer <code class="special">{expr}</code>
bufwinnr(<code class="special">{expr}</code>)		Number	window number of buffer <code class="special">{expr}</code>
byte2line(<code class="special">{byte}</code>)		Number	line number at byte count <code class="special">{byte}</code>
byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code>)		Number	byte index of <code class="special">{nr}</code>'th char in <code class="special">{expr}</code>
byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code>)	Number	byte index of <code class="special">{nr}</code>'th char in <code class="special">{expr}</code>
call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])
				any	call <code class="special">{func}</code> with arguments <code class="special">{arglist}</code>
ceil(<code class="special">{expr}</code>)			Float	round <code class="special">{expr}</code> up
ch_close(<code class="special">{handle}</code>)		none	close <code class="special">{handle}</code>
ch_evalexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
				any	evaluate <code class="special">{expr}</code> on JSON <code class="special">{handle}</code>
ch_evalraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])
				any	evaluate <code class="special">{string}</code> on raw <code class="special">{handle}</code>
ch_getbufnr(<code class="special">{handle}</code>, <code class="special">{what}</code>)	Number	get buffer number for <code class="special">{handle}</code>/<code class="special">{what}</code>
ch_getjob(<code class="special">{channel}</code>)		Job	get the Job of <code class="special">{channel}</code>
ch_info(<code class="special">{handle}</code>)		String	info about channel  <code class="special">{handle}</code>
ch_log(<code class="special">{msg}</code> [, <code class="special">{handle}</code>])	none	write <code class="special">{msg}</code> in the channel log file
ch_logfile(<code class="special">{fname}</code> [, <code class="special">{mode}</code>])	none	start logging channel activity
ch_open(<code class="special">{address}</code> [, <code class="special">{options}</code>])
				Channel open a channel to <code class="special">{address}</code>
ch_read(<code class="special">{handle}</code> [, <code class="special">{options}</code>]) String  read from  <code class="special">{handle}</code>
ch_readraw(<code class="special">{handle}</code> [, <code class="special">{options}</code>])
				String  read raw from  <code class="special">{handle}</code>
ch_sendexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])
				any	send <code class="special">{expr}</code> over JSON <code class="special">{handle}</code>
ch_sendraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])
				any	send <code class="special">{string}</code> over raw <code class="special">{handle}</code>
ch_setoptions(<code class="special">{handle}</code>, <code class="special">{options}</code>)
				none	set options for <code class="special">{handle}</code>
ch_status(<code class="special">{handle}</code>)		String	status of channel  <code class="special">{handle}</code>
changenr()			Number	current change number
char2nr(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])	Number	ASCII/UTF8 value of first char in <code class="special">{expr}</code>
cindent(<code class="special">{lnum}</code>)			Number	C indent for line <code class="special">{lnum}</code>
clearmatches()			none	clear all matches
col(<code class="special">{expr}</code>)			Number	column nr of cursor or mark
complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>) none	set Insert mode completion
complete_add(<code class="special">{expr}</code>)		Number	add completion match
complete_check()		Number	check for key typed during completion
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
				Number	number of choice picked by user
copy(<code class="special">{expr}</code>)			any	make a shallow copy of <code class="special">{expr}</code>
cos(<code class="special">{expr}</code>)			Float	cosine of <code class="special">{expr}</code>
cosh(<code class="special">{expr}</code>)			Float	hyperbolic cosine of <code class="special">{expr}</code>
count(<code class="special">{list}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])
				Number	 count how many <code class="special">{expr}</code> are in <code class="special">{list}</code>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
				Number	checks existence of cscope connection
cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])
				Number	move cursor to <code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>
cursor(<code class="special">{list}</code>)			Number	move cursor to position in <code class="special">{list}</code>
deepcopy(<code class="special">{expr}</code> [, <code class="special">{noref}</code>])	any	make a full copy of <code class="special">{expr}</code>
delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])	Number	delete the file or directory <code class="special">{fname}</code>
did_filetype()			Number	TRUE if FileType autocommand event used
diff_filler(<code class="special">{lnum}</code>)		Number	diff filler lines about <code class="special">{lnum}</code>
diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)	Number	diff highlighting at <code class="special">{lnum}</code>/<code class="special">{col}</code>
disable_char_avail_for_testing(<code class="special">{expr}</code>)
				none	test without typeahead
empty(<code class="special">{expr}</code>)			Number	TRUE if <code class="special">{expr}</code> is empty
escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)	String	escape <code class="special">{chars}</code> in <code class="special">{string}</code> with '\'
eval(<code class="special">{string}</code>)			any	evaluate <code class="special">{string}</code> into its value
eventhandler()			Number	TRUE if inside an event handler
executable(<code class="special">{expr}</code>)		Number	1 if executable <code class="special">{expr}</code> exists
exepath(<code class="special">{expr}</code>)			String  full path of the command <code class="special">{expr}</code>
exists(<code class="special">{expr}</code>)			Number	TRUE if <code class="special">{expr}</code> exists
extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])
				List/Dict insert items of <code class="special">{expr2}</code> into <code class="special">{expr1}</code>
exp(<code class="special">{expr}</code>)			Float	exponential of <code class="special">{expr}</code>
expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])
				any	expand special keywords in <code class="special">{expr}</code>
feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])	Number	add key sequence to typeahead buffer
filereadable(<code class="special">{file}</code>)		Number	TRUE if <code class="special">{file}</code> is a readable file
filewritable(<code class="special">{file}</code>)		Number	TRUE if <code class="special">{file}</code> is a writable file
filter(<code class="special">{expr}</code>, <code class="special">{string}</code>)	List/Dict  remove items from <code class="special">{expr}</code> where
					<code class="special">{string}</code> is 0
finddir(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])
				String	find directory <code class="special">{name}</code> in <code class="special">{path}</code>
findfile(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])
				String	find file <code class="special">{name}</code> in <code class="special">{path}</code>
float2nr(<code class="special">{expr}</code>)		Number	convert Float <code class="special">{expr}</code> to a Number
floor(<code class="special">{expr}</code>)			Float	round <code class="special">{expr}</code> down
fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)		Float	remainder of <code class="special">{expr1}</code> / <code class="special">{expr2}</code>
fnameescape(<code class="special">{fname}</code>)		String	escape special characters in <code class="special">{fname}</code>
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)	String	modify file name
foldclosed(<code class="special">{lnum}</code>)		Number	first line of fold at <code class="special">{lnum}</code> if closed
foldclosedend(<code class="special">{lnum}</code>)		Number	last line of fold at <code class="special">{lnum}</code> if closed
foldlevel(<code class="special">{lnum}</code>)		Number	fold level at <code class="special">{lnum}</code>
foldtext()			String	line displayed for closed fold
foldtextresult(<code class="special">{lnum}</code>)		String	text for closed fold at <code class="special">{lnum}</code>
foreground()			Number	bring the Vim window to the foreground
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
				Funcref reference to function <code class="special">{name}</code>
garbagecollect([<code class="special">{atexit}</code>])	none	free memory, breaking cyclic references
garbagecollect_for_testing()	none	free memory right now
get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{def}</code>])	any	get item <code class="special">{idx}</code> from <code class="special">{list}</code> or <code class="special">{def}</code>
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{def}</code>])	any	get item <code class="special">{key}</code> from <code class="special">{dict}</code> or <code class="special">{def}</code>
getbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
				List	lines <code class="special">{lnum}</code> to <code class="special">{end}</code> of buffer <code class="special">{expr}</code>
getbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
				any	variable <code class="special">{varname}</code> in buffer <code class="special">{expr}</code>
getchar([expr])			Number	get one character from the user
getcharmod()			Number	modifiers for the last typed character
getcharsearch()			Dict	last character search
getcmdline()			String	return the current command-line
getcmdpos()			Number	return cursor position in command-line
getcmdtype()			String	return current command-line type
getcmdwintype()			String	return current command-line window type
getcurpos()			List	position of the cursor
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])	String	get the current working directory
getfontname([<code class="special">{name}</code>])		String	name of font being used
getfperm(<code class="special">{fname}</code>)		String	file permissions of file <code class="special">{fname}</code>
getfsize(<code class="special">{fname}</code>)		Number	size in bytes of file <code class="special">{fname}</code>
getftime(<code class="special">{fname}</code>)		Number	last modification time of file
getftype(<code class="special">{fname}</code>)		String	description of type of file <code class="special">{fname}</code>
getline(<code class="special">{lnum}</code>)			String	line <code class="special">{lnum}</code> of current buffer
getline(<code class="special">{lnum}</code>, <code class="special">{end}</code>)		List	lines <code class="special">{lnum}</code> to <code class="special">{end}</code> of current buffer
getloclist(<code class="special">{nr}</code>)		List	list of location list items
getmatches()			List	list of current matches
getpid()			Number	process ID of Vim
getpos(<code class="special">{expr}</code>)			List	position of cursor, mark, etc.
getqflist()			List	list of quickfix items
getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])
				String or List   contents of register
getregtype([<code class="special">{regname}</code>])		String	type of register
gettabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
				any	variable <code class="special">{varname}</code> in tab <code class="special">{nr}</code> or <code class="special">{def}</code>
gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{name}</code> [, <code class="special">{def}</code>])
				any	<code class="special">{name}</code> in <code class="special">{winnr}</code> in tab page <code class="special">{tabnr}</code>
getwinposx()			Number	X coord in pixels of GUI Vim window
getwinposy()			Number	Y coord in pixels of GUI Vim window
getwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])
				any	variable <code class="special">{varname}</code> in window <code class="special">{nr}</code>
glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
				any	expand file wildcards in <code class="special">{expr}</code>
glob2regpat(<code class="special">{expr}</code>)		String  convert a glob pat into a search pat
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
				String	do glob(<code class="special">{expr}</code>) for all dirs in <code class="special">{path}</code>
has(<code class="special">{feature}</code>)			Number	TRUE if feature <code class="special">{feature}</code> supported
has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)		Number	TRUE if <code class="special">{dict}</code> has entry <code class="special">{key}</code>
haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
				Number	TRUE if the window executed |<a href="editing.html#:lcd">:lcd</a>|
hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
				Number	TRUE if mapping to <code class="special">{what}</code> exists
histadd(<code class="special">{history}</code>, <code class="special">{item}</code>)	String	add an item to a history
histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])	String	remove an item from a history
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])	String	get the item <code class="special">{index}</code> from a history
histnr(<code class="special">{history}</code>)		Number	highest index of a history
hlexists(<code class="special">{name}</code>)		Number	TRUE if highlight group <code class="special">{name}</code> exists
hlID(<code class="special">{name}</code>)			Number	syntax ID of highlight group <code class="special">{name}</code>
hostname()			String	name of the machine Vim is running on
iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)	String	convert encoding of <code class="special">{expr}</code>
indent(<code class="special">{lnum}</code>)			Number	indent of line <code class="special">{lnum}</code>
index(<code class="special">{list}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])
				Number	index in <code class="special">{list}</code> where <code class="special">{expr}</code> appears
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])
				String	get input from the user
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]]])
				String  like input() but in a GUI dialog
inputlist(<code class="special">{textlist}</code>)		Number	let the user pick from a choice list
inputrestore()			Number	restore typeahead
inputsave()			Number	save and clear typeahead
inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>]) String  like input() but hiding the text
insert(<code class="special">{list}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>]) List	insert <code class="special">{item}</code> in <code class="special">{list}</code> [before <code class="special">{idx}</code>]
invert(<code class="special">{expr}</code>)			Number  bitwise invert
isdirectory(<code class="special">{directory}</code>)	Number	TRUE if <code class="special">{directory}</code> is a directory
islocked(<code class="special">{expr}</code>)		Number	TRUE if <code class="special">{expr}</code> is locked
isnan(<code class="special">{expr}</code>)			Number  TRUE if <code class="special">{expr}</code> is NaN
items(<code class="special">{dict}</code>)			List	key-value pairs in <code class="special">{dict}</code>
job_getchannel(<code class="special">{job}</code>)		Channel	get the channel handle for <code class="special">{job}</code>
job_info(<code class="special">{job}</code>)			Dict	get information about <code class="special">{job}</code>
job_setoptions(<code class="special">{job}</code>, <code class="special">{options}</code>) none	set options for <code class="special">{job}</code>
job_start(<code class="special">{command}</code> [, <code class="special">{options}</code>])
				Job	 start a job
job_status(<code class="special">{job}</code>)		String	get the status of <code class="special">{job}</code>
job_stop(<code class="special">{job}</code> [, <code class="special">{how}</code>])	Number	stop <code class="special">{job}</code>
join(<code class="special">{list}</code> [, <code class="special">{sep}</code>])		String	join <code class="special">{list}</code> items into one String
js_decode(<code class="special">{string}</code>)		any	decode JS style JSON
js_encode(<code class="special">{expr}</code>)		String	encode JS style JSON
json_decode(<code class="special">{string}</code>)		any	decode JSON
json_encode(<code class="special">{expr}</code>)		String	encode JSON
keys(<code class="special">{dict}</code>)			List	keys in <code class="special">{dict}</code>
len(<code class="special">{expr}</code>)			Number	the length of <code class="special">{expr}</code>
libcall(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>)	String	call <code class="special">{func}</code> in library <code class="special">{lib}</code> with <code class="special">{arg}</code>
libcallnr(<code class="special">{lib}</code>, <code class="special">{func}</code>, <code class="special">{arg}</code>)  Number  idem, but return a Number
line(<code class="special">{expr}</code>)			Number	line nr of cursor, last line or mark
line2byte(<code class="special">{lnum}</code>)		Number	byte count of line <code class="special">{lnum}</code>
lispindent(<code class="special">{lnum}</code>)		Number	Lisp indent for line <code class="special">{lnum}</code>
localtime()			Number	current time
log(<code class="special">{expr}</code>)			Float	natural logarithm (base e) of <code class="special">{expr}</code>
log10(<code class="special">{expr}</code>)			Float	logarithm of Float <code class="special">{expr}</code> to base 10
luaeval(<code class="special">{expr}</code>[, <code class="special">{expr}</code>])	any	evaluate |<a href="if_lua.html#Lua">Lua</a>| expression
map(<code class="special">{expr}</code>, <code class="special">{string}</code>)		List/Dict  change each item in <code class="special">{expr}</code> to <code class="special">{expr}</code>
maparg(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])
				String or Dict
					rhs of mapping <code class="special">{name}</code> in mode <code class="special">{mode}</code>
mapcheck(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])
				String	check for mappings matching <code class="special">{name}</code>
match(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
				Number	position where <code class="special">{pat}</code> matches in <code class="special">{expr}</code>
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code> [, <code class="special">{dict}</code>]]])
				Number	highlight <code class="special">{pattern}</code> with <code class="special">{group}</code>
matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code>[, <code class="special">{dict}</code>]]])
				Number	highlight positions with <code class="special">{group}</code>
matcharg(<code class="special">{nr}</code>)			List	arguments of |<a href="pattern.html#:match">:match</a>|
matchdelete(<code class="special">{id}</code>)		Number	delete match identified by <code class="special">{id}</code>
matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
				Number	position where <code class="special">{pat}</code> ends in <code class="special">{expr}</code>
matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
				List	match and submatches of <code class="special">{pat}</code> in <code class="special">{expr}</code>
matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
				String	<code class="special">{count}</code>'th match of <code class="special">{pat}</code> in <code class="special">{expr}</code>
matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])
				List	<code class="special">{count}</code>'th match of <code class="special">{pat}</code> in <code class="special">{expr}</code>
max(<code class="special">{list}</code>)			Number	maximum value of items in <code class="special">{list}</code>
min(<code class="special">{list}</code>)			Number	minimum value of items in <code class="special">{list}</code>
mkdir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{prot}</code>]])
				Number	create directory <code class="special">{name}</code>
mode([expr])			String	current editing mode
mzeval(<code class="special">{expr}</code>)			any	evaluate |<a href="if_mzsch.html#MzScheme">MzScheme</a>| expression
nextnonblank(<code class="special">{lnum}</code>)		Number	line nr of non-blank line &gt;= <code class="special">{lnum}</code>
nr2char(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])	String	single char with ASCII/UTF8 value <code class="special">{expr}</code>
or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)		Number  bitwise OR
pathshorten(<code class="special">{expr}</code>)		String	shorten directory names in a path
perleval(<code class="special">{expr}</code>)		any	evaluate |<a href="if_perl.html#Perl">Perl</a>| expression
pow(<code class="special">{x}</code>, <code class="special">{y}</code>)			Float	<code class="special">{x}</code> to the power of <code class="special">{y}</code>
prevnonblank(<code class="special">{lnum}</code>)		Number	line nr of non-blank line &lt;= <code class="special">{lnum}</code>
printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code>...)	String	format text
pumvisible()			Number	whether popup menu is visible
pyeval(<code class="special">{expr}</code>)			any	evaluate |<a href="if_pyth.html#Python">Python</a>| expression
py3eval(<code class="special">{expr}</code>)			any	evaluate |<a href="if_pyth.html#python3">python3</a>| expression
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])
				List	items from <code class="special">{expr}</code> to <code class="special">{max}</code>
readfile(<code class="special">{fname}</code> [, <code class="special">{binary}</code> [, <code class="special">{max}</code>]])
				List	get list of lines from file <code class="special">{fname}</code>
reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])	List	get time value
reltimefloat(<code class="special">{time}</code>)		Float	turn the time value into a Float
reltimestr(<code class="special">{time}</code>)		String	turn time value into a String
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
				String	send expression
remote_foreground(<code class="special">{server}</code>)	Number	bring Vim server to the foreground
remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])
				Number	check for reply string
remote_read(<code class="special">{serverid}</code>)		String	read reply string
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
				String	send key sequence
remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>])  any	remove items <code class="special">{idx}</code>-<code class="special">{end}</code> from <code class="special">{list}</code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)		any	remove entry <code class="special">{key}</code> from <code class="special">{dict}</code>
rename(<code class="special">{from}</code>, <code class="special">{to}</code>)		Number	rename (move) file from <code class="special">{from}</code> to <code class="special">{to}</code>
repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)		String	repeat <code class="special">{expr}</code> <code class="special">{count}</code> times
resolve(<code class="special">{filename}</code>)		String	get filename a shortcut points to
reverse(<code class="special">{list}</code>)			List	reverse <code class="special">{list}</code> in-place
round(<code class="special">{expr}</code>)			Float	round off <code class="special">{expr}</code>
screenattr(<code class="special">{row}</code>, <code class="special">{col}</code>)	Number	attribute at screen position
screenchar(<code class="special">{row}</code>, <code class="special">{col}</code>)	Number	character at screen position
screencol()			Number	current cursor column
screenrow()			Number	current cursor row
search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])
				Number	search for <code class="special">{pattern}</code>
searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])
				Number	search for variable declaration
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
				Number	search for other end of start/end pair
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code> [...]]])
				List	search for other end of start/end pair
searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])
				List	search for <code class="special">{pattern}</code>
server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)
				Number	send reply string
serverlist()			String	get a list of available servers
setbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
				none	set <code class="special">{varname}</code> in buffer <code class="special">{expr}</code> to <code class="special">{val}</code>
setcharsearch(<code class="special">{dict}</code>)		Dict	set character search from <code class="special">{dict}</code>
setcmdpos(<code class="special">{pos}</code>)		Number	set cursor position in command-line
setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)	Number	set <code class="special">{fname}</code> file permissions to <code class="special">{mode}</code>
setline(<code class="special">{lnum}</code>, <code class="special">{line}</code>)		Number	set line <code class="special">{lnum}</code> to <code class="special">{line}</code>
setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code>[, <code class="special">{action}</code>])
				Number	modify location list using <code class="special">{list}</code>
setmatches(<code class="special">{list}</code>)		Number	restore a list of matches
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)		Number	set the <code class="special">{expr}</code> position to <code class="special">{list}</code>
setqflist(<code class="special">{list}</code>[, <code class="special">{action}</code>])	Number	modify quickfix list using <code class="special">{list}</code>
setreg(<code class="special">{n}</code>, <code class="special">{v}</code>[, <code class="special">{opt}</code>])	Number	set register to value and type
settabvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) none	set <code class="special">{varname}</code> in tab page <code class="special">{nr}</code> to <code class="special">{val}</code>
settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)
				none	set <code class="special">{varname}</code> in window <code class="special">{winnr}</code> in tab
					page <code class="special">{tabnr}</code> to <code class="special">{val}</code>
setwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>) none	set <code class="special">{varname}</code> in window <code class="special">{nr}</code> to <code class="special">{val}</code>
sha256(<code class="special">{string}</code>)		String	SHA256 checksum of <code class="special">{string}</code>
shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])
				String	escape <code class="special">{string}</code> for use as shell
					command argument
shiftwidth()			Number	effective value of 'shiftwidth'
simplify(<code class="special">{filename}</code>)		String	simplify filename as much as possible
sin(<code class="special">{expr}</code>)			Float	sine of <code class="special">{expr}</code>
sinh(<code class="special">{expr}</code>)			Float	hyperbolic sine of <code class="special">{expr}</code>
sort(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
				List	sort <code class="special">{list}</code>, using <code class="special">{func}</code> to compare
soundfold(<code class="special">{word}</code>)		String	sound-fold <code class="special">{word}</code>
spellbadword()			String	badly spelled word at cursor
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
				List	spelling suggestions
split(<code class="special">{expr}</code> [, <code class="special">{pat}</code> [, <code class="special">{keepempty}</code>]])
				List	make |<a href="eval.html#List">List</a>| from <code class="special">{pat}</code> separated <code class="special">{expr}</code>
sqrt(<code class="special">{expr}</code>)			Float	square root of <code class="special">{expr}</code>
str2float(<code class="special">{expr}</code>)		Float	convert String to Float
str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code>])	Number	convert String to Number
strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])	Number	character length of the String <code class="special">{expr}</code>
strcharpart(<code class="special">{str}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])
				String	<code class="special">{len}</code> characters of <code class="special">{str}</code> at <code class="special">{start}</code>
strdisplaywidth(<code class="special">{expr}</code> [, <code class="special">{col}</code>]) Number display length of the String <code class="special">{expr}</code>
strftime(<code class="special">{format}</code>[, <code class="special">{time}</code>])	String	time in specified format
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)	Number	get char <code class="special">{index}</code> from <code class="special">{str}</code>
stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code>[, <code class="special">{start}</code>])
				Number	index of <code class="special">{needle}</code> in <code class="special">{haystack}</code>
string(<code class="special">{expr}</code>)			String	String representation of <code class="special">{expr}</code> value
strlen(<code class="special">{expr}</code>)			Number	length of the String <code class="special">{expr}</code>
strpart(<code class="special">{str}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])
				String	<code class="special">{len}</code> characters of <code class="special">{str}</code> at <code class="special">{start}</code>
strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])
				Number	last index of <code class="special">{needle}</code> in <code class="special">{haystack}</code>
strtrans(<code class="special">{expr}</code>)		String	translate string to make it printable
strwidth(<code class="special">{expr}</code>)		Number	display cell length of the String <code class="special">{expr}</code>
submatch(<code class="special">{nr}</code>[, <code class="special">{list}</code>])	String or List
					specific match in ":s" or substitute()
substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)
				String	all <code class="special">{pat}</code> in <code class="special">{expr}</code> replaced with <code class="special">{sub}</code>
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)	Number	syntax ID at <code class="special">{lnum}</code> and <code class="special">{col}</code>
synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])
				String	attribute <code class="special">{what}</code> of syntax ID <code class="special">{synID}</code>
synIDtrans(<code class="special">{synID}</code>)		Number	translated syntax ID of <code class="special">{synID}</code>
synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)	List    info about concealing
synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)		List	stack of syntax IDs at <code class="special">{lnum}</code> and <code class="special">{col}</code>
system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])	String	output of shell command/filter <code class="special">{expr}</code>
systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])	List	output of shell command/filter <code class="special">{expr}</code>
tabpagebuflist([<code class="special">{arg}</code>])	List	list of buffer numbers in tab page
tabpagenr([<code class="special">{arg}</code>])		Number	number of current or last tab page
tabpagewinnr(<code class="special">{tabarg}</code>[, <code class="special">{arg}</code>]) Number	number of current window in tab page
taglist(<code class="special">{expr}</code>)			List	list of tags matching <code class="special">{expr}</code>
tagfiles()			List	tags files used
tan(<code class="special">{expr}</code>)			Float	tangent of <code class="special">{expr}</code>
tanh(<code class="special">{expr}</code>)			Float	hyperbolic tangent of <code class="special">{expr}</code>
tempname()			String	name for a temporary file
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
				Number	create a timer
timer_stop(<code class="special">{timer}</code>)		none	stop a timer
tolower(<code class="special">{expr}</code>)			String	the String <code class="special">{expr}</code> switched to lowercase
toupper(<code class="special">{expr}</code>)			String	the String <code class="special">{expr}</code> switched to uppercase
tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)	String	translate chars of <code class="special">{src}</code> in <code class="special">{fromstr}</code>
					to chars in <code class="special">{tostr}</code>
trunc(<code class="special">{expr}</code>)			Float	truncate Float <code class="special">{expr}</code>
type(<code class="special">{name}</code>)			Number	type of variable <code class="special">{name}</code>
undofile(<code class="special">{name}</code>)		String	undo file name for <code class="special">{name}</code>
undotree()			List	undo file tree
uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])
				List	remove adjacent duplicates from a list
values(<code class="special">{dict}</code>)			List	values in <code class="special">{dict}</code>
virtcol(<code class="special">{expr}</code>)			Number	screen column of cursor or mark
visualmode([expr])		String	last visual mode used
wildmenumode()			Number	whether 'wildmenu' mode is active
win_findbuf(<code class="special">{bufnr}</code>)		List	find windows containing <code class="special">{bufnr}</code>
win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])	Number	get window ID for <code class="special">{win}</code> in <code class="special">{tab}</code>
win_gotoid(<code class="special">{expr}</code>)		Number	go to window with ID <code class="special">{expr}</code>
win_id2tabwin(<code class="special">{expr}</code>)		List	get tab and window nr from window ID
win_id2win(<code class="special">{expr}</code>)		Number	get window nr from window ID
winbufnr(<code class="special">{nr}</code>)			Number	buffer number of window <code class="special">{nr}</code>
wincol()			Number	window column of the cursor
winheight(<code class="special">{nr}</code>)			Number	height of window <code class="special">{nr}</code>
winline()			Number	window line of the cursor
winnr([<code class="special">{expr}</code>])			Number	number of current window
winrestcmd()			String	returns command to restore window sizes
winrestview(<code class="special">{dict}</code>)		none	restore view of current window
winsaveview()			Dict	save view of current window
winwidth(<code class="special">{nr}</code>)			Number	width of window <code class="special">{nr}</code>
wordcount()			Dict	get byte/char/word statistics
writefile(<code class="special">{list}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
				Number	write list of lines to file <code class="special">{fname}</code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)		Number  bitwise XOR


abs(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="abs()">abs()</a>*</b>
		Return the absolute value of <code class="special">{expr}</code>.  When <code class="special">{expr}</code> evaluates to
		a |<a href="eval.html#Float">Float</a>| abs() returns a |<a href="eval.html#Float">Float</a>|.  When <code class="special">{expr}</code> can be
		converted to a |<a href="eval.html#Number">Number</a>| abs() returns a |<a href="eval.html#Number">Number</a>|.  Otherwise
		abs() gives an error message and returns -1.
		Examples:
<code class="example">			echo abs(1.456)</code>
&lt;			1.456
<code class="example">			echo abs(-5.456)</code>
&lt;			5.456
<code class="example">			echo abs(-4)</code>
			4
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


acos(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="acos()">acos()</a>*</b>
		Return the arc cosine of <code class="special">{expr}</code> measured in radians, as a
		|<a href="eval.html#Float">Float</a>| in the range of [0, pi].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>| in the range
		[-1, 1].
		Examples:
<code class="example">			:echo acos(0)</code>
&lt;			1.570796
<code class="example">			:echo acos(-0.5)</code>
			2.094395
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


add(<code class="special">{list}</code>, <code class="special">{expr}</code>)					<b class="vimtag">*<a name="add()">add()</a>*</b>
		Append the item <code class="special">{expr}</code> to |<a href="eval.html#List">List</a>| <code class="special">{list}</code>.  Returns the
		resulting |<a href="eval.html#List">List</a>|.  Examples:
<code class="example">			:let alist = add([1, 2, 3], item)</code>
<code class="example">			:call add(mylist, "woodstock")</code>
		<code class="note">Note</code> that when <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| it is appended as a single
		item.  Use |<a href="eval.html#extend()">extend()</a>| to concatenate |<a href="eval.html#Lists">Lists</a>|.
		Use |<a href="eval.html#insert()">insert()</a>| to add an item at another position.


alloc_fail(<code class="special">{id}</code>, <code class="special">{countdown}</code>, <code class="special">{repeat}</code>)			<b class="vimtag">*<a name="alloc_fail()">alloc_fail()</a>*</b>
		This is for testing: If the memory allocation with <code class="special">{id}</code> is
		called, then decrement <code class="special">{countdown}</code>, and when it reaches zero
		let memory allocation fail <code class="special">{repeat}</code> times.  When <code class="special">{repeat}</code> is
		smaller than one it fails one time.


and(<code class="special">{expr}</code>, <code class="special">{expr}</code>)					<b class="vimtag">*<a name="and()">and()</a>*</b>
		Bitwise AND on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example:
<code class="example">			:let flag = and(bits, 0x80)</code>
<code class="example"></code>
<code class="example"></code>
append(<code class="special">{lnum}</code>, <code class="special">{expr}</code>)					<b class="vimtag">*<a name="append()">append()</a>*</b>
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>|: Append each item of the |<a href="eval.html#List">List</a>| as a
		text line below line <code class="special">{lnum}</code> in the current buffer.
		Otherwise append <code class="special">{expr}</code> as one text line below line <code class="special">{lnum}</code> in
		the current buffer.
		<code class="special">{lnum}</code> can be zero to insert a line before the first one.
		Returns 1 for failure (<code class="special">{lnum}</code> out of range or out of memory),
		0 for success.	Example:
<code class="example">			:let failed = append(line('$'), "# THE END")</code>
<code class="example">			:let failed = append(0, ["Chapter 1", "the beginning"])</code>

							<b class="vimtag">*<a name="argc()">argc()</a>*</b>
argc()		The result is the number of files in the argument list of the
		current window.  See |<a href="editing.html#arglist">arglist</a>|.

							<b class="vimtag">*<a name="argidx()">argidx()</a>*</b>
argidx()	The result is the current index in the argument list.  0 is
		the first file.  argc() - 1 is the last one.  See |<a href="editing.html#arglist">arglist</a>|.

							<b class="vimtag">*<a name="arglistid()">arglistid()</a>*</b>
arglistid([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
		Return the argument list ID.  This is a number which
		identifies the argument list being used.  Zero is used for the
		global argument list.  See |<a href="editing.html#arglist">arglist</a>|.
		Return -1 if the arguments are invalid.

		Without arguments use the current window.
		With <code class="special">{winnr}</code> only use this window in the current tab page.
		With <code class="special">{winnr}</code> and <code class="special">{tabnr}</code> use the window in the specified tab
		page.

							<b class="vimtag">*<a name="argv()">argv()</a>*</b>
argv([<code class="special">{nr}</code>])	The result is the <code class="special">{nr}</code>th file in the argument list of the
		current window.  See |<a href="editing.html#arglist">arglist</a>|.  "argv(0)" is the first one.
		Example:
<code class="example">	:let i = 0</code>
<code class="example">	:while i &lt; argc()</code>
<code class="example">	:  let f = escape(fnameescape(argv(i)), '.')</code>
<code class="example">	:  exe 'amenu Arg.' . f . ' :e ' . f . '<code class="special">&lt;CR&gt;</code>'</code>
<code class="example">	:  let i = i + 1</code>
<code class="example">	:endwhile</code>
		Without the <code class="special">{nr}</code> argument a |<a href="eval.html#List">List</a>| with the whole |<a href="editing.html#arglist">arglist</a>| is
		returned.

							<b class="vimtag">*<a name="assert_equal()">assert_equal()</a>*</b>
assert_equal(<code class="special">{expected}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
		When <code class="special">{expected}</code> and <code class="special">{actual}</code> are not equal an error message is
		added to |<a href="eval.html#v:errors">v:errors</a>|.
		There is no automatic conversion, the String "4" is different
		from the Number 4.  And the number 4 is different from the
		Float 4.0.  The value of 'ignorecase' is not used here, case
		always matters.
		When <code class="special">{msg}</code> is omitted an error in the form "Expected
		<code class="special">{expected}</code> but got <code class="special">{actual}</code>" is produced.
		Example:
<code class="example">	assert_equal('foo', 'bar')</code>
		Will result in a string to be added to |<a href="eval.html#v:errors">v:errors</a>|:
<code class="section">	test.vim line 12: Expected 'foo' but got 'bar' </code>

assert_exception(<code class="special">{error}</code> [, <code class="special">{msg}</code>])			<b class="vimtag">*<a name="assert_exception()">assert_exception()</a>*</b>
		When v:exception does not contain the string <code class="special">{error}</code> an error
		message is added to |<a href="eval.html#v:errors">v:errors</a>|.
		This can be used to assert that a command throws an exception.
		Using the error number, followed by a colon, avoids problems
		with translations:
<code class="example">			try</code>
<code class="example">			  commandthatfails</code>
<code class="example">			  call assert_false(1, 'command should have failed')</code>
<code class="example">			catch</code>
<code class="example">			  call assert_exception('E492:')</code>
<code class="example">			endtry</code>
<code class="example"></code>
assert_fails(<code class="special">{cmd}</code> [, <code class="special">{error}</code>])					<b class="vimtag">*<a name="assert_fails()">assert_fails()</a>*</b>
		Run <code class="special">{cmd}</code> and add an error message to |<a href="eval.html#v:errors">v:errors</a>| if it does
		NOT produce an error.
		When <code class="special">{error}</code> is given it must match |<a href="eval.html#v:errmsg">v:errmsg</a>|.

assert_false(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])				<b class="vimtag">*<a name="assert_false()">assert_false()</a>*</b>
		When <code class="special">{actual}</code> is not false an error message is added to
		|<a href="eval.html#v:errors">v:errors</a>|, like with |<a href="eval.html#assert_equal()">assert_equal()</a>|.
		A value is false when it is zero. When <code class="special">{actual}</code> is not a
		number the assert fails.
		When <code class="special">{msg}</code> is omitted an error in the form "Expected False but
		got <code class="special">{actual}</code>" is produced.

								<b class="vimtag">*<a name="assert_match()">assert_match()</a>*</b>
assert_match(<code class="special">{pattern}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
		When <code class="special">{pattern}</code> does not match <code class="special">{actual}</code> an error message is
		added to |<a href="eval.html#v:errors">v:errors</a>|.

		<code class="special">{pattern}</code> is used as with |<code class="badlink">=~</code>|: The matching is always done
		like 'magic' was set and 'cpoptions' is empty, no matter what
		the actual value of 'magic' or 'cpoptions' is.

		<code class="special">{actual}</code> is used as a string, automatic conversion applies.
		Use "^" and "$" to match with the start and end of the text.
		Use both to match the whole text.

		When <code class="special">{msg}</code> is omitted an error in the form "Pattern <code class="special">{pattern}</code>
		does not match <code class="special">{actual}</code>" is produced.
		Example:
<code class="example">	assert_match('^f.*o$', 'foobar')</code>
		Will result in a string to be added to |<a href="eval.html#v:errors">v:errors</a>|:
<code class="section">	test.vim line 12: Pattern '^f.*o$' does not match 'foobar' </code>

							<b class="vimtag">*<a name="assert_notequal()">assert_notequal()</a>*</b>
assert_<code class="note">note</code>qual(<code class="special">{expected}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
		The opposite of `assert_equal()`: add an error message to
		|<a href="eval.html#v:errors">v:errors</a>| when <code class="special">{expected}</code> and <code class="special">{actual}</code> are equal.

							<b class="vimtag">*<a name="assert_notmatch()">assert_notmatch()</a>*</b>
assert_notmatch(<code class="special">{pattern}</code>, <code class="special">{actual}</code> [, <code class="special">{msg}</code>])
		The opposite of `assert_match()`: add an error message to
		|<a href="eval.html#v:errors">v:errors</a>| when <code class="special">{pattern}</code> matches <code class="special">{actual}</code>.

assert_true(<code class="special">{actual}</code> [, <code class="special">{msg}</code>])					<b class="vimtag">*<a name="assert_true()">assert_true()</a>*</b>
		When <code class="special">{actual}</code> is not true an error message is added to
		|<a href="eval.html#v:errors">v:errors</a>|, like with |<a href="eval.html#assert_equal()">assert_equal()</a>|.
		A value is true when it is a non-zero number.  When <code class="special">{actual}</code>
		is not a number the assert fails.
		When <code class="special">{msg}</code> is omitted an error in the form "Expected True but
		got <code class="special">{actual}</code>" is produced.

asin(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="asin()">asin()</a>*</b>
		Return the arc sine of <code class="special">{expr}</code> measured in radians, as a |<a href="eval.html#Float">Float</a>|
		in the range of [-pi/2, pi/2].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>| in the range
		[-1, 1].
		Examples:
<code class="example">			:echo asin(0.8)</code>
&lt;			0.927295
<code class="example">			:echo asin(-0.5)</code>
			-0.523599
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


atan(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="atan()">atan()</a>*</b>
		Return the principal value of the arc tangent of <code class="special">{expr}</code>, in
		the range [-pi/2, +pi/2] radians, as a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo atan(100)</code>
&lt;			1.560797
<code class="example">			:echo atan(-4.01)</code>
			-1.326405
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


atan2(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)					<b class="vimtag">*<a name="atan2()">atan2()</a>*</b>
		Return the arc tangent of <code class="special">{expr1}</code> / <code class="special">{expr2}</code>, measured in
		radians, as a |<a href="eval.html#Float">Float</a>| in the range [-pi, pi].
		<code class="special">{expr1}</code> and <code class="special">{expr2}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo atan2(-1, 1)</code>
&lt;			-0.785398
<code class="example">			:echo atan2(1, -1)</code>
			2.356194
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


							<b class="vimtag">*<a name="browse()">browse()</a>*</b>
browse(<code class="special">{save}</code>, <code class="special">{title}</code>, <code class="special">{initdir}</code>, <code class="special">{default}</code>)
		Put up a file requester.  This only works when "has("browse")"
		returns non-zero (only in some GUI versions).
		The input fields are:
		    <code class="special">{save}</code>	when non-zero, select file to write
		    <code class="special">{title}</code>	title for the requester
		    <code class="special">{initdir}</code>	directory to start browsing in
		    <code class="special">{default}</code>	default file name
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.

							<b class="vimtag">*<a name="browsedir()">browsedir()</a>*</b>
browsedir(<code class="special">{title}</code>, <code class="special">{initdir}</code>)
		Put up a directory requester.  This only works when
		"has("browse")" returns non-zero (only in some GUI versions).
		On systems where a directory browser is not supported a file
		browser is used.  In that case: select a file in the directory
		to be used.
		The input fields are:
		    <code class="special">{title}</code>	title for the requester
		    <code class="special">{initdir}</code>	directory to start browsing in
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.

bufexists(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="bufexists()">bufexists()</a>*</b>
		The result is a Number, which is non-zero if a buffer called
		<code class="special">{expr}</code> exists.
		If the <code class="special">{expr}</code> argument is a number, buffer numbers are used.
		If the <code class="special">{expr}</code> argument is a string it must match a buffer name
		exactly.  The name can be:
		- Relative to the current directory.
		- A full path.
		- The name of a buffer with 'buftype' set to "nofile".
		- A URL name.
		Unlisted buffers will be found.
		<code class="note">Note</code> that help files are listed by their short name in the
		output of |<a href="windows.html#:buffers">:buffers</a>|, but bufexists() requires using their
		long name to be able to find them.
		bufexists() may report a buffer exists, but to use the name
		with a |<a href="windows.html#:buffer">:buffer</a>| command you may need to use |<a href="eval.html#expand()">expand()</a>|.  Esp
		for MS-Windows 8.3 names in the form "c:\DOCUME~1"
		Use "bufexists(0)" to test for the existence of an alternate
		file name.
							<b class="vimtag">*<a name="buffer_exists()">buffer_exists()</a>*</b>
		Obsolete name: buffer_exists().

buflisted(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="buflisted()">buflisted()</a>*</b>
		The result is a Number, which is non-zero if a buffer called
		<code class="special">{expr}</code> exists and is listed (has the 'buflisted' option set).
		The <code class="special">{expr}</code> argument is used like with |<a href="eval.html#bufexists()">bufexists()</a>|.

bufloaded(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="bufloaded()">bufloaded()</a>*</b>
		The result is a Number, which is non-zero if a buffer called
		<code class="special">{expr}</code> exists and is loaded (shown in a window or hidden).
		The <code class="special">{expr}</code> argument is used like with |<a href="eval.html#bufexists()">bufexists()</a>|.

bufname(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="bufname()">bufname()</a>*</b>
		The result is the name of a buffer, as it is displayed by the
		":ls" command.
		If <code class="special">{expr}</code> is a Number, that buffer number's name is given.
		Number zero is the alternate buffer for the current window.
		If <code class="special">{expr}</code> is a String, it is used as a |<a href="autocmd.html#file-pattern">file-pattern</a>| to match
		with the buffer names.	This is always done like 'magic' is
		set and 'cpoptions' is empty.  When there is more than one
		match an empty string is returned.
		"" or "%" can be used for the current buffer, "#" for the
		alternate buffer.
		A full match is preferred, otherwise a match at the start, end
		or middle of the buffer name is accepted.  If you only want a
		full match then put "^" at the start and "$" at the end of the
		pattern.
		Listed buffers are found first.  If there is a single match
		with a listed buffer, that one is returned.  Next unlisted
		buffers are searched for.
		If the <code class="special">{expr}</code> is a String, but you want to use it as a buffer
		number, force it to be a Number by adding zero to it:
<code class="example">			:echo bufname("3" + 0)</code>
		If the buffer doesn't exist, or doesn't have a name, an empty
		string is returned.
<code class="example">	bufname("#")		alternate buffer name</code>
<code class="example">	bufname(3)		name of buffer 3</code>
<code class="example">	bufname("%")		name of current buffer</code>
<code class="example">	bufname("file2")	name of buffer where "file2" matches.</code>
							<b class="vimtag">*<a name="buffer_name()">buffer_name()</a>*</b>
		Obsolete name: buffer_name().

							<b class="vimtag">*<a name="bufnr()">bufnr()</a>*</b>
bufnr(<code class="special">{expr}</code> [, <code class="special">{create}</code>])
		The result is the number of a buffer, as it is displayed by
		the ":ls" command.  For the use of <code class="special">{expr}</code>, see |<a href="eval.html#bufname()">bufname()</a>|
		above.
		If the buffer doesn't exist, -1 is returned.  Or, if the
		<code class="special">{create}</code> argument is present and not zero, a new, unlisted,
		buffer is created and its number is returned.
		bufnr("$") is the last buffer:
<code class="example">	:let last_buffer = bufnr("$")</code>
		The result is a Number, which is the highest buffer number
		of existing buffers.  <code class="note">Note</code> that not all buffers with a smaller
		number necessarily exist, because ":bwipeout" may have removed
		them.  Use bufexists() to test for the existence of a buffer.
							<b class="vimtag">*<a name="buffer_number()">buffer_number()</a>*</b>
		Obsolete name: buffer_number().
							<b class="vimtag">*<a name="last_buffer_nr()">last_buffer_nr()</a>*</b>
		Obsolete name for bufnr("$"): last_buffer_nr().

bufwinnr(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="bufwinnr()">bufwinnr()</a>*</b>
		The result is a Number, which is the number of the first
		window associated with buffer <code class="special">{expr}</code>.  For the use of <code class="special">{expr}</code>,
		see |<a href="eval.html#bufname()">bufname()</a>| above.	If buffer <code class="special">{expr}</code> doesn't exist or
		there is no such window, -1 is returned.  Example:
<code class="example"></code>
<code class="example">	echo "A window containing buffer 1 is " . (bufwinnr(1))</code>
<code class="example"></code>
		The number can be used with |<a href="windows.html#CTRL-W_w">CTRL-W_w</a>| and ":wincmd w"
		|<a href="windows.html#:wincmd">:wincmd</a>|.
		Only deals with the current tab page.

byte2line(<code class="special">{byte}</code>)					<b class="vimtag">*<a name="byte2line()">byte2line()</a>*</b>
		Return the line number that contains the character at byte
		count <code class="special">{byte}</code> in the current buffer.  This includes the
		end-of-line character, depending on the 'fileformat' option
		for the current buffer.  The first character has byte count
		one.
		Also see |<a href="eval.html#line2byte()">line2byte()</a>|, |<a href="motion.html#go">go</a>| and |<a href="motion.html#:goto">:goto</a>|.
		{not available when compiled without the |<a href="various.html#+byte_offset">+byte_offset</a>|
		feature}

byteidx(<code class="special">{expr}</code>, <code class="special">{nr}</code>)					<b class="vimtag">*<a name="byteidx()">byteidx()</a>*</b>
		Return byte index of the <code class="special">{nr}</code>'th character in the string
		<code class="special">{expr}</code>.  Use zero for the first character, it returns zero.
		This function is only useful when there are multibyte
		characters, otherwise the returned value is equal to <code class="special">{nr}</code>.
		Composing characters are not counted separately, their byte
		length is added to the preceding base character.  See
		|<a href="eval.html#byteidxcomp()">byteidxcomp()</a>| below for counting composing characters
		separately.
		Example :
<code class="example">			echo matchstr(str, ".", byteidx(str, 3))</code>
		will display the fourth character.  Another way to do the
		same:
<code class="example">			let s = strpart(str, byteidx(str, 3))</code>
<code class="example">			echo strpart(s, 0, byteidx(s, 1))</code>
		Also see |<a href="eval.html#strgetchar()">strgetchar()</a>| and |<a href="eval.html#strcharpart()">strcharpart()</a>|.

		If there are less than <code class="special">{nr}</code> characters -1 is returned.
		If there are exactly <code class="special">{nr}</code> characters the length of the string
		in bytes is returned.

byteidxcomp(<code class="special">{expr}</code>, <code class="special">{nr}</code>)					<b class="vimtag">*<a name="byteidxcomp()">byteidxcomp()</a>*</b>
		Like byteidx(), except that a composing character is counted
		as a separate character.  Example:
<code class="example">			let s = 'e' . nr2char(0x301)</code>
<code class="example">			echo byteidx(s, 1)</code>
<code class="example">			echo byteidxcomp(s, 1)</code>
<code class="example">			echo byteidxcomp(s, 2)</code>
		The first and third echo result in 3 ('e' plus composing
		character is 3 bytes), the second echo results in 1 ('e' is
		one byte).
		Only works different from byteidx() when 'encoding' is set to
		a Unicode encoding.

call(<code class="special">{func}</code>, <code class="special">{arglist}</code> [, <code class="special">{dict}</code>])			<b class="vimtag">*<a name="call()">call()</a>*</b> <b class="vimtag">*<a name="E699">E699</a>*</b>
		Call function <code class="special">{func}</code> with the items in |<a href="eval.html#List">List</a>| <code class="special">{arglist}</code> as
		arguments.
		<code class="special">{func}</code> can either be a |<a href="eval.html#Funcref">Funcref</a>| or the name of a function.
		a:firstline and a:lastline are set to the cursor line.
		Returns the return value of the called function.
		<code class="special">{dict}</code> is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |<a href="eval.html#Dictionary-function">Dictionary-function</a>|

ceil(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="ceil()">ceil()</a>*</b>
		Return the smallest integral value greater than or equal to
		<code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| (round up).
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			echo ceil(1.456)</code>
&lt;			2.0
<code class="example">			echo ceil(-5.456)</code>
&lt;			-5.0
<code class="example">			echo ceil(4.0)</code>
			4.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}

changenr()						<b class="vimtag">*<a name="changenr()">changenr()</a>*</b>
		Return the number of the most recent change.  This is the same
		number as what is displayed with |<a href="undo.html#:undolist">:undolist</a>| and can be used
		with the |<a href="undo.html#:undo">:undo</a>| command.
		When a change was made it is the number of that change.  After
		redo it is the number of the redone change.  After undo it is
		one less than the number of the undone change.

char2nr(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])					<b class="vimtag">*<a name="char2nr()">char2nr()</a>*</b>
		Return number value of the first char in <code class="special">{expr}</code>.  Examples:
<code class="example">			char2nr(" ")		returns 32</code>
<code class="example">			char2nr("ABC")		returns 65</code>
		When <code class="special">{utf8}</code> is omitted or zero, the current 'encoding' is used.
		Example for "utf-8":
<code class="example">			char2nr("")		returns 225</code>
<code class="example">			char2nr(""[0])		returns 195</code>
		With <code class="special">{utf8}</code> set to 1, always treat as utf-8 characters.
		A combining character is a separate character.
		|<a href="eval.html#nr2char()">nr2char()</a>| does the opposite.

cindent(<code class="special">{lnum}</code>)						<b class="vimtag">*<a name="cindent()">cindent()</a>*</b>
		Get the amount of indent for line <code class="special">{lnum}</code> according the C
		indenting rules, as with 'cindent'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  <code class="special">{lnum}</code> is used just like in |<a href="eval.html#getline()">getline()</a>|.
		When <code class="special">{lnum}</code> is invalid or Vim was not compiled the |<a href="various.html#+cindent">+cindent</a>|
		feature, -1 is returned.
		See |<a href="indent.html#C-indenting">C-indenting</a>|.

clearmatches()						<b class="vimtag">*<a name="clearmatches()">clearmatches()</a>*</b>
		Clears all matches previously defined by |<a href="eval.html#matchadd()">matchadd()</a>| and the
		|<a href="pattern.html#:match">:match</a>| commands.

							<b class="vimtag">*<a name="col()">col()</a>*</b>
col(<code class="special">{expr}</code>)	The result is a Number, which is the byte index of the column
		position given with <code class="special">{expr}</code>.  The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of bytes in the cursor line plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |<a href="motion.html#'%3C">'&lt;</a>| in
			    that it's updated right away.
		Additionally <code class="special">{expr}</code> can be [lnum, col]: a |<a href="eval.html#List">List</a>| with the line
		and column number. Most useful when the column is "$", to get
		the last column of a specific line.  When "lnum" or "col" is
		out of range then col() returns zero.
		To get the line number use |<a href="eval.html#line()">line()</a>|.  To get both use
		|<a href="eval.html#getpos()">getpos()</a>|.
		For the screen column position use |<a href="eval.html#virtcol()">virtcol()</a>|.
		<code class="note">Note</code> that only marks in the current file can be used.
		Examples:
<code class="example">			col(".")		column of cursor</code>
<code class="example">			col("$")		length of cursor line plus one</code>
<code class="example">			col("'t")		column of mark t</code>
<code class="example">			col("'" . markname)	column of mark markname</code>
		The first column is 1.	0 is returned for an error.
		For an uppercase mark the column may actually be in another
		buffer.
		For the cursor position, when 'virtualedit' is active, the
		column is one higher if the cursor is after the end of the
		line.  This can be used to obtain the column in Insert mode:
<code class="example">			:imap <code class="special">&lt;F2&gt;</code> <code class="special">&lt;C-O&gt;</code>:let save_ve = &amp;ve<code class="special">&lt;CR&gt;</code></code>
<code class="example">				\<code class="special">&lt;C-O&gt;</code>:set ve=all<code class="special">&lt;CR&gt;</code></code>
<code class="example">				\<code class="special">&lt;C-O&gt;</code>:echo col(".") . "\n" <code class="special">&lt;Bar&gt;</code></code>
<code class="example">				\let &amp;ve = save_ve<code class="special">&lt;CR&gt;</code></code>


complete(<code class="special">{startcol}</code>, <code class="special">{matches}</code>)			<b class="vimtag">*<a name="complete()">complete()</a>*</b> <b class="vimtag">*<a name="E785">E785</a>*</b>
		Set the matches for Insert mode completion.
		Can only be used in Insert mode.  You need to use a mapping
		with <code class="keystroke">CTRL-R</code> = |<a href="insert.html#i_CTRL-R">i_CTRL-R</a>|.  It does not work after <code class="keystroke">CTRL-O</code> or
		with an expression mapping.
		<code class="special">{startcol}</code> is the byte offset in the line where the completed
		text start.  The text up to the cursor is the original text
		that will be replaced by the matches.  Use col('.') for an
		empty string.  "col('.') - 1" will replace one character by a
		match.
		<code class="special">{matches}</code> must be a |<a href="eval.html#List">List</a>|.  Each |<a href="eval.html#List">List</a>| item is one match.
		See |<a href="insert.html#complete-items">complete-items</a>| for the kind of items that are possible.
		<code class="note">Note</code> that the after calling this function you need to avoid
		inserting anything that would cause completion to stop.
		The match can be selected with <code class="keystroke">CTRL-N</code> and <code class="keystroke">CTRL-P</code> as usual with
		Insert mode completion.  The popup menu will appear if
		specified, see |<a href="insert.html#ins-completion-menu">ins-completion-menu</a>|.
		Example:
<code class="example">	inoremap <code class="special">&lt;F5&gt;</code> <code class="special">&lt;C-R&gt;</code>=ListMonths()<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
<code class="example">	func! ListMonths()</code>
<code class="example">	  call complete(col('.'), ['January', 'February', 'March',</code>
<code class="example">		\ 'April', 'May', 'June', 'July', 'August', 'September',</code>
<code class="example">		\ 'October', 'November', 'December'])</code>
<code class="example">	  return ''</code>
<code class="example">	endfunc</code>
		This isn't very useful, but it shows how it works.  <code class="note">Note</code> that
		an empty string is returned to avoid a zero being inserted.

complete_add(<code class="special">{expr}</code>)				<b class="vimtag">*<a name="complete_add()">complete_add()</a>*</b>
		Add <code class="special">{expr}</code> to the list of matches.  Only to be used by the
		function specified with the 'completefunc' option.
		Returns 0 for failure (empty string or out of memory),
		1 when the match was added, 2 when the match was already in
		the list.
		See |<a href="insert.html#complete-functions">complete-functions</a>| for an explanation of <code class="special">{expr}</code>.	It is
		the same as one item in the list that 'omnifunc' would return.

complete_check()				<b class="vimtag">*<a name="complete_check()">complete_check()</a>*</b>
		Check for a key typed while looking for completion matches.
		This is to be used when looking for matches takes some time.
		Returns non-zero when searching for matches is to be aborted,
		zero otherwise.
		Only to be used by the function specified with the
		'completefunc' option.

						<b class="vimtag">*<a name="confirm()">confirm()</a>*</b>
confirm(<code class="special">{msg}</code> [, <code class="special">{choices}</code> [, <code class="special">{default}</code> [, <code class="special">{type}</code>]]])
		Confirm() offers the user a dialog, from which a choice can be
		made.  It returns the number of the choice.  For the first
		choice this is 1.
		<code class="note">Note:</code> confirm() is only supported when compiled with dialog
		support, see |<a href="various.html#+dialog_con">+dialog_con</a>| and |<a href="various.html#+dialog_gui">+dialog_gui</a>|.

		<code class="special">{msg}</code> is displayed in a |<a href="gui_w32.html#dialog">dialog</a>| with <code class="special">{choices}</code> as the
		alternatives.  When <code class="special">{choices}</code> is missing or empty, "&amp;OK" is
		used (and translated).
		<code class="special">{msg}</code> is a String, use '\n' to include a newline.  Only on
		some systems the string is wrapped when it doesn't fit.

		<code class="special">{choices}</code> is a String, with the individual choices separated
		by '\n', e.g.
<code class="example">			confirm("Save changes?", "&amp;Yes\n&amp;No\n&amp;Cancel")</code>
		The letter after the '&amp;' is the shortcut key for that choice.
		Thus you can type 'c' to select "Cancel".  The shortcut does
		not need to be the first letter:
<code class="example">			confirm("file has been modified", "&amp;Save\nSave &amp;All")</code>
		For the console, the first letter of each choice is used as
		the default shortcut key.

		The optional <code class="special">{default}</code> argument is the number of the choice
		that is made if the user hits <code class="special">&lt;CR&gt;</code>.  Use 1 to make the first
		choice the default one.  Use 0 to not set a default.  If
		<code class="special">{default}</code> is omitted, 1 is used.

		The optional <code class="special">{type}</code> argument gives the type of dialog.  This
		is only used for the icon of the GTK, Mac, Motif and Win32
		GUI.  It can be one of these values: "Error", "Question",
		"Info", "Warning" or "Generic".  Only the first character is
		relevant.  When <code class="special">{type}</code> is omitted, "Generic" is used.

		If the user aborts the dialog by pressing <code class="special">&lt;Esc&gt;</code>, <code class="keystroke">CTRL-C</code>,
		or another valid interrupt key, confirm() returns 0.

		An example:
<code class="example">   :let choice = confirm("What do you want?", "&amp;Apples\n&amp;Oranges\n&amp;Bananas", 2)</code>
<code class="example">   :if choice == 0</code>
<code class="example">   :	echo "make up your mind!"</code>
<code class="example">   :elseif choice == 3</code>
<code class="example">   :	echo "tasteful"</code>
<code class="example">   :else</code>
<code class="example">   :	echo "I prefer bananas myself."</code>
<code class="example">   :endif</code>
		In a GUI dialog, buttons are used.  The layout of the buttons
		depends on the 'v' flag in 'guioptions'.  If it is included,
		the buttons are always put vertically.	Otherwise,  confirm()
		tries to put the buttons in one horizontal line.  If they
		don't fit, a vertical layout is used anyway.  For some systems
		the horizontal layout is always used.

ch_close(<code class="special">{handle}</code>)						<b class="vimtag">*<a name="ch_close()">ch_close()</a>*</b>
		Close <code class="special">{handle}</code>.  See |<a href="channel.html#channel-close">channel-close</a>|.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_evalexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])			<b class="vimtag">*<a name="ch_evalexpr()">ch_evalexpr()</a>*</b>
		Send <code class="special">{expr}</code> over <code class="special">{handle}</code>.  The <code class="special">{expr}</code> is encoded
		according to the type of channel.  The function cannot be used
		with a raw channel.  See |<a href="channel.html#channel-use">channel-use</a>|.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.
								<b class="vimtag">*<a name="E917">E917</a>*</b>
		<code class="special">{options}</code> must be a Dictionary.  It must not have a "callback"
		entry.  It can have a "timeout" entry to specify the timeout
		for this specific request.

		ch_evalexpr() waits for a response and returns the decoded
		expression.  When there is an error or timeout it returns an
		empty string.

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_evalraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])		<b class="vimtag">*<a name="ch_evalraw()">ch_evalraw()</a>*</b>
		Send <code class="special">{string}</code> over <code class="special">{handle}</code>.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.

		Works like |<a href="eval.html#ch_evalexpr()">ch_evalexpr()</a>|, but does not encode the request or
		decode the response.  The caller is responsible for the
		correct contents.  Also does not add a newline for a channel
		in NL mode, the caller must do that.  The NL in the response
		is removed.
		See |<a href="channel.html#channel-use">channel-use</a>|.

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_getbufnr(<code class="special">{handle}</code>, <code class="special">{what}</code>)				 <b class="vimtag">*<a name="ch_getbufnr()">ch_getbufnr()</a>*</b>
		Get the buffer number that <code class="special">{handle}</code> is using for <code class="special">{what}</code>.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.
		<code class="special">{what}</code> can be "err" for stderr, "out" for stdout or empty for
		socket output.
		Returns -1 when there is no buffer.
		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_getjob(<code class="special">{channel}</code>)						<b class="vimtag">*<a name="ch_getjob()">ch_getjob()</a>*</b>
		Get the Job associated with <code class="special">{channel}</code>.
		If there is no job calling |<a href="eval.html#job_status()">job_status()</a>| on the returned Job
		will result in "fail".

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| and
		|<a href="various.html#+job">+job</a>| features}

ch_info(<code class="special">{handle}</code>)						<b class="vimtag">*<a name="ch_info()">ch_info()</a>*</b>
		Returns a Dictionary with information about <code class="special">{handle}</code>.  The
		items are:
		   "id"		  number of the channel
		   "status"	  "open" (any part is open) or "closed"
		When opened with ch_open():
		   "hostname"	  the hostname of the address
		   "port"	  the port of the address
		   "sock_status"  "open" or "closed"
		   "sock_mode"	  "NL", "RAW", "JSON" or "JS"
		   "sock_io"	  "socket"
		   "sock_timeout" timeout in msec
		When opened with job_start():
		   "out_status"	  "open" or "closed"
		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
		   "out_io"	  "null", "pipe", "file" or "buffer"
		   "out_timeout"  timeout in msec
		   "err_status"	  "open" or "closed"
		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
		   "err_timeout"  timeout in msec
		   "in_status"	  "open" or "closed"
		   "in_mode"	  "NL", "RAW", "JSON" or "JS"
		   "in_io"	  "null", "pipe", "file" or "buffer"
		   "in_timeout"	  timeout in msec

ch_log(<code class="special">{msg}</code> [, <code class="special">{handle}</code>])					<b class="vimtag">*<a name="ch_log()">ch_log()</a>*</b>
		Write <code class="special">{msg}</code> in the channel log file, if it was opened with
		|<a href="eval.html#ch_logfile()">ch_logfile()</a>|.
		When <code class="special">{handle}</code> is passed the channel number is used for the
		message.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.  The
		Channel must open.

ch_logfile(<code class="special">{fname}</code> [, <code class="special">{mode}</code>])					<b class="vimtag">*<a name="ch_logfile()">ch_logfile()</a>*</b>
		Start logging channel activity to <code class="special">{fname}</code>.
		When <code class="special">{fname}</code> is an empty string: stop logging.

		When <code class="special">{mode}</code> is omitted or "a" append to the file.
		When <code class="special">{mode}</code> is "w" start with an empty file.

		The file is flushed after every message, on Unix you can use
		"tail -f" to see what is going on in real time.


ch_open(<code class="special">{address}</code> [, <code class="special">{options}</code>])				<b class="vimtag">*<a name="ch_open()">ch_open()</a>*</b>
		Open a channel to <code class="special">{address}</code>.  See |<a href="channel.html#channel">channel</a>|.
		Returns a Channel.  Use |<a href="eval.html#ch_status()">ch_status()</a>| to check for failure.

		<code class="special">{address}</code> has the form "hostname:port", e.g.,
		"localhost:8765".

		If <code class="special">{options}</code> is given it must be a |<a href="eval.html#Dictionary">Dictionary</a>|.
		See |<a href="channel.html#channel-open-options">channel-open-options</a>|.

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_read(<code class="special">{handle}</code> [, <code class="special">{options}</code>])					<b class="vimtag">*<a name="ch_read()">ch_read()</a>*</b>
		Read from <code class="special">{handle}</code> and return the received message.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.
		See |<a href="channel.html#channel-more">channel-more</a>|.
		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_readraw(<code class="special">{handle}</code> [, <code class="special">{options}</code>])			<b class="vimtag">*<a name="ch_readraw()">ch_readraw()</a>*</b>
		Like ch_read() but for a JS and JSON channel does not decode
		the message.  See |<a href="channel.html#channel-more">channel-more</a>|.
		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_sendexpr(<code class="special">{handle}</code>, <code class="special">{expr}</code> [, <code class="special">{options}</code>])			<b class="vimtag">*<a name="ch_sendexpr()">ch_sendexpr()</a>*</b>
		Send <code class="special">{expr}</code> over <code class="special">{handle}</code>.  The <code class="special">{expr}</code> is encoded
		according to the type of channel.  The function cannot be used
		with a raw channel.
		See |<a href="channel.html#channel-use">channel-use</a>|.				<b class="vimtag">*<a name="E912">E912</a>*</b>
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_sendraw(<code class="special">{handle}</code>, <code class="special">{string}</code> [, <code class="special">{options}</code>])		<b class="vimtag">*<a name="ch_sendraw()">ch_sendraw()</a>*</b>
		Send <code class="special">{string}</code> over <code class="special">{handle}</code>.
		Works like |<a href="eval.html#ch_sendexpr()">ch_sendexpr()</a>|, but does not encode the request or
		decode the response.  The caller is responsible for the
		correct contents.  Also does not add a newline for a channel
		in NL mode, the caller must do that.  The NL in the response
		is removed.
		See |<a href="channel.html#channel-use">channel-use</a>|.

		{only available when compiled with the |<a href="various.html#+channel">+channel</a>| feature}

ch_setoptions(<code class="special">{handle}</code>, <code class="special">{options}</code>)			<b class="vimtag">*<a name="ch_setoptions()">ch_setoptions()</a>*</b>
		Set options on <code class="special">{handle}</code>:
			"callback"	the channel callback
			"timeout"	default read timeout in msec
			"mode"		mode for the whole channel
		See |<a href="eval.html#ch_open()">ch_open()</a>| for more explanation.
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.

		<code class="note">Note</code> that changing the mode may cause queued messages to be
		lost.

		These options cannot be changed:
			"waittime"	only applies to "ch_open()|

ch_status(<code class="special">{handle}</code>)						<b class="vimtag">*<a name="ch_status()">ch_status()</a>*</b>
		Return the status of <code class="special">{handle}</code>:
			"fail"		failed to open the channel
			"open"		channel can be used
			"buffered"	channel can be read, not written to
			"closed"	channel can not be used
		<code class="special">{handle}</code> can be Channel or a Job that has a Channel.
		"buffered" is used when the channel was closed but there is
		still data that can be obtained with |<a href="eval.html#ch_read()">ch_read()</a>|.

							<b class="vimtag">*<a name="copy()">copy()</a>*</b>
copy(<code class="special">{expr}</code>)	Make a copy of <code class="special">{expr}</code>.	For Numbers and Strings this isn't
		different from using <code class="special">{expr}</code> directly.
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| a shallow copy is created.  This means
		that the original |<a href="eval.html#List">List</a>| can be changed without changing the
		copy, and vice versa.  But the items are identical, thus
		changing an item changes the contents of both |<a href="eval.html#Lists">Lists</a>|.
		A |<a href="eval.html#Dictionary">Dictionary</a>| is copied in a similar way as a |<a href="eval.html#List">List</a>|.
		Also see |<a href="eval.html#deepcopy()">deepcopy()</a>|.

cos(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="cos()">cos()</a>*</b>
		Return the cosine of <code class="special">{expr}</code>, measured in radians, as a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo cos(100)</code>
&lt;			0.862319
<code class="example">			:echo cos(-4.01)</code>
			-0.646043
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


cosh(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="cosh()">cosh()</a>*</b>
		Return the hyperbolic cosine of <code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| in the range
		[1, inf].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo cosh(0.5)</code>
&lt;			1.127626
<code class="example">			:echo cosh(-0.5)</code>
			-1.127626
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


count(<code class="special">{comp}</code>, <code class="special">{expr}</code> [, <code class="special">{ic}</code> [, <code class="special">{start}</code>]])			<b class="vimtag">*<a name="count()">count()</a>*</b>
		Return the number of times an item with value <code class="special">{expr}</code> appears
		in |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| <code class="special">{comp}</code>.
		If <code class="special">{start}</code> is given then start with the item with this index.
		<code class="special">{start}</code> can only be used with a |<a href="eval.html#List">List</a>|.
		When <code class="special">{ic}</code> is given and it's non-zero then case is ignored.


							<b class="vimtag">*<a name="cscope_connection()">cscope_connection()</a>*</b>
cscope_connection([<code class="special">{num}</code> , <code class="special">{dbpath}</code> [, <code class="special">{prepend}</code>]])
		Checks for the existence of a |<a href="if_cscop.html#cscope">cscope</a>| connection.  If no
		parameters are specified, then the function returns:
			0, if cscope was not available (not compiled in), or
			   if there are no cscope connections;
			1, if there is at least one cscope connection.

		If parameters are specified, then the value of <code class="special">{num}</code>
		determines how existence of a cscope connection is checked:

		<code class="special">{num}</code>	Description of existence check
		-----	------------------------------
		0	Same as no parameters (e.g., "cscope_connection()").
		1	Ignore <code class="special">{prepend}</code>, and use partial string matches for
			<code class="special">{dbpath}</code>.
		2	Ignore <code class="special">{prepend}</code>, and use exact string matches for
			<code class="special">{dbpath}</code>.
		3	Use <code class="special">{prepend}</code>, use partial string matches for both
			<code class="special">{dbpath}</code> and <code class="special">{prepend}</code>.
		4	Use <code class="special">{prepend}</code>, use exact string matches for both
			<code class="special">{dbpath}</code> and <code class="special">{prepend}</code>.

		<code class="note">Note:</code> All string comparisons are case sensitive!

		Examples.  Suppose we had the following (from ":cs show"):
<code class="example"></code>
<code class="example">  # pid    database name			prepend path</code>
<code class="example">  0 27664  cscope.out				/usr/local</code>

<code class="section">		Invocation					Return Val </code>
		----------					----------
<code class="example">		cscope_connection()					1</code>
<code class="example">		cscope_connection(1, "out")				1</code>
<code class="example">		cscope_connection(2, "out")				0</code>
<code class="example">		cscope_connection(3, "out")				0</code>
<code class="example">		cscope_connection(3, "out", "local")			1</code>
<code class="example">		cscope_connection(4, "out")				0</code>
<code class="example">		cscope_connection(4, "out", "local")			0</code>
<code class="example">		cscope_connection(4, "cscope.out", "/usr/local")	1</code>

cursor(<code class="special">{lnum}</code>, <code class="special">{col}</code> [, <code class="special">{off}</code>])				<b class="vimtag">*<a name="cursor()">cursor()</a>*</b>
cursor(<code class="special">{list}</code>)
		Positions the cursor at the column (byte count) <code class="special">{col}</code> in the
		line <code class="special">{lnum}</code>.  The first column is one.

		When there is one argument <code class="special">{list}</code> this is used as a |<a href="eval.html#List">List</a>|
		with two, three or four item:
			[<code class="special">{lnum}</code>, <code class="special">{col}</code>]
			[<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>]
			[<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{off}</code>, <code class="special">{curswant}</code>]
		This is like the return value of |<a href="eval.html#getpos()">getpos()</a>| or |<a href="eval.html#getcurpos()">getcurpos()</a>|,
		but without the first item.

		Does not change the jumplist.
		If <code class="special">{lnum}</code> is greater than the number of lines in the buffer,
		the cursor will be positioned at the last line in the buffer.
		If <code class="special">{lnum}</code> is zero, the cursor will stay in the current line.
		If <code class="special">{col}</code> is greater than the number of bytes in the line,
		the cursor will be positioned at the last character in the
		line.
		If <code class="special">{col}</code> is zero, the cursor will stay in the current column.
		If <code class="special">{curswant}</code> is given it is used to set the preferred column
		for vertical movement.  Otherwise <code class="special">{col}</code> is used.

		When 'virtualedit' is used <code class="special">{off}</code> specifies the offset in
		screen columns from the start of the character.  E.g., a
		position within a <code class="special">&lt;Tab&gt;</code> or after the last character.
		Returns 0 when the position could be set, -1 otherwise.


deepcopy(<code class="special">{expr}</code>[, <code class="special">{noref}</code>])				<b class="vimtag">*<a name="deepcopy()">deepcopy()</a>*</b> <b class="vimtag">*<a name="E698">E698</a>*</b>
		Make a copy of <code class="special">{expr}</code>.	For Numbers and Strings this isn't
		different from using <code class="special">{expr}</code> directly.
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| a full copy is created.  This means
		that the original |<a href="eval.html#List">List</a>| can be changed without changing the
		copy, and vice versa.  When an item is a |<a href="eval.html#List">List</a>| or
		|<a href="eval.html#Dictionary">Dictionary</a>|, a copy for it is made, recursively.  Thus
		changing an item in the copy does not change the contents of
		the original |<a href="eval.html#List">List</a>|.
		A |<a href="eval.html#Dictionary">Dictionary</a>| is copied in a similar way as a |<a href="eval.html#List">List</a>|.
		When <code class="special">{noref}</code> is omitted or zero a contained |<a href="eval.html#List">List</a>| or
		|<a href="eval.html#Dictionary">Dictionary</a>| is only copied once.  All references point to
		this single copy.  With <code class="special">{noref}</code> set to 1 every occurrence of a
		|<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| results in a new copy.  This also means
		that a cyclic reference causes deepcopy() to fail.
								<b class="vimtag">*<a name="E724">E724</a>*</b>
		Nesting is possible up to 100 levels.  When there is an item
		that refers back to a higher level making a deep copy with
		<code class="special">{noref}</code> set to 1 will fail.
		Also see |<a href="eval.html#copy()">copy()</a>|.

delete(<code class="special">{fname}</code> [, <code class="special">{flags}</code>])					<b class="vimtag">*<a name="delete()">delete()</a>*</b>
		Without <code class="special">{flags}</code> or with <code class="special">{flags}</code> empty: Deletes the file by the
		name <code class="special">{fname}</code>.  This also works when <code class="special">{fname}</code> is a symbolic link.

		When <code class="special">{flags}</code> is "d": Deletes the directory by the name
		<code class="special">{fname}</code>.  This fails when directory <code class="special">{fname}</code> is not empty.

		When <code class="special">{flags}</code> is "rf": Deletes the directory by the name
		<code class="special">{fname}</code> and everything in it, recursively.  BE CAREFUL!
		A symbolic link itself is deleted, not what it points to.

		The result is a Number, which is 0 if the delete operation was
		successful and -1 when the deletion failed or partly failed.

		Use |<a href="eval.html#remove()">remove()</a>| to delete an item from a |<a href="eval.html#List">List</a>|.
		To delete a line from the buffer use |<a href="change.html#:delete">:delete</a>|.  Use |<a href="eval.html#:exe">:exe</a>|
		when the line number is in a variable.

							<b class="vimtag">*<a name="did_filetype()">did_filetype()</a>*</b>
did_filetype()	Returns non-zero when autocommands are being executed and the
		FileType event has been triggered at least once.  Can be used
		to avoid triggering the FileType event again in the scripts
		that detect the file type. |<a href="autocmd.html#FileType">FileType</a>|
		When editing another file, the counter is reset, thus this
		really checks if the FileType event has been triggered for the
		current buffer.  This allows an autocommand that starts
		editing another buffer to set 'filetype' and load a syntax
		file.

diff_filler(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="diff_filler()">diff_filler()</a>*</b>
		Returns the number of filler lines above line <code class="special">{lnum}</code>.
		These are the lines that were inserted at this point in
		another diff'ed window.  These filler lines are shown in the
		display but don't exist in the buffer.
		<code class="special">{lnum}</code> is used like with |<a href="eval.html#getline()">getline()</a>|.  Thus "." is the current
		line, "'m" mark m, etc.
		Returns 0 if the current window is not in diff mode.

diff_hlID(<code class="special">{lnum}</code>, <code class="special">{col}</code>)				<b class="vimtag">*<a name="diff_hlID()">diff_hlID()</a>*</b>
		Returns the highlight ID for diff mode at line <code class="special">{lnum}</code> column
		<code class="special">{col}</code> (byte index).  When the current line does not have a
		diff change zero is returned.
		<code class="special">{lnum}</code> is used like with |<a href="eval.html#getline()">getline()</a>|.  Thus "." is the current
		line, "'m" mark m, etc.
		<code class="special">{col}</code> is 1 for the leftmost column, <code class="special">{lnum}</code> is 1 for the first
		line.
		The highlight ID can be used with |<a href="eval.html#synIDattr()">synIDattr()</a>| to obtain
		syntax information about the highlighting.

					<b class="vimtag">*<a name="disable_char_avail_for_testing()">disable_char_avail_for_testing()</a>*</b>
disable_char_avail_for_testing(<code class="special">{expr}</code>)
		When <code class="special">{expr}</code> is 1 the internal char_avail() function will
		return FALSE.  When <code class="special">{expr}</code> is 0 the char_avail() function will
		function normally.
		Only use this for a test where typeahead causes the test not
		to work.  E.g., to trigger the CursorMovedI autocommand event.

empty(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="empty()">empty()</a>*</b>
		Return the Number 1 if <code class="special">{expr}</code> is empty, zero otherwise.
		- A |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| is empty when it does not have any
		  items.
		- A Number and Float is empty when its value is zero.
		- |<a href="eval.html#v:false">v:false</a>|, |<a href="eval.html#v:none">v:none</a>| and |<a href="eval.html#v:null">v:null</a>| are empty, |<a href="eval.html#v:true">v:true</a>| is not.
		- A Job is empty when it failed to start.
		- A Channel is empty when it is closed.

		For a long |<a href="eval.html#List">List</a>| this is much faster than comparing the
		length with zero.

escape(<code class="special">{string}</code>, <code class="special">{chars}</code>)				<b class="vimtag">*<a name="escape()">escape()</a>*</b>
		Escape the characters in <code class="special">{chars}</code> that occur in <code class="special">{string}</code> with a
		backslash.  Example:
<code class="example">			:echo escape('c:\program files\vim', ' \')</code>
&lt;		results in:
<code class="example">			c:\\program\ files\\vim</code>
		Also see |<a href="eval.html#shellescape()">shellescape()</a>|.

							<b class="vimtag">*<a name="eval()">eval()</a>*</b>
eval(<code class="special">{string}</code>)	Evaluate <code class="special">{string}</code> and return the result.  Especially useful to
		turn the result of |<a href="eval.html#string()">string()</a>| back into the original value.
		This works for Numbers, Floats, Strings and composites of
		them.  Also works for |<a href="eval.html#Funcref">Funcref</a>|s that refer to existing
		functions.

eventhandler()						<b class="vimtag">*<a name="eventhandler()">eventhandler()</a>*</b>
		Returns 1 when inside an event handler.  That is that Vim got
		interrupted while waiting for the user to type a character,
		e.g., when dropping a file on Vim.  This means interactive
		commands cannot be used.  Otherwise zero is returned.

executable(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="executable()">executable()</a>*</b>
		This function checks if an executable with the name <code class="special">{expr}</code>
		exists.  <code class="special">{expr}</code> must be the name of the program without any
		arguments.
		executable() uses the value of $PATH and/or the normal
		searchpath for programs.		<b class="vimtag">*<a name="PATHEXT">PATHEXT</a>*</b>
		On MS-DOS and MS-Windows the ".exe", ".bat", etc. can
		optionally be included.  Then the extensions in $PATHEXT are
		tried.	Thus if "foo.exe" does not exist, "foo.exe.bat" can be
		found.	If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is
		used.  A dot by itself can be used in $PATHEXT to try using
		the name without an extension.	When 'shell' looks like a
		Unix shell, then the name is also tried without adding an
		extension.
		On MS-DOS and MS-Windows it only checks if the file exists and
		is not a directory, not if it's really executable.
		On MS-Windows an executable in the same directory as Vim is
		always found.  Since this directory is added to $PATH it
		should also work to execute it |<a href="os_win32.html#win32-PATH">win32-PATH</a>|.
		The result is a Number:
			1	exists
			0	does not exist
			-1	not implemented on this system

exepath(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="exepath()">exepath()</a>*</b>
		If <code class="special">{expr}</code> is an executable and is either an absolute path, a
		relative path or found in $PATH, return the full path.
		<code class="note">Note</code> that the current directory is used when <code class="special">{expr}</code> starts
		with "./", which may be a problem for Vim:
<code class="example">			echo exepath(v:progpath)</code>
		If <code class="special">{expr}</code> cannot be found in $PATH or is not executable then
		an empty string is returned.

							<b class="vimtag">*<a name="exists()">exists()</a>*</b>
exists(<code class="special">{expr}</code>)	The result is a Number, which is non-zero if <code class="special">{expr}</code> is
		defined, zero otherwise.  The <code class="special">{expr}</code> argument is a string,
		which contains one of these:
			&amp;option-name	Vim option (only checks if it exists,
					not if it really works)
			+option-name	Vim option that works.
			$ENVNAME	environment variable (could also be
					done by comparing with an empty
					string)
			*funcname	built-in function (see |<a href="eval.html#functions">functions</a>|)
					or user defined function (see
					|<a href="eval.html#user-functions">user-functions</a>|). Also works for a
					variable that is a Funcref.
			varname		internal variable (see
					|<a href="eval.html#internal-variables">internal-variables</a>|).	Also works
					for |<a href="eval.html#curly-braces-names">curly-braces-names</a>|, |<a href="eval.html#Dictionary">Dictionary</a>|
					entries, |<a href="eval.html#List">List</a>| items, etc.  Beware
					that evaluating an index may cause an
					error message for an invalid
					expression.  E.g.:
<code class="example">					   :let l = [1, 2, 3]</code>
<code class="example">					   :echo exists("l[5]")</code>
&lt;					   0
<code class="example">					   :echo exists("l[xx]")</code>
					   E121: Undefined variable: xx
					   0
			:cmdname	Ex command: built-in command, user
					command or command modifier |<a href="map.html#:command">:command</a>|.
					Returns:
					1  for match with start of a command
					2  full match with a command
					3  matches several user commands
					To check for a supported command
					always check the return value to be 2.
			:2match		The |<a href="pattern.html#:2match">:2match</a>| command.
			:3match		The |<a href="pattern.html#:3match">:3match</a>| command.
			#event		autocommand defined for this event
			#event#pattern	autocommand defined for this event and
					pattern (the pattern is taken
					literally and compared to the
					autocommand patterns character by
					character)
			#group		autocommand group exists
			#group#event	autocommand defined for this group and
					event.
			#group#event#pattern
					autocommand defined for this group,
					event and pattern.
			##event		autocommand for this event is
					supported.
		For checking for a supported feature use |<a href="eval.html#has()">has()</a>|.

		Examples:
<code class="example">			exists("&amp;shortname")</code>
<code class="example">			exists("$HOSTNAME")</code>
<code class="example">			exists("*strftime")</code>
<code class="example">			exists("*s:MyFunc")</code>
<code class="example">			exists("bufcount")</code>
<code class="example">			exists(":Make")</code>
<code class="example">			exists("#CursorHold")</code>
<code class="example">			exists("#BufReadPre#*.gz")</code>
<code class="example">			exists("#filetypeindent")</code>
<code class="example">			exists("#filetypeindent#FileType")</code>
<code class="example">			exists("#filetypeindent#FileType#*")</code>
<code class="example">			exists("##ColorScheme")</code>
		There must be no space between the symbol (&amp;/$/*/#) and the
		name.
		There must be no extra characters after the name, although in
		a few cases this is ignored.  That may become more strict in
		the future, thus don't count on it!
		Working example:
<code class="example">			exists(":make")</code>
&lt;		NOT working example:
<code class="example">			exists(":make install")</code>
<code class="example"></code>
		<code class="note">Note</code> that the argument must be a string, not the name of the
		variable itself.  For example:
<code class="example">			exists(bufcount)</code>
		This doesn't check for existence of the "bufcount" variable,
		but gets the value of "bufcount", and checks if that exists.

exp(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="exp()">exp()</a>*</b>
		Return the exponential of <code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| in the range
		[0, inf].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo exp(2)</code>
&lt;			7.389056
<code class="example">			:echo exp(-1)</code>
			0.367879
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


expand(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code>]])				<b class="vimtag">*<a name="expand()">expand()</a>*</b>
		Expand wildcards and the following special keywords in <code class="special">{expr}</code>.
		'wildignorecase' applies.

		If <code class="special">{list}</code> is given and it is non-zero, a List will be returned.
		Otherwise the result is a String and when there are several
		matches, they are separated by <code class="special">&lt;NL&gt;</code> characters.  [<code class="note">Note:</code> in
		version 5.0 a space was used, which caused problems when a
		file name contains a space]

		If the expansion fails, the result is an empty string.	A name
		for a non-existing file is not included, unless <code class="special">{expr}</code> does
		not start with '%', '#' or '&lt;', see below.

		When <code class="special">{expr}</code> starts with '%', '#' or '&lt;', the expansion is done
		like for the |<a href="cmdline.html#cmdline-special">cmdline-special</a>| variables with their associated
		modifiers.  Here is a short overview:

			%		current file name
			#		alternate file name
			#n		alternate file name n
			<code class="special">&lt;cfile&gt;</code>		file name under the cursor
			<code class="special">&lt;afile&gt;</code>		autocmd file name
			<code class="special">&lt;abuf&gt;</code>		autocmd buffer number (as a String!)
			<code class="special">&lt;amatch&gt;</code>	autocmd matched name
			<code class="special">&lt;sfile&gt;</code>		sourced script file or function name
			<code class="special">&lt;slnum&gt;</code>		sourced script file line number
			<code class="special">&lt;cword&gt;</code>		word under the cursor
			<code class="special">&lt;cWORD&gt;</code>		WORD under the cursor
			<code class="special">&lt;client&gt;</code>	the <code class="special">{clientid}</code> of the last received
					message |<a href="eval.html#server2client()">server2client()</a>|
		Modifiers:
			:p		expand to full path
			:h		head (last path component removed)
			:t		tail (last path component only)
			:r		root (one extension removed)
			:e		extension only

		Example:
<code class="example">			:let &amp;tags = expand("%:p:h") . "/tags"</code>
		<code class="note">Note</code> that when expanding a string that starts with '%', '#' or
		'&lt;', any following text is ignored.  This does NOT work:
<code class="example">			:let doesntwork = expand("%:h.bak")</code>
&lt;		Use this:
<code class="example">			:let doeswork = expand("%:h") . ".bak"</code>
		Also <code class="note">note</code> that expanding "<code class="special">&lt;cfile&gt;</code>" and others only returns the
		referenced file name without further expansion.  If "<code class="special">&lt;cfile&gt;</code>"
		is "~/.cshrc", you need to do another expand() to have the
		"~/" expanded into the path of the home directory:
<code class="example">			:echo expand(expand("<code class="special">&lt;cfile&gt;</code>"))</code>

		There cannot be white space between the variables and the
		following modifier.  The |<a href="eval.html#fnamemodify()">fnamemodify()</a>| function can be used
		to modify normal file names.

		When using '%' or '#', and the current or alternate file name
		is not defined, an empty string is used.  Using "%:p" in a
		buffer with no name, results in the current directory, with a
		'/' added.

		When <code class="special">{expr}</code> does not start with '%', '#' or '&lt;', it is
		expanded like a file name is expanded on the command line.
		'suffixes' and 'wildignore' are used, unless the optional
		<code class="special">{nosuf}</code> argument is given and it is non-zero.
		Names for non-existing files are included.  The "**" item can
		be used to search in a directory tree.  For example, to find
		all "README" files in the current directory and below:
<code class="example">			:echo expand("**/README")</code>

		Expand() can also be used to expand variables and environment
		variables that are only known in a shell.  But this can be
		slow, because a shell may be used to do the expansion.  See
		|<a href="eval.html#expr-env-expand">expr-env-expand</a>|.
		The expanded variable is still handled like a list of file
		names.	When an environment variable cannot be expanded, it is
		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
		"$FOOBAR".

		See |<a href="eval.html#glob()">glob()</a>| for finding existing files.  See |<a href="eval.html#system()">system()</a>| for
		getting the raw output of an external command.

extend(<code class="special">{expr1}</code>, <code class="special">{expr2}</code> [, <code class="special">{expr3}</code>])			<b class="vimtag">*<a name="extend()">extend()</a>*</b>
		<code class="special">{expr1}</code> and <code class="special">{expr2}</code> must be both |<a href="eval.html#Lists">Lists</a>| or both
		|<a href="eval.html#Dictionaries">Dictionaries</a>|.

		If they are |<a href="eval.html#Lists">Lists</a>|: Append <code class="special">{expr2}</code> to <code class="special">{expr1}</code>.
		If <code class="special">{expr3}</code> is given insert the items of <code class="special">{expr2}</code> before item
		<code class="special">{expr3}</code> in <code class="special">{expr1}</code>.  When <code class="special">{expr3}</code> is zero insert before the
		first item.  When <code class="special">{expr3}</code> is equal to len(<code class="special">{expr1}</code>) then
		<code class="special">{expr2}</code> is appended.
		Examples:
<code class="example">			:echo sort(extend(mylist, [7, 5]))</code>
<code class="example">			:call extend(mylist, [2, 3], 1)</code>
		When <code class="special">{expr1}</code> is the same List as <code class="special">{expr2}</code> then the number of
		items copied is equal to the original length of the List.
		E.g., when <code class="special">{expr3}</code> is 1 you get N new copies of the first item
		(where N is the original length of the List).
		Use |<a href="eval.html#add()">add()</a>| to concatenate one item to a list.	To concatenate
		two lists into a new list use the + operator:
<code class="example">			:let newlist = [1, 2, 3] + [4, 5]</code>

		If they are |<a href="eval.html#Dictionaries">Dictionaries</a>|:
		Add all entries from <code class="special">{expr2}</code> to <code class="special">{expr1}</code>.
		If a key exists in both <code class="special">{expr1}</code> and <code class="special">{expr2}</code> then <code class="special">{expr3}</code> is
		used to decide what to do:
		<code class="special">{expr3}</code> = "keep": keep the value of <code class="special">{expr1}</code>
		<code class="special">{expr3}</code> = "force": use the value of <code class="special">{expr2}</code>
		<code class="special">{expr3}</code> = "error": give an error message		<b class="vimtag">*<a name="E737">E737</a>*</b>
		When <code class="special">{expr3}</code> is omitted then "force" is assumed.

		<code class="special">{expr1}</code> is changed when <code class="special">{expr2}</code> is not empty.  If necessary
		make a copy of <code class="special">{expr1}</code> first.
		<code class="special">{expr2}</code> remains unchanged.
		When <code class="special">{expr1}</code> is locked and <code class="special">{expr2}</code> is not empty the operation
		fails.
		Returns <code class="special">{expr1}</code>.


feedkeys(<code class="special">{string}</code> [, <code class="special">{mode}</code>])				<b class="vimtag">*<a name="feedkeys()">feedkeys()</a>*</b>
		Characters in <code class="special">{string}</code> are queued for processing as if they
		come from a mapping or were typed by the user.
		By default the string is added to the end of the typeahead
		buffer, thus if a mapping is still being executed the
		characters come after them.  Use the 'i' flag to insert before
		other characters, they will be executed next, before any
		characters from a mapping.
		The function does not wait for processing of keys contained in
		<code class="special">{string}</code>.
		To include special keys into <code class="special">{string}</code>, use double-quotes
		and "\..." notation |<a href="eval.html#expr-quote">expr-quote</a>|. For example,
		feedkeys("\<code class="special">&lt;CR&gt;</code>") simulates pressing of the <code class="special">&lt;Enter&gt;</code> key. But
		feedkeys('\<code class="special">&lt;CR&gt;</code>') pushes 5 characters.
		If <code class="special">{mode}</code> is absent, keys are remapped.
		<code class="special">{mode}</code> is a String, which can contain these character flags:
		'm'	Remap keys. This is default.
		'n'	Do not remap keys.
		't'	Handle keys as if typed; otherwise they are handled as
			if coming from a mapping.  This matters for undo,
			opening folds, etc.
		'i'	Insert the string instead of appending (see above).
		'x'	Execute commands until typeahead is empty.  This is
			similar to using ":normal!".  You can call feedkeys()
			several times without 'x' and then one time with 'x'
			(possibly with an empty <code class="special">{string}</code>) to execute all the
			typeahead.  <code class="note">Note</code> that when Vim ends in Insert mode it
			will behave as if <code class="special">&lt;Esc&gt;</code> is typed, to avoid getting
			stuck, waiting for a character to be typed before the
			script continues.
		'!'	When used with 'x' will not end Insert mode. Can be
			used in a test when a timer is set to exit Insert mode
			a little later.  Useful for testing CursorHoldI.

		Return value is always 0.

filereadable(<code class="special">{file}</code>)					<b class="vimtag">*<a name="filereadable()">filereadable()</a>*</b>
		The result is a Number, which is TRUE when a file with the
		name <code class="special">{file}</code> exists, and can be read.  If <code class="special">{file}</code> doesn't exist,
		or is a directory, the result is FALSE.  <code class="special">{file}</code> is any
		expression, which is used as a String.
		If you don't care about the file being readable you can use
		|<a href="eval.html#glob()">glob()</a>|.
							<b class="vimtag">*<a name="file_readable()">file_readable()</a>*</b>
		Obsolete name: file_readable().


filewritable(<code class="special">{file}</code>)					<b class="vimtag">*<a name="filewritable()">filewritable()</a>*</b>
		The result is a Number, which is 1 when a file with the
		name <code class="special">{file}</code> exists, and can be written.  If <code class="special">{file}</code> doesn't
		exist, or is not writable, the result is 0.  If <code class="special">{file}</code> is a
		directory, and we can write to it, the result is 2.


filter(<code class="special">{expr}</code>, <code class="special">{string}</code>)					<b class="vimtag">*<a name="filter()">filter()</a>*</b>
		<code class="special">{expr}</code> must be a |<a href="eval.html#List">List</a>| or a |<a href="eval.html#Dictionary">Dictionary</a>|.
		For each item in <code class="special">{expr}</code> evaluate <code class="special">{string}</code> and when the result
		is zero remove the item from the |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>|.
		Inside <code class="special">{string}</code> |<a href="eval.html#v:val">v:val</a>| has the value of the current item.
		For a |<a href="eval.html#Dictionary">Dictionary</a>| |<a href="eval.html#v:key">v:key</a>| has the key of the current item.
		Examples:
<code class="example">			:call filter(mylist, 'v:val !~ "OLD"')</code>
&lt;		Removes the items where "OLD" appears.
<code class="example">			:call filter(mydict, 'v:key &gt;= 8')</code>
&lt;		Removes the items with a key below 8.
<code class="example">			:call filter(var, 0)</code>
		Removes all the items, thus clears the |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>|.

		<code class="note">Note</code> that <code class="special">{string}</code> is the result of expression and is then
		used as an expression again.  Often it is good to use a
		|<a href="eval.html#literal-string">literal-string</a>| to avoid having to double backslashes.

		The operation is done in-place.  If you want a |<a href="eval.html#List">List</a>| or
		|<a href="eval.html#Dictionary">Dictionary</a>| to remain unmodified make a copy first:
<code class="example">			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')</code>
<code class="example"></code>
		Returns <code class="special">{expr}</code>, the |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| that was filtered.
		When an error is encountered while evaluating <code class="special">{string}</code> no
		further items in <code class="special">{expr}</code> are processed.


finddir(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])				<b class="vimtag">*<a name="finddir()">finddir()</a>*</b>
		Find directory <code class="special">{name}</code> in <code class="special">{path}</code>.  Supports both downwards and
		upwards recursive directory searches.  See |<a href="editing.html#file-searching">file-searching</a>|
		for the syntax of <code class="special">{path}</code>.
		Returns the path of the first found match.  When the found
		directory is below the current directory a relative path is
		returned.  Otherwise a full path is returned.
		If <code class="special">{path}</code> is omitted or empty then 'path' is used.
		If the optional <code class="special">{count}</code> is given, find <code class="special">{count}</code>'s occurrence of
		<code class="special">{name}</code> in <code class="special">{path}</code> instead of the first one.
		When <code class="special">{count}</code> is negative return all the matches in a |<a href="eval.html#List">List</a>|.
		This is quite similar to the ex-command |<a href="editing.html#:find">:find</a>|.
		{only available when compiled with the |<a href="various.html#+file_in_path">+file_in_path</a>|
		feature}

findfile(<code class="special">{name}</code>[, <code class="special">{path}</code>[, <code class="special">{count}</code>]])				<b class="vimtag">*<a name="findfile()">findfile()</a>*</b>
		Just like |<a href="eval.html#finddir()">finddir()</a>|, but find a file instead of a directory.
		Uses 'suffixesadd'.
		Example:
<code class="example">			:echo findfile("tags.vim", ".;")</code>
		Searches from the directory of the current file upwards until
		it finds the file "tags.vim".

float2nr(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="float2nr()">float2nr()</a>*</b>
		Convert <code class="special">{expr}</code> to a Number by omitting the part after the
		decimal point.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a Number.
		When the value of <code class="special">{expr}</code> is out of range for a |<a href="eval.html#Number">Number</a>| the
		result is truncated to 0x7fffffff or -0x7fffffff.  NaN results
		in -0x80000000.
		Examples:
<code class="example">			echo float2nr(3.95)</code>
&lt;			3
<code class="example">			echo float2nr(-23.45)</code>
&lt;			-23
<code class="example">			echo float2nr(1.0e100)</code>
&lt;			2147483647
<code class="example">			echo float2nr(-1.0e150)</code>
&lt;			-2147483647
<code class="example">			echo float2nr(1.0e-100)</code>
			0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


floor(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="floor()">floor()</a>*</b>
		Return the largest integral value less than or equal to
		<code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| (round down).
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			echo floor(1.856)</code>
&lt;			1.0
<code class="example">			echo floor(-5.456)</code>
&lt;			-6.0
<code class="example">			echo floor(4.0)</code>
			4.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


fmod(<code class="special">{expr1}</code>, <code class="special">{expr2}</code>)					<b class="vimtag">*<a name="fmod()">fmod()</a>*</b>
		Return the remainder of <code class="special">{expr1}</code> / <code class="special">{expr2}</code>, even if the
		division is not representable.  Returns <code class="special">{expr1}</code> - i * <code class="special">{expr2}</code>
		for some integer i such that if <code class="special">{expr2}</code> is non-zero, the
		result has the same sign as <code class="special">{expr1}</code> and magnitude less than
		the magnitude of <code class="special">{expr2}</code>.  If <code class="special">{expr2}</code> is zero, the value
		returned is zero.  The value returned is a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr1}</code> and <code class="special">{expr2}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo fmod(12.33, 1.22)</code>
&lt;			0.13
<code class="example">			:echo fmod(-12.33, 1.22)</code>
			-0.13
		{only available when compiled with |<a href="various.html#+float">+float</a>| feature}


fnameescape(<code class="special">{string}</code>)					<b class="vimtag">*<a name="fnameescape()">fnameescape()</a>*</b>
		Escape <code class="special">{string}</code> for use as file name command argument.	All
		characters that have a special meaning, such as '%' and '|'
		are escaped with a backslash.
		For most systems the characters escaped are
		" \t\n*?[{`$\\%#'\"|!&lt;".  For systems where a backslash
		appears in a filename, it depends on the value of 'isfname'.
		A leading '+' and '&gt;' is also escaped (special after |<a href="editing.html#:edit">:edit</a>|
		and |<a href="editing.html#:write">:write</a>|).  And a "-" by itself (special after |<a href="editing.html#:cd">:cd</a>|).
		Example:
<code class="example">			:let fname = '+some str%nge|name'</code>
<code class="example">			:exe "edit " . fnameescape(fname)</code>
&lt;		results in executing:
<code class="example">			edit \+some\ str\%nge\|name</code>
<code class="example"></code>
fnamemodify(<code class="special">{fname}</code>, <code class="special">{mods}</code>)				<b class="vimtag">*<a name="fnamemodify()">fnamemodify()</a>*</b>
		Modify file name <code class="special">{fname}</code> according to <code class="special">{mods}</code>.  <code class="special">{mods}</code> is a
		string of characters like it is used for file names on the
		command line.  See |<a href="cmdline.html#filename-modifiers">filename-modifiers</a>|.
		Example:
<code class="example">			:echo fnamemodify("main.c", ":p:h")</code>
&lt;		results in:
<code class="example">			/home/mool/vim/vim/src</code>
		<code class="note">Note:</code> Environment variables don't work in <code class="special">{fname}</code>, use
		|<a href="eval.html#expand()">expand()</a>| first then.

foldclosed(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="foldclosed()">foldclosed()</a>*</b>
		The result is a Number.  If the line <code class="special">{lnum}</code> is in a closed
		fold, the result is the number of the first line in that fold.
		If the line <code class="special">{lnum}</code> is not in a closed fold, -1 is returned.

foldclosedend(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="foldclosedend()">foldclosedend()</a>*</b>
		The result is a Number.  If the line <code class="special">{lnum}</code> is in a closed
		fold, the result is the number of the last line in that fold.
		If the line <code class="special">{lnum}</code> is not in a closed fold, -1 is returned.

foldlevel(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="foldlevel()">foldlevel()</a>*</b>
		The result is a Number, which is the foldlevel of line <code class="special">{lnum}</code>
		in the current buffer.	For nested folds the deepest level is
		returned.  If there is no fold at line <code class="special">{lnum}</code>, zero is
		returned.  It doesn't matter if the folds are open or closed.
		When used while updating folds (from 'foldexpr') -1 is
		returned for lines where folds are still to be updated and the
		foldlevel is unknown.  As a special case the level of the
		previous line is usually available.

							<b class="vimtag">*<a name="foldtext()">foldtext()</a>*</b>
foldtext()	Returns a String, to be displayed for a closed fold.  This is
		the default function used for the 'foldtext' option and should
		only be called from evaluating 'foldtext'.  It uses the
		|<a href="eval.html#v:foldstart">v:foldstart</a>|, |<a href="eval.html#v:foldend">v:foldend</a>| and |<a href="eval.html#v:folddashes">v:folddashes</a>| variables.
		The returned string looks like this:
<code class="example">			+-- 45 lines: abcdef</code>
		The number of dashes depends on the foldlevel.	The "45" is
		the number of lines in the fold.  "abcdef" is the text in the
		first non-blank line of the fold.  Leading white space, "//"
		or "/*" and the text from the 'foldmarker' and 'commentstring'
		options is removed.
		{not available when compiled without the |<a href="various.html#+folding">+folding</a>| feature}

foldtextresult(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="foldtextresult()">foldtextresult()</a>*</b>
		Returns the text that is displayed for the closed fold at line
		<code class="special">{lnum}</code>.  Evaluates 'foldtext' in the appropriate context.
		When there is no closed fold at <code class="special">{lnum}</code> an empty string is
		returned.
		<code class="special">{lnum}</code> is used like with |<a href="eval.html#getline()">getline()</a>|.  Thus "." is the current
		line, "'m" mark m, etc.
		Useful when exporting folded text, e.g., to HTML.
		{not available when compiled without the |<a href="various.html#+folding">+folding</a>| feature}

							<b class="vimtag">*<a name="foreground()">foreground()</a>*</b>
foreground()	Move the Vim window to the foreground.	Useful when sent from
		a client to a Vim server. |<a href="eval.html#remote_send()">remote_send()</a>|
		On Win32 systems this might not work, the OS does not always
		allow a window to bring itself to the foreground.  Use
		|<a href="eval.html#remote_foreground()">remote_foreground()</a>| instead.
		{only in the Win32, Athena, Motif and GTK GUI versions and the
		Win32 console version}


					<b class="vimtag">*<a name="function()">function()</a>*</b> <b class="vimtag">*<a name="E700">E700</a>*</b> <b class="vimtag">*<a name="E922">E922</a>*</b> <b class="vimtag">*<a name="E923">E923</a>*</b>
function(<code class="special">{name}</code> [, <code class="special">{arglist}</code>] [, <code class="special">{dict}</code>])
		Return a |<a href="eval.html#Funcref">Funcref</a>| variable that refers to function <code class="special">{name}</code>.
		<code class="special">{name}</code> can be the name of a user defined function or an
		internal function.

		<code class="special">{name}</code> can also be a Funcref, also a partial.  When it is a
		partial the dict stored in it will be used and the <code class="special">{dict}</code>
		argument is not allowed. E.g.:
<code class="example">			let FuncWithArg = function(dict.Func, [arg])</code>
<code class="example">			let Broken = function(dict.Func, [arg], dict)</code>

		When <code class="special">{arglist}</code> or <code class="special">{dict}</code> is present this creates a partial.
		That mans the argument list and/or the dictionary is stored in
		the Funcref and will be used when the Funcref is called.

		The arguments are passed to the function in front of other
		arguments.  Example:
<code class="example">			func Callback(arg1, arg2, name)</code>
<code class="example">			...</code>
<code class="example">			let Func = function('Callback', ['one', 'two'])</code>
<code class="example">			...</code>
<code class="example">			call Func('name')</code>
&lt;		Invokes the function as with:
<code class="example">			call Callback('one', 'two', 'name')</code>
<code class="example"></code>
		The function() call can be nested to add more arguments to the
		Funcref.  The extra arguments are appended to the list of
		arguments.  Example:
<code class="example">			func Callback(arg1, arg2, name)</code>
<code class="example">			...</code>
<code class="example">			let Func = function('Callback', ['one'])</code>
<code class="example">			let Func2 = function(Func, ['two'])</code>
<code class="example">			...</code>
<code class="example">			call Func2('name')</code>
&lt;		Invokes the function as with:
<code class="example">			call Callback('one', 'two', 'name')</code>
<code class="example"></code>
		The Dictionary is only useful when calling a "dict" function.
		In that case the <code class="special">{dict}</code> is passed in as "self". Example:
<code class="example">			function Callback() dict</code>
<code class="example">			   echo "called for " . self.name</code>
<code class="example">			endfunction</code>
<code class="example">			...</code>
<code class="example">			let context = <code class="special">{"name": "example"}</code></code>
<code class="example">			let Func = function('Callback', context)</code>
<code class="example">			...</code>
<code class="example">			call Func()	" will echo: called for example</code>
		The use of function() is not needed when there are no extra
		arguments, these two are equivalent:
<code class="example">			let Func = function('Callback', context)</code>
<code class="example">			let Func = context.Callback</code>
<code class="example"></code>
&lt;		The argument list and the Dictionary can be combined:
<code class="example">			function Callback(arg1, count) dict</code>
<code class="example">			...</code>
<code class="example">			let context = <code class="special">{"name": "example"}</code></code>
<code class="example">			let Func = function('Callback', ['one'], context)</code>
<code class="example">			...</code>
<code class="example">			call Func(500)</code>
&lt;		Invokes the function as with:
<code class="example">			call context.Callback('one', 500)</code>
<code class="example"></code>
<code class="example"></code>
garbagecollect([<code class="special">{atexit}</code>])				<b class="vimtag">*<a name="garbagecollect()">garbagecollect()</a>*</b>
		Cleanup unused |<a href="eval.html#Lists">Lists</a>|, |<a href="eval.html#Dictionaries">Dictionaries</a>|, |<a href="eval.html#Channels">Channels</a>| and |<a href="eval.html#Jobs">Jobs</a>|
		that have circular references.

		There is hardly ever a need to invoke this function, as it is
		automatically done when Vim runs out of memory or is waiting
		for the user to press a key after 'updatetime'.  Items without
		circular references are always freed when they become unused.
		This is useful if you have deleted a very big |<a href="eval.html#List">List</a>| and/or
		|<a href="eval.html#Dictionary">Dictionary</a>| with circular references in a script that runs
		for a long time.

		When the optional <code class="special">{atexit}</code> argument is one, garbage
		collection will also be done when exiting Vim, if it wasn't
		done before.  This is useful when checking for memory leaks.

garbagecollect_for_testing()			 <b class="vimtag">*<a name="garbagecollect_for_testing()">garbagecollect_for_testing()</a>*</b>
		Like garbagecollect(), but executed right away.  This must
		only be called directly to avoid any structure to exist
		internally, and |<a href="eval.html#v:testing">v:testing</a>| must have been set before calling
		any function.

get(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{default}</code>])			<b class="vimtag">*<a name="get()">get()</a>*</b>
		Get item <code class="special">{idx}</code> from |<a href="eval.html#List">List</a>| <code class="special">{list}</code>.  When this item is not
		available return <code class="special">{default}</code>.  Return zero when <code class="special">{default}</code> is
		omitted.
get(<code class="special">{dict}</code>, <code class="special">{key}</code> [, <code class="special">{default}</code>])
		Get item with key <code class="special">{key}</code> from |<a href="eval.html#Dictionary">Dictionary</a>| <code class="special">{dict}</code>.  When this
		item is not available return <code class="special">{default}</code>.  Return zero when
		<code class="special">{default}</code> is omitted.

							<b class="vimtag">*<a name="getbufline()">getbufline()</a>*</b>
getbufline(<code class="special">{expr}</code>, <code class="special">{lnum}</code> [, <code class="special">{end}</code>])
		Return a |<a href="eval.html#List">List</a>| with the lines starting from <code class="special">{lnum}</code> to <code class="special">{end}</code>
		(inclusive) in the buffer <code class="special">{expr}</code>.  If <code class="special">{end}</code> is omitted, a
		|<a href="eval.html#List">List</a>| with only the line <code class="special">{lnum}</code> is returned.

		For the use of <code class="special">{expr}</code>, see |<a href="eval.html#bufname()">bufname()</a>| above.

		For <code class="special">{lnum}</code> and <code class="special">{end}</code> "$" can be used for the last line of the
		buffer.  Otherwise a number must be used.

		When <code class="special">{lnum}</code> is smaller than 1 or bigger than the number of
		lines in the buffer, an empty |<a href="eval.html#List">List</a>| is returned.

		When <code class="special">{end}</code> is greater than the number of lines in the buffer,
		it is treated as <code class="special">{end}</code> is set to the number of lines in the
		buffer.  When <code class="special">{end}</code> is before <code class="special">{lnum}</code> an empty |<a href="eval.html#List">List</a>| is
		returned.

		This function works only for loaded buffers.  For unloaded and
		non-existing buffers, an empty |<a href="eval.html#List">List</a>| is returned.

		Example:
<code class="example">			:let lines = getbufline(bufnr("myfile"), 1, "$")</code>
<code class="example"></code>
getbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])				<b class="vimtag">*<a name="getbufvar()">getbufvar()</a>*</b>
		The result is the value of option or local buffer variable
		<code class="special">{varname}</code> in buffer <code class="special">{expr}</code>.  <code class="note">Note</code> that the name without "b:"
		must be used.
		When <code class="special">{varname}</code> is empty returns a dictionary with all the
		buffer-local variables.
		This also works for a global or buffer-local option, but it
		doesn't work for a global variable, window-local variable or
		window-local option.
		For the use of <code class="special">{expr}</code>, see |<a href="eval.html#bufname()">bufname()</a>| above.
		When the buffer or variable doesn't exist <code class="special">{def}</code> or an empty
		string is returned, there is no error message.
		Examples:
<code class="example">			:let bufmodified = getbufvar(1, "&amp;mod")</code>
<code class="example">			:echo "todo myvar = " . getbufvar("todo", "myvar")</code>

getchar([expr])						<b class="vimtag">*<a name="getchar()">getchar()</a>*</b>
		Get a single character from the user or input stream.
		If [expr] is omitted, wait until a character is available.
		If [expr] is 0, only get a character when one is available.
			Return zero otherwise.
		If [expr] is 1, only check if a character is available, it is
			not consumed.  Return zero if no character available.

		Without [expr] and when [expr] is 0 a whole character or
		special key is returned.  If it is an 8-bit character, the
		result is a number.  Use nr2char() to convert it to a String.
		Otherwise a String is returned with the encoded character.
		For a special key it's a sequence of bytes starting with 0x80
		(decimal: 128).  This is the same value as the string
		"\<code class="special">&lt;Key&gt;</code>", e.g., "\<code class="special">&lt;Left&gt;</code>".  The returned value is also a
		String when a modifier (shift, control, alt) was used that is
		not included in the character.

		When [expr] is 0 and Esc is typed, there will be a short delay
		while Vim waits to see if this is the start of an escape
		sequence.

		When [expr] is 1 only the first byte is returned.  For a
		one-byte character it is the character itself as a number.
		Use nr2char() to convert it to a String.

		Use getcharmod() to obtain any additional modifiers.

		When the user clicks a mouse button, the mouse event will be
		returned.  The position can then be found in |<a href="eval.html#v:mouse_col">v:mouse_col</a>|,
		|<a href="eval.html#v:mouse_lnum">v:mouse_lnum</a>| and |<a href="eval.html#v:mouse_win">v:mouse_win</a>|.  This example positions the
		mouse as it would normally happen:
<code class="example">			let c = getchar()</code>
<code class="example">			if c == "\<code class="special">&lt;LeftMouse&gt;</code>" &amp;&amp; v:mouse_win &gt; 0</code>
<code class="example">			  exe v:mouse_win . "wincmd w"</code>
<code class="example">			  exe v:mouse_lnum</code>
<code class="example">			  exe "normal " . v:mouse_col . "|"</code>
<code class="example">			endif</code>

		There is no prompt, you will somehow have to make clear to the
		user that a character has to be typed.
		There is no mapping for the character.
		Key codes are replaced, thus when the user presses the <code class="special">&lt;Del&gt;</code>
		key you get the code for the <code class="special">&lt;Del&gt;</code> key, not the raw character
		sequence.  Examples:
<code class="example">			getchar() == "\<code class="special">&lt;Del&gt;</code>"</code>
<code class="example">			getchar() == "\<code class="special">&lt;S-Left&gt;</code>"</code>
&lt;		This example redefines "f" to ignore case:
<code class="example">			:nmap f :call FindChar()<code class="special">&lt;CR&gt;</code></code>
<code class="example">			:function FindChar()</code>
<code class="example">			:  let c = nr2char(getchar())</code>
<code class="example">			:  while col('.') &lt; col('$') - 1</code>
<code class="example">			:    normal l</code>
<code class="example">			:    if getline('.')[col('.') - 1] ==? c</code>
<code class="example">			:      break</code>
<code class="example">			:    endif</code>
<code class="example">			:  endwhile</code>
<code class="example">			:endfunction</code>

		You may also receive synthetic characters, such as
		|<a href="autocmd.html#%3CCursorHold%3E">&lt;CursorHold&gt;</a>|. Often you will want to ignore this and get
		another character:
<code class="example">			:function GetKey()</code>
<code class="example">			:  let c = getchar()</code>
<code class="example">			:  while c == "\<code class="special">&lt;CursorHold&gt;</code>"</code>
<code class="example">			:    let c = getchar()</code>
<code class="example">			:  endwhile</code>
<code class="example">			:  return c</code>
<code class="example">			:endfunction</code>
<code class="example"></code>
getcharmod()						<b class="vimtag">*<a name="getcharmod()">getcharmod()</a>*</b>
		The result is a Number which is the state of the modifiers for
		the last obtained character with getchar() or in another way.
		These values are added together:
			2	shift
			4	control
			8	alt (meta)
			16	meta (when it's different from ALT)
			32	mouse double click
			64	mouse triple click
			96	mouse quadruple click (== 32 + 64)
			128	command (Macintosh only)
		Only the modifiers that have not been included in the
		character itself are obtained.	Thus Shift-a results in "A"
		without a modifier.

getcharsearch()						<b class="vimtag">*<a name="getcharsearch()">getcharsearch()</a>*</b>
		Return the current character search information as a <code class="special">{dict}</code>
		with the following entries:

		    char	character previously used for a character
				search (|<a href="motion.html#t">t</a>|, |<a href="motion.html#f">f</a>|, |<a href="motion.html#T">T</a>|, or |<a href="motion.html#F">F</a>|); empty string
				if no character search has been performed
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |<a href="motion.html#t">t</a>| or |<a href="motion.html#T">T</a>|
				character search, 0 for an |<a href="motion.html#f">f</a>| or |<a href="motion.html#F">F</a>|
				character search

		This can be useful to always have |<a href="motion.html#;">;</a>| and |<a href="motion.html#,">,</a>| search
		forward/backward regardless of the direction of the previous
		character search:
<code class="example">			:nnoremap <code class="special">&lt;expr&gt;</code> ; getcharsearch().forward ? ';' : ','</code>
<code class="example">			:nnoremap <code class="special">&lt;expr&gt;</code> , getcharsearch().forward ? ',' : ';'</code>
		Also see |<a href="eval.html#setcharsearch()">setcharsearch()</a>|.

getcmdline()						<b class="vimtag">*<a name="getcmdline()">getcmdline()</a>*</b>
		Return the current command-line.  Only works when the command
		line is being edited, thus requires use of |<a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>| or
		|<a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>|.
		Example:
<code class="example">			:cmap <code class="special">&lt;F7&gt;</code> <code class="special">&lt;C-\&gt;</code>eescape(getcmdline(), ' \')<code class="special">&lt;CR&gt;</code></code>
		Also see |<a href="eval.html#getcmdtype()">getcmdtype()</a>|, |<a href="eval.html#getcmdpos()">getcmdpos()</a>| and |<a href="eval.html#setcmdpos()">setcmdpos()</a>|.

getcmdpos()						<b class="vimtag">*<a name="getcmdpos()">getcmdpos()</a>*</b>
		Return the position of the cursor in the command line as a
		byte count.  The first column is 1.
		Only works when editing the command line, thus requires use of
		|<a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>| or |<a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>| or an expression mapping.
		Returns 0 otherwise.
		Also see |<a href="eval.html#getcmdtype()">getcmdtype()</a>|, |<a href="eval.html#setcmdpos()">setcmdpos()</a>| and |<a href="eval.html#getcmdline()">getcmdline()</a>|.

getcmdtype()						<b class="vimtag">*<a name="getcmdtype()">getcmdtype()</a>*</b>
		Return the current command-line type. Possible return values
		are:
		    :	normal Ex command
		    &gt;	debug mode command |<a href="repeat.html#debug-mode">debug-mode</a>|
		    /	forward search command
		    ?	backward search command
		    @	|<a href="eval.html#input()">input()</a>| command
		    -	|<a href="insert.html#:insert">:insert</a>| or |<a href="insert.html#:append">:append</a>| command
		    =	|<a href="insert.html#i_CTRL-R_%20">i_CTRL-R_=</a>|
		Only works when editing the command line, thus requires use of
		|<a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>| or |<a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>| or an expression mapping.
		Returns an empty string otherwise.
		Also see |<a href="eval.html#getcmdpos()">getcmdpos()</a>|, |<a href="eval.html#setcmdpos()">setcmdpos()</a>| and |<a href="eval.html#getcmdline()">getcmdline()</a>|.

getcmdwintype()						<b class="vimtag">*<a name="getcmdwintype()">getcmdwintype()</a>*</b>
		Return the current |<a href="cmdline.html#command-line-window">command-line-window</a>| type. Possible return
		values are the same as |<a href="eval.html#getcmdtype()">getcmdtype()</a>|. Returns an empty string
		when not in the command-line window.

							<b class="vimtag">*<a name="getcurpos()">getcurpos()</a>*</b>
getcurpos()	Get the position of the cursor.  This is like getpos('.'), but
		includes an extra item in the list:
<code class="section">		    [bufnum, lnum, col, off, curswant] </code>
		The "curswant" number is the preferred column when moving the
		cursor vertically.
		This can be used to save and restore the cursor position:
<code class="example">			let save_cursor = getcurpos()</code>
<code class="example">			MoveTheCursorAround</code>
<code class="example">			call setpos('.', save_cursor)</code>

							<b class="vimtag">*<a name="getcwd()">getcwd()</a>*</b>
getcwd([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])
		The result is a String, which is the name of the current
		working directory.
		Without arguments, for the current window.

		With <code class="special">{winnr}</code> return the local current directory of this window
		in the current tab page.
		With <code class="special">{winnr}</code> and <code class="special">{tabnr}</code> return the local current directory of
		the window in the specified tab page.
		Return an empty string if the arguments are invalid.

getfsize(<code class="special">{fname}</code>)					<b class="vimtag">*<a name="getfsize()">getfsize()</a>*</b>
		The result is a Number, which is the size in bytes of the
		given file <code class="special">{fname}</code>.
		If <code class="special">{fname}</code> is a directory, 0 is returned.
		If the file <code class="special">{fname}</code> can't be found, -1 is returned.
		If the size of <code class="special">{fname}</code> is too big to fit in a Number then -2
		is returned.

getfontname([<code class="special">{name}</code>])					<b class="vimtag">*<a name="getfontname()">getfontname()</a>*</b>
		Without an argument returns the name of the normal font being
		used.  Like what is used for the Normal highlight group
		|<a href="syntax.html#hl-Normal">hl-Normal</a>|.
		With an argument a check is done whether <code class="special">{name}</code> is a valid
		font name.  If not then an empty string is returned.
		Otherwise the actual font name is returned, or <code class="special">{name}</code> if the
		GUI does not support obtaining the real name.
		Only works when the GUI is running, thus not in your vimrc or
		gvimrc file.  Use the |<a href="autocmd.html#GUIEnter">GUIEnter</a>| autocommand to use this
		function just after the GUI has started.
		<code class="note">Note</code> that the GTK 2 GUI accepts any font name, thus checking
		for a valid name does not work.

getfperm(<code class="special">{fname}</code>)					<b class="vimtag">*<a name="getfperm()">getfperm()</a>*</b>
		The result is a String, which is the read, write, and execute
		permissions of the given file <code class="special">{fname}</code>.
		If <code class="special">{fname}</code> does not exist or its directory cannot be read, an
		empty string is returned.
		The result is of the form "rwxrwxrwx", where each group of
		"rwx" flags represent, in turn, the permissions of the owner
		of the file, the group the file belongs to, and other users.
		If a user does not have a given permission the flag for this
		is replaced with the string "-".  Examples:
<code class="example">			:echo getfperm("/etc/passwd")</code>
<code class="example">			:echo getfperm(expand("~/.vimrc"))</code>
		This will hopefully (from a security point of view) display
		the string "rw-r--r--" or even "rw-------".

		For setting permissins use |<a href="eval.html#setfperm()">setfperm()</a>|.

getftime(<code class="special">{fname}</code>)					<b class="vimtag">*<a name="getftime()">getftime()</a>*</b>
		The result is a Number, which is the last modification time of
		the given file <code class="special">{fname}</code>.  The value is measured as seconds
		since 1st Jan 1970, and may be passed to strftime().  See also
		|<a href="eval.html#localtime()">localtime()</a>| and |<a href="eval.html#strftime()">strftime()</a>|.
		If the file <code class="special">{fname}</code> can't be found -1 is returned.

getftype(<code class="special">{fname}</code>)					<b class="vimtag">*<a name="getftype()">getftype()</a>*</b>
		The result is a String, which is a description of the kind of
		file of the given file <code class="special">{fname}</code>.
		If <code class="special">{fname}</code> does not exist an empty string is returned.
		Here is a table over different kinds of files and their
		results:
			Normal file		"file"
			Directory		"dir"
			Symbolic link		"link"
			Block device		"bdev"
			Character device	"cdev"
			Socket			"socket"
			FIFO			"fifo"
			All other		"other"
		Example:
<code class="example">			getftype("/home")</code>
		<code class="note">Note</code> that a type such as "link" will only be returned on
		systems that support it.  On some systems only "dir" and
		"file" are returned.  On MS-Windows a symbolic link to a
		directory returns "dir" instead of "link".

							<b class="vimtag">*<a name="getline()">getline()</a>*</b>
getline(<code class="special">{lnum}</code> [, <code class="special">{end}</code>])
		Without <code class="special">{end}</code> the result is a String, which is line <code class="special">{lnum}</code>
		from the current buffer.  Example:
<code class="example">			getline(1)</code>
		When <code class="special">{lnum}</code> is a String that doesn't start with a
		digit, line() is called to translate the String into a Number.
		To get the line under the cursor:
<code class="example">			getline(".")</code>
		When <code class="special">{lnum}</code> is smaller than 1 or bigger than the number of
		lines in the buffer, an empty string is returned.

		When <code class="special">{end}</code> is given the result is a |<a href="eval.html#List">List</a>| where each item is
		a line from the current buffer in the range <code class="special">{lnum}</code> to <code class="special">{end}</code>,
		including line <code class="special">{end}</code>.
		<code class="special">{end}</code> is used in the same way as <code class="special">{lnum}</code>.
		Non-existing lines are silently omitted.
		When <code class="special">{end}</code> is before <code class="special">{lnum}</code> an empty |<a href="eval.html#List">List</a>| is returned.
		Example:
<code class="example">			:let start = line('.')</code>
<code class="example">			:let end = search("^$") - 1</code>
<code class="example">			:let lines = getline(start, end)</code>
<code class="example"></code>
		To get lines from another buffer see |<a href="eval.html#getbufline()">getbufline()</a>|

getloclist(<code class="special">{nr}</code>)					<b class="vimtag">*<a name="getloclist()">getloclist()</a>*</b>
		Returns a list with all the entries in the location list for
		window <code class="special">{nr}</code>. When <code class="special">{nr}</code> is zero the current window is used.
		For a location list window, the displayed location list is
		returned.  For an invalid window number <code class="special">{nr}</code>, an empty list is
		returned. Otherwise, same as |<a href="eval.html#getqflist()">getqflist()</a>|.

getmatches()						<b class="vimtag">*<a name="getmatches()">getmatches()</a>*</b>
		Returns a |<a href="eval.html#List">List</a>| with all matches previously defined by
		|<a href="eval.html#matchadd()">matchadd()</a>| and the |<a href="pattern.html#:match">:match</a>| commands.  |<a href="eval.html#getmatches()">getmatches()</a>| is
		useful in combination with |<a href="eval.html#setmatches()">setmatches()</a>|, as |<a href="eval.html#setmatches()">setmatches()</a>|
		can restore a list of matches saved by |<a href="eval.html#getmatches()">getmatches()</a>|.
		Example:
<code class="example">			:echo getmatches()</code>
			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}]
<code class="example">			:let m = getmatches()</code>
<code class="example">			:call clearmatches()</code>
<code class="example">			:echo getmatches()</code>
&lt;			[]
<code class="example">			:call setmatches(m)</code>
<code class="example">			:echo getmatches()</code>
			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}]
<code class="example">			:unlet m</code>

							<b class="vimtag">*<a name="getpid()">getpid()</a>*</b>
getpid()	Return a Number which is the process ID of the Vim process.
		On Unix and MS-Windows this is a unique number, until Vim
		exits.	On MS-DOS it's always zero.

							<b class="vimtag">*<a name="getpos()">getpos()</a>*</b>
getpos(<code class="special">{expr}</code>)	Get the position for <code class="special">{expr}</code>.  For possible values of <code class="special">{expr}</code>
		see |<a href="eval.html#line()">line()</a>|.  For getting the cursor position see
		|<a href="eval.html#getcurpos()">getcurpos()</a>|.
		The result is a |<a href="eval.html#List">List</a>| with four numbers:
		    [bufnum, lnum, col, off]
		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
		is the buffer number of the mark.
		"lnum" and "col" are the position in the buffer.  The first
		column is 1.
		The "off" number is zero, unless 'virtualedit' is used.  Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <code class="special">&lt;Tab&gt;</code> or after the last
		character.
		<code class="note">Note</code> that for '<code class="special">&lt; and '&gt;</code> Visual mode matters: when it is "V"
		(visual line mode) the column of '&lt; is zero and the column of
		'&gt; is a large number.
		This can be used to save and restore the position of a mark:
<code class="example">			let save_a_mark = getpos("'a")</code>
<code class="example">			...</code>
<code class="example">			call setpos("'a", save_a_mark)</code>
		Also see |<a href="eval.html#getcurpos()">getcurpos()</a>| and |<a href="eval.html#setpos()">setpos()</a>|.


getqflist()						<b class="vimtag">*<a name="getqflist()">getqflist()</a>*</b>
		Returns a list with all the current quickfix errors.  Each
		list item is a dictionary with these entries:
			bufnr	number of buffer that has the file name, use
				bufname() to get the name
			lnum	line number in the buffer (first line is 1)
			col	column number (first column is 1)
			vcol	non-zero: "col" is visual column
				zero: "col" is byte index
			nr	error number
			pattern	search pattern used to locate the error
			text	description of the error
			type	type of the error, 'E', '1', etc.
			valid	non-zero: recognized error message

		When there is no error list or it's empty an empty list is
		returned. Quickfix list entries with non-existing buffer
		number are returned with "bufnr" set to zero.

		Useful application: Find pattern matches in multiple files and
		do something with them:
<code class="example">			:vimgrep /theword/jg *.c</code>
<code class="example">			:for d in getqflist()</code>
<code class="example">			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text</code>
<code class="example">			:endfor</code>
<code class="example"></code>
<code class="example"></code>
getreg([<code class="special">{regname}</code> [, 1 [, <code class="special">{list}</code>]]])			<b class="vimtag">*<a name="getreg()">getreg()</a>*</b>
		The result is a String, which is the contents of register
		<code class="special">{regname}</code>.  Example:
<code class="example">			:let cliptext = getreg('*')</code>
		When <code class="special">{regname}</code> was not set the result is a empty string.

		getreg('=') returns the last evaluated value of the expression
		register.  (For use in maps.)
		getreg('=', 1) returns the expression itself, so that it can
		be restored with |<a href="eval.html#setreg()">setreg()</a>|.  For other registers the extra
		argument is ignored, thus you can always give it.

		If <code class="special">{list}</code> is present and non-zero, the result type is changed
		to |<a href="eval.html#List">List</a>|. Each list item is one text line. Use it if you care
		about zero bytes possibly present inside register: without
		third argument both NLs and zero bytes are represented as NLs
		(see |<a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a>|).
		When the register was not set an empty list is returned.

		If <code class="special">{regname}</code> is not specified, |<a href="eval.html#v:register">v:register</a>| is used.


getregtype([<code class="special">{regname}</code>])					<b class="vimtag">*<a name="getregtype()">getregtype()</a>*</b>
		The result is a String, which is type of register <code class="special">{regname}</code>.
		The value will be one of:
		    "v"			for |<a href="motion.html#characterwise">characterwise</a>| text
		    "V"			for |<a href="motion.html#linewise">linewise</a>| text
		    "<code class="special">&lt;<code class="keystroke">CTRL-V</code>&gt;</code><code class="special">{width}</code>"	for |<a href="visual.html#blockwise-visual">blockwise-visual</a>| text
		    ""			for an empty or unknown register
		<code class="special">&lt;<code class="keystroke">CTRL-V</code>&gt;</code> is one character with value 0x16.
		If <code class="special">{regname}</code> is not specified, |<a href="eval.html#v:register">v:register</a>| is used.

gettabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])				<b class="vimtag">*<a name="gettabvar()">gettabvar()</a>*</b>
		Get the value of a tab-local variable <code class="special">{varname}</code> in tab page
		<code class="special">{tabnr}</code>. |<a href="eval.html#t:var">t:var</a>|
		Tabs are numbered starting with one.
		When <code class="special">{varname}</code> is empty a dictionary with all tab-local
		variables is returned.
		<code class="note">Note</code> that the name without "t:" must be used.
		When the tab or variable doesn't exist <code class="special">{def}</code> or an empty
		string is returned, there is no error message.

gettabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])		<b class="vimtag">*<a name="gettabwinvar()">gettabwinvar()</a>*</b>
		Get the value of window-local variable <code class="special">{varname}</code> in window
		<code class="special">{winnr}</code> in tab page <code class="special">{tabnr}</code>.
		When <code class="special">{varname}</code> starts with "&amp;" get the value of a window-local
		option.
		When <code class="special">{varname}</code> is empty a dictionary with all window-local
		variables is returned.
		<code class="note">Note</code> that <code class="special">{varname}</code> must be the name without "w:".
		Tabs are numbered starting with one.  For the current tabpage
		use |<a href="eval.html#getwinvar()">getwinvar()</a>|.
		When <code class="special">{winnr}</code> is zero the current window is used.
		This also works for a global option, buffer-local option and
		window-local option, but it doesn't work for a global variable
		or buffer-local variable.
		When the tab, window or variable doesn't exist <code class="special">{def}</code> or an
		empty string is returned, there is no error message.
		Examples:
<code class="example">			:let list_is_on = gettabwinvar(1, 2, '&amp;list')</code>
<code class="example">			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')</code>

							<b class="vimtag">*<a name="getwinposx()">getwinposx()</a>*</b>
getwinposx()	The result is a Number, which is the X coordinate in pixels of
		the left hand side of the GUI Vim window.  The result will be
		-1 if the information is not available.

							<b class="vimtag">*<a name="getwinposy()">getwinposy()</a>*</b>
getwinposy()	The result is a Number, which is the Y coordinate in pixels of
		the top of the GUI Vim window.	The result will be -1 if the
		information is not available.

getwinvar(<code class="special">{winnr}</code>, <code class="special">{varname}</code> [, <code class="special">{def}</code>])				<b class="vimtag">*<a name="getwinvar()">getwinvar()</a>*</b>
		Like |<a href="eval.html#gettabwinvar()">gettabwinvar()</a>| for the current tabpage.
		Examples:
<code class="example">			:let list_is_on = getwinvar(2, '&amp;list')</code>
<code class="example">			:echo "myvar = " . getwinvar(1, 'myvar')</code>

glob(<code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])		<b class="vimtag">*<a name="glob()">glob()</a>*</b>
		Expand the file wildcards in <code class="special">{expr}</code>.  See |<a href="editing.html#wildcards">wildcards</a>| for the
		use of special characters.

		Unless the optional <code class="special">{nosuf}</code> argument is given and is non-zero,
		the 'suffixes' and 'wildignore' options apply: Names matching
		one of the patterns in 'wildignore' will be skipped and
		'suffixes' affect the ordering of matches.
		'wildignorecase' always applies.

		When <code class="special">{list}</code> is present and it is non-zero the result is a List
		with all matching files. The advantage of using a List is,
		you also get filenames containing newlines correctly.
		Otherwise the result is a String and when there are several
		matches, they are separated by <code class="special">&lt;NL&gt;</code> characters.

		If the expansion fails, the result is an empty String or List.

		A name for a non-existing file is not included.  A symbolic
		link is only included if it points to an existing file.
		However, when the <code class="special">{alllinks}</code> argument is present and it is
		non-zero then all symbolic links are included.

		For most systems backticks can be used to get files names from
		any external command.  Example:
<code class="example">			:let tagfiles = glob("`find . -name tags -print`")</code>
<code class="example">			:let &amp;tags = substitute(tagfiles, "\n", ",", "g")</code>
		The result of the program inside the backticks should be one
		item per line.	Spaces inside an item are allowed.

		See |<a href="eval.html#expand()">expand()</a>| for expanding special Vim variables.  See
		|<a href="eval.html#system()">system()</a>| for getting the raw output of an external command.

glob2regpat(<code class="special">{expr}</code>)					 <b class="vimtag">*<a name="glob2regpat()">glob2regpat()</a>*</b>
		Convert a file pattern, as used by glob(), into a search
		pattern.  The result can be used to match with a string that
		is a file name.  E.g.
<code class="example">			if filename =~ glob2regpat('Make*.mak')</code>
&lt;		This is equivalent to:
<code class="example">			if filename =~ '^Make.*\.mak$'</code>
		When <code class="special">{expr}</code> is an empty string the result is "^$", match an
		empty string.

								<b class="vimtag">*<a name="globpath()">globpath()</a>*</b>
globpath(<code class="special">{path}</code>, <code class="special">{expr}</code> [, <code class="special">{nosuf}</code> [, <code class="special">{list}</code> [, <code class="special">{alllinks}</code>]]])
		Perform glob() on all directories in <code class="special">{path}</code> and concatenate
		the results.  Example:
<code class="example">			:echo globpath(&amp;rtp, "syntax/c.vim")</code>

		<code class="special">{path}</code> is a comma-separated list of directory names.  Each
		directory name is prepended to <code class="special">{expr}</code> and expanded like with
		|<a href="eval.html#glob()">glob()</a>|.  A path separator is inserted when needed.
		To add a comma inside a directory name escape it with a
		backslash.  <code class="note">Note</code> that on MS-Windows a directory may have a
		trailing backslash, remove it if you put a comma after it.
		If the expansion fails for one of the directories, there is no
		error message.

		Unless the optional <code class="special">{nosuf}</code> argument is given and is non-zero,
		the 'suffixes' and 'wildignore' options apply: Names matching
		one of the patterns in 'wildignore' will be skipped and
		'suffixes' affect the ordering of matches.

		When <code class="special">{list}</code> is present and it is non-zero the result is a List
		with all matching files. The advantage of using a List is, you
		also get filenames containing newlines correctly. Otherwise
		the result is a String and when there are several matches,
		they are separated by <code class="special">&lt;NL&gt;</code> characters.  Example:
<code class="example">			:echo globpath(&amp;rtp, "syntax/c.vim", 0, 1)</code>

		<code class="special">{alllinks}</code> is used as with |<a href="eval.html#glob()">glob()</a>|.

		The "**" item can be used to search in a directory tree.
		For example, to find all "README.txt" files in the directories
		in 'runtimepath' and below:
<code class="example">			:echo globpath(&amp;rtp, "**/README.txt")</code>
		Upwards search and limiting the depth of "**" is not
		supported, thus using 'path' will not always work properly.

							<b class="vimtag">*<a name="has()">has()</a>*</b>
has(<code class="special">{feature}</code>)	The result is a Number, which is 1 if the feature <code class="special">{feature}</code> is
		supported, zero otherwise.  The <code class="special">{feature}</code> argument is a
		string.  See |<a href="eval.html#feature-list">feature-list</a>| below.
		Also see |<a href="eval.html#exists()">exists()</a>|.


has_key(<code class="special">{dict}</code>, <code class="special">{key}</code>)					<b class="vimtag">*<a name="has_key()">has_key()</a>*</b>
		The result is a Number, which is 1 if |<a href="eval.html#Dictionary">Dictionary</a>| <code class="special">{dict}</code> has
		an entry with key <code class="special">{key}</code>.  Zero otherwise.

haslocaldir([<code class="special">{winnr}</code> [, <code class="special">{tabnr}</code>]])			<b class="vimtag">*<a name="haslocaldir()">haslocaldir()</a>*</b>
		The result is a Number, which is 1 when the window has set a
		local path via |<a href="editing.html#:lcd">:lcd</a>|, and 0 otherwise.

		Without arguments use the current window.
		With <code class="special">{winnr}</code> use this window in the current tab page.
		With <code class="special">{winnr}</code> and <code class="special">{tabnr}</code> use the window in the specified tab
		page.
		Return 0 if the arguments are invalid.

hasmapto(<code class="special">{what}</code> [, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])			<b class="vimtag">*<a name="hasmapto()">hasmapto()</a>*</b>
		The result is a Number, which is 1 if there is a mapping that
		contains <code class="special">{what}</code> in somewhere in the rhs (what it is mapped to)
		and this mapping exists in one of the modes indicated by
		<code class="special">{mode}</code>.
		When <code class="special">{abbr}</code> is there and it is non-zero use abbreviations
		instead of mappings.  Don't forget to specify Insert and/or
		Command-line mode.
		Both the global mappings and the mappings local to the current
		buffer are checked for a match.
		If no matching mapping is found 0 is returned.
		The following characters are recognized in <code class="special">{mode}</code>:
			n	Normal mode
			v	Visual mode
			o	Operator-pending mode
			i	Insert mode
			l	Language-Argument ("r", "f", "t", etc.)
			c	Command-line mode
		When <code class="special">{mode}</code> is omitted, "nvo" is used.

		This function is useful to check if a mapping already exists
		to a function in a Vim script.	Example:
<code class="example">			:if !hasmapto('\ABCdoit')</code>
<code class="example">			:   map <code class="special">&lt;Leader&gt;</code>d \ABCdoit</code>
<code class="example">			:endif</code>
		This installs the mapping to "\ABCdoit" only if there isn't
		already a mapping to "\ABCdoit".

histadd(<code class="special">{history}</code>, <code class="special">{item}</code>)				<b class="vimtag">*<a name="histadd()">histadd()</a>*</b>
		Add the String <code class="special">{item}</code> to the history <code class="special">{history}</code> which can be
		one of:					<b class="vimtag">*<a name="hist-names">hist-names</a>*</b>
			"cmd"	 or ":"	  command line history
			"search" or "/"   search pattern history
			"expr"	 or "="   typed expression history
			"input"  or "@"	  input line history
			"debug"  or "&gt;"   debug command history
		The <code class="special">{history}</code> string does not need to be the whole name, one
		character is sufficient.
		If <code class="special">{item}</code> does already exist in the history, it will be
		shifted to become the newest entry.
		The result is a Number: 1 if the operation was successful,
		otherwise 0 is returned.

		Example:
<code class="example">			:call histadd("input", strftime("%Y %b %d"))</code>
<code class="example">			:let date=input("Enter date: ")</code>
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.

histdel(<code class="special">{history}</code> [, <code class="special">{item}</code>])				<b class="vimtag">*<a name="histdel()">histdel()</a>*</b>
		Clear <code class="special">{history}</code>, i.e. delete all its entries.  See |<a href="eval.html#hist-names">hist-names</a>|
		for the possible values of <code class="special">{history}</code>.

		If the parameter <code class="special">{item}</code> evaluates to a String, it is used as a
		regular expression.  All entries matching that expression will
		be removed from the history (if there are any).
		Upper/lowercase must match, unless "\c" is used |<a href="pattern.html#%2F\c">/\c</a>|.
		If <code class="special">{item}</code> evaluates to a Number, it will be interpreted as
		an index, see |<a href="cmdline.html#:history-indexing">:history-indexing</a>|.  The respective entry will
		be removed if it exists.

		The result is a Number: 1 for a successful operation,
		otherwise 0 is returned.

		Examples:
		Clear expression register history:
<code class="example">			:call histdel("expr")</code>

		Remove all entries starting with "*" from the search history:
<code class="example">			:call histdel("/", '^\*')</code>

		The following three are equivalent:
<code class="example">			:call histdel("search", histnr("search"))</code>
<code class="example">			:call histdel("search", -1)</code>
<code class="example">			:call histdel("search", '^'.histget("search", -1).'$')</code>

		To delete the last search pattern and use the last-but-one for
		the "n" command and 'hlsearch':
<code class="example">			:call histdel("search", -1)</code>
<code class="example">			:let @/ = histget("search", -1)</code>
<code class="example"></code>
histget(<code class="special">{history}</code> [, <code class="special">{index}</code>])				<b class="vimtag">*<a name="histget()">histget()</a>*</b>
		The result is a String, the entry with Number <code class="special">{index}</code> from
		<code class="special">{history}</code>.  See |<a href="eval.html#hist-names">hist-names</a>| for the possible values of
		<code class="special">{history}</code>, and |<a href="cmdline.html#:history-indexing">:history-indexing</a>| for <code class="special">{index}</code>.  If there is
		no such entry, an empty String is returned.  When <code class="special">{index}</code> is
		omitted, the most recent item from the history is used.

		Examples:
		Redo the second last search from history.
<code class="example">			:execute '/' . histget("search", -2)</code>
<code class="example"></code>
		Define an Ex command ":H <code class="special">{num}</code>" that supports re-execution of
		the <code class="special">{num}</code>th entry from the output of |<a href="cmdline.html#:history">:history</a>|.
<code class="example">			:command -nargs=1 H execute histget("cmd", 0+<code class="special">&lt;args&gt;</code>)</code>

histnr(<code class="special">{history}</code>)					<b class="vimtag">*<a name="histnr()">histnr()</a>*</b>
		The result is the Number of the current entry in <code class="special">{history}</code>.
		See |<a href="eval.html#hist-names">hist-names</a>| for the possible values of <code class="special">{history}</code>.
		If an error occurred, -1 is returned.

		Example:
<code class="example">			:let inp_index = histnr("expr")</code>

hlexists(<code class="special">{name}</code>)					<b class="vimtag">*<a name="hlexists()">hlexists()</a>*</b>
		The result is a Number, which is non-zero if a highlight group
		called <code class="special">{name}</code> exists.  This is when the group has been
		defined in some way.  Not necessarily when highlighting has
		been defined for it, it may also have been used for a syntax
		item.
							<b class="vimtag">*<a name="highlight_exists()">highlight_exists()</a>*</b>
		Obsolete name: highlight_exists().

							<b class="vimtag">*<a name="hlID()">hlID()</a>*</b>
hlID(<code class="special">{name}</code>)	The result is a Number, which is the ID of the highlight group
		with name <code class="special">{name}</code>.  When the highlight group doesn't exist,
		zero is returned.
		This can be used to retrieve information about the highlight
		group.	For example, to get the background color of the
		"Comment" group:
<code class="example">	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")</code>
							<b class="vimtag">*<a name="highlightID()">highlightID()</a>*</b>
		Obsolete name: highlightID().

hostname()						<b class="vimtag">*<a name="hostname()">hostname()</a>*</b>
		The result is a String, which is the name of the machine on
		which Vim is currently running.  Machine names greater than
		256 characters long are truncated.

iconv(<code class="special">{expr}</code>, <code class="special">{from}</code>, <code class="special">{to}</code>)				<b class="vimtag">*<a name="iconv()">iconv()</a>*</b>
		The result is a String, which is the text <code class="special">{expr}</code> converted
		from encoding <code class="special">{from}</code> to encoding <code class="special">{to}</code>.
		When the conversion completely fails an empty string is
		returned.  When some characters could not be converted they
		are replaced with "?".
		The encoding names are whatever the iconv() library function
		can accept, see ":!man 3 iconv".
		Most conversions require Vim to be compiled with the |<a href="various.html#+iconv">+iconv</a>|
		feature.  Otherwise only UTF-8 to latin1 conversion and back
		can be done.
		This can be used to display messages with special characters,
		no matter what 'encoding' is set to.  Write the message in
		UTF-8 and use:
<code class="example">			echo iconv(utf8_str, "utf-8", &amp;enc)</code>
		<code class="note">Note</code> that Vim uses UTF-8 for all Unicode encodings, conversion
		from/to UCS-2 is automatically changed to use UTF-8.  You
		cannot use UCS-2 in a string anyway, because of the NUL bytes.
		{only available when compiled with the |<a href="various.html#+multi_byte">+multi_byte</a>| feature}

							<b class="vimtag">*<a name="indent()">indent()</a>*</b>
indent(<code class="special">{lnum}</code>)	The result is a Number, which is indent of line <code class="special">{lnum}</code> in the
		current buffer.  The indent is counted in spaces, the value
		of 'tabstop' is relevant.  <code class="special">{lnum}</code> is used just like in
		|<a href="eval.html#getline()">getline()</a>|.
		When <code class="special">{lnum}</code> is invalid -1 is returned.


index(<code class="special">{list}</code>, <code class="special">{expr}</code> [, <code class="special">{start}</code> [, <code class="special">{ic}</code>]])			<b class="vimtag">*<a name="index()">index()</a>*</b>
		Return the lowest index in |<a href="eval.html#List">List</a>| <code class="special">{list}</code> where the item has a
		value equal to <code class="special">{expr}</code>.  There is no automatic conversion, so
		the String "4" is different from the Number 4.  And the number
		4 is different from the Float 4.0.  The value of 'ignorecase'
		is not used here, case always matters.
		If <code class="special">{start}</code> is given then start looking at the item with index
		<code class="special">{start}</code> (may be negative for an item relative to the end).
		When <code class="special">{ic}</code> is given and it is non-zero, ignore case.  Otherwise
		case must match.
		-1 is returned when <code class="special">{expr}</code> is not found in <code class="special">{list}</code>.
		Example:
<code class="example">			:let idx = index(words, "the")</code>
<code class="example">			:if index(numbers, 123) &gt;= 0</code>
<code class="example"></code>
<code class="example"></code>
input(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{completion}</code>]])		<b class="vimtag">*<a name="input()">input()</a>*</b>
		The result is a String, which is whatever the user typed on
		the command-line.  The <code class="special">{prompt}</code> argument is either a prompt
		string, or a blank string (for no prompt).  A '\n' can be used
		in the prompt to start a new line.
		The highlighting set with |<a href="eval.html#:echohl">:echohl</a>| is used for the prompt.
		The input is entered just like a command-line, with the same
		editing commands and mappings.	There is a separate history
		for lines typed for input().
		Example:
<code class="example">			:if input("Coffee or beer? ") == "beer"</code>
<code class="example">			:  echo "Cheers!"</code>
<code class="example">			:endif</code>

		If the optional <code class="special">{text}</code> argument is present and not empty, this
		is used for the default reply, as if the user typed this.
		Example:
<code class="example">			:let color = input("Color? ", "white")</code>
<code class="example"></code>
		The optional <code class="special">{completion}</code> argument specifies the type of
		completion supported for the input.  Without it completion is
		not performed.	The supported completion types are the same as
		that can be supplied to a user-defined command using the
		"-complete=" argument.	Refer to |<a href="map.html#:command-completion">:command-completion</a>| for
		more information.  Example:
<code class="example">			let fname = input("File: ", "", "file")</code>

		<code class="note">NOTE:</code> This function must not be used in a startup file, for
		the versions that only run in GUI mode (e.g., the Win32 GUI).
		<code class="note">Note:</code> When input() is called from within a mapping it will
		consume remaining characters from that mapping, because a
		mapping is handled like the characters were typed.
		Use |<a href="eval.html#inputsave()">inputsave()</a>| before input() and |<a href="eval.html#inputrestore()">inputrestore()</a>|
		after input() to avoid that.  Another solution is to avoid
		that further characters follow in the mapping, e.g., by using
		|<a href="eval.html#:execute">:execute</a>| or |<a href="various.html#:normal">:normal</a>|.

		Example with a mapping:
<code class="example">			:nmap \x :call GetFoo()<code class="special">&lt;CR&gt;</code>:exe "/" . Foo<code class="special">&lt;CR&gt;</code></code>
<code class="example">			:function GetFoo()</code>
<code class="example">			:  call inputsave()</code>
<code class="example">			:  let g:Foo = input("enter search pattern: ")</code>
<code class="example">			:  call inputrestore()</code>
<code class="example">			:endfunction</code>
<code class="example"></code>
inputdialog(<code class="special">{prompt}</code> [, <code class="special">{text}</code> [, <code class="special">{cancelreturn}</code>]])		<b class="vimtag">*<a name="inputdialog()">inputdialog()</a>*</b>
		Like |<a href="eval.html#input()">input()</a>|, but when the GUI is running and text dialogs
		are supported, a dialog window pops up to input the text.
		Example:
<code class="example">		   :let n = inputdialog("value for shiftwidth", shiftwidth())</code>
<code class="example">		   :if n != ""</code>
<code class="example">		   :  let &amp;sw = n</code>
<code class="example">		   :endif</code>
		When the dialog is cancelled <code class="special">{cancelreturn}</code> is returned.  When
		omitted an empty string is returned.
		Hitting <code class="special">&lt;Enter&gt;</code> works like pressing the OK button.  Hitting
		<code class="special">&lt;Esc&gt;</code> works like pressing the Cancel button.
		<code class="note">NOTE:</code> Command-line completion is not supported.

inputlist(<code class="special">{textlist}</code>)					<b class="vimtag">*<a name="inputlist()">inputlist()</a>*</b>
		<code class="special">{textlist}</code> must be a |<a href="eval.html#List">List</a>| of strings.  This |<a href="eval.html#List">List</a>| is
		displayed, one string per line.  The user will be prompted to
		enter a number, which is returned.
		The user can also select an item by clicking on it with the
		mouse.	For the first string 0 is returned.  When clicking
		above the first item a negative number is returned.  When
		clicking on the prompt one more than the length of <code class="special">{textlist}</code>
		is returned.
		Make sure <code class="special">{textlist}</code> has less than 'lines' entries, otherwise
		it won't work.	It's a good idea to put the entry number at
		the start of the string.  And put a prompt in the first item.
		Example:
<code class="example">			let color = inputlist(['Select color:', '1. red',</code>
<code class="example">				\ '2. green', '3. blue'])</code>
<code class="example"></code>
inputrestore()						<b class="vimtag">*<a name="inputrestore()">inputrestore()</a>*</b>
		Restore typeahead that was saved with a previous |<a href="eval.html#inputsave()">inputsave()</a>|.
		Should be called the same number of times inputsave() is
		called.  Calling it more often is harmless though.
		Returns 1 when there is nothing to restore, 0 otherwise.

inputsave()						<b class="vimtag">*<a name="inputsave()">inputsave()</a>*</b>
		Preserve typeahead (also from mappings) and clear it, so that
		a following prompt gets input from the user.  Should be
		followed by a matching inputrestore() after the prompt.  Can
		be used several times, in which case there must be just as
		many inputrestore() calls.
		Returns 1 when out of memory, 0 otherwise.

inputsecret(<code class="special">{prompt}</code> [, <code class="special">{text}</code>])			<b class="vimtag">*<a name="inputsecret()">inputsecret()</a>*</b>
		This function acts much like the |<a href="eval.html#input()">input()</a>| function with but
		two exceptions:
		a) the user's response will be displayed as a sequence of
		asterisks ("*") thereby keeping the entry secret, and
		b) the user's response will not be recorded on the input
		|<a href="cmdline.html#history">history</a>| stack.
		The result is a String, which is whatever the user actually
		typed on the command-line in response to the issued prompt.
		<code class="note">NOTE:</code> Command-line completion is not supported.

insert(<code class="special">{list}</code>, <code class="special">{item}</code> [, <code class="special">{idx}</code>])			<b class="vimtag">*<a name="insert()">insert()</a>*</b>
		Insert <code class="special">{item}</code> at the start of |<a href="eval.html#List">List</a>| <code class="special">{list}</code>.
		If <code class="special">{idx}</code> is specified insert <code class="special">{item}</code> before the item with index
		<code class="special">{idx}</code>.	If <code class="special">{idx}</code> is zero it goes before the first item, just
		like omitting <code class="special">{idx}</code>.  A negative <code class="special">{idx}</code> is also possible, see
		|<a href="eval.html#list-index">list-index</a>|.  -1 inserts just before the last item.
		Returns the resulting |<a href="eval.html#List">List</a>|.  Examples:
<code class="example">			:let mylist = insert([2, 3, 5], 1)</code>
<code class="example">			:call insert(mylist, 4, -1)</code>
<code class="example">			:call insert(mylist, 6, len(mylist))</code>
		The last example can be done simpler with |<a href="eval.html#add()">add()</a>|.
		<code class="note">Note</code> that when <code class="special">{item}</code> is a |<a href="eval.html#List">List</a>| it is inserted as a single
		item.  Use |<a href="eval.html#extend()">extend()</a>| to concatenate |<a href="eval.html#Lists">Lists</a>|.

invert(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="invert()">invert()</a>*</b>
		Bitwise invert.  The argument is converted to a number.  A
		List, Dict or Float argument causes an error.  Example:
<code class="example">			:let bits = invert(bits)</code>
<code class="example"></code>
isdirectory(<code class="special">{directory}</code>)				<b class="vimtag">*<a name="isdirectory()">isdirectory()</a>*</b>
		The result is a Number, which is non-zero when a directory
		with the name <code class="special">{directory}</code> exists.  If <code class="special">{directory}</code> doesn't
		exist, or isn't a directory, the result is FALSE.  <code class="special">{directory}</code>
		is any expression, which is used as a String.

islocked(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="islocked()">islocked()</a>*</b> <b class="vimtag">*<a name="E786">E786</a>*</b>
		The result is a Number, which is non-zero when <code class="special">{expr}</code> is the
		name of a locked variable.
		<code class="special">{expr}</code> must be the name of a variable, |<a href="eval.html#List">List</a>| item or
		|<a href="eval.html#Dictionary">Dictionary</a>| entry, not the variable itself!  Example:
<code class="example">			:let alist = [0, ['a', 'b'], 2, 3]</code>
<code class="example">			:lockvar 1 alist</code>
<code class="example">			:echo islocked('alist')		" 1</code>
<code class="example">			:echo islocked('alist[1]')	" 0</code>
<code class="example"></code>
		When <code class="special">{expr}</code> is a variable that does not exist you get an error
		message.  Use |<a href="eval.html#exists()">exists()</a>| to check for existence.

isnan(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="isnan()">isnan()</a>*</b>
		Return non-zero if <code class="special">{expr}</code> is a float with value NaN.
<code class="example">			echo isnan(0.0 / 0.0)</code>
<code class="section">			1 </code>

		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}

items(<code class="special">{dict}</code>)						<b class="vimtag">*<a name="items()">items()</a>*</b>
		Return a |<a href="eval.html#List">List</a>| with all the key-value pairs of <code class="special">{dict}</code>.  Each
		|<a href="eval.html#List">List</a>| item is a list with two items: the key of a <code class="special">{dict}</code>
		entry and the value of this entry.  The |<a href="eval.html#List">List</a>| is in arbitrary
		order.

job_getchannel(<code class="special">{job}</code>)					 <b class="vimtag">*<a name="job_getchannel()">job_getchannel()</a>*</b>
		Get the channel handle that <code class="special">{job}</code> is using.
		To check if the job has no channel:
<code class="example">			if string(job_getchannel()) == 'channel fail'</code>

		{only available when compiled with the |<a href="various.html#+job">+job</a>| feature}

job_info(<code class="special">{job}</code>)						<b class="vimtag">*<a name="job_info()">job_info()</a>*</b>
		Returns a Dictionary with information about <code class="special">{job}</code>:
		   "status"	what |<a href="eval.html#job_status()">job_status()</a>| returns
		   "channel"	what |<a href="eval.html#job_getchannel()">job_getchannel()</a>| returns
		   "exitval"	only valid when "status" is "dead"
		   "exit_cb"	function to be called on exit
		   "stoponexit"	|<a href="channel.html#job-stoponexit">job-stoponexit</a>|

job_setoptions(<code class="special">{job}</code>, <code class="special">{options}</code>)			<b class="vimtag">*<a name="job_setoptions()">job_setoptions()</a>*</b>
		Change options for <code class="special">{job}</code>.  Supported are:
		   "stoponexit"	|<a href="channel.html#job-stoponexit">job-stoponexit</a>|
		   "exit_cb"	|<a href="channel.html#job-exit_cb">job-exit_cb</a>|

job_start(<code class="special">{command}</code> [, <code class="special">{options}</code>])			<b class="vimtag">*<a name="job_start()">job_start()</a>*</b>
		Start a job and return a Job object.  Unlike |<a href="eval.html#system()">system()</a>| and
		|<a href="various.html#:!cmd">:!cmd</a>| this does not wait for the job to finish.

		<code class="special">{command}</code> can be a String.  This works best on MS-Windows.  On
		Unix it is split up in white-separated parts to be passed to
		execvp().  Arguments in double quotes can contain white space.

		<code class="special">{command}</code> can be a List, where the first item is the executable
		and further items are the arguments.  All items are converted
		to String.  This works best on Unix.

		On MS-Windows, job_start() makes a GUI application hidden. If
		want to show it, Use |<a href="os_win32.html#:!start">:!start</a>| instead.

		The command is executed directly, not through a shell, the
		'shell' option is not used.  To use the shell:
<code class="example">	let job = job_start(["/bin/sh", "-c", "echo hello"])</code>
&lt;		Or:
<code class="example">	let job = job_start('/bin/sh -c "echo hello"')</code>
		<code class="note">Note</code> that this will start two processes, the shell and the
		command it executes.  If you don't want this use the "exec"
		shell command.

		On Unix $PATH is used to search for the executable only when
		the command does not contain a slash.

		The job will use the same terminal as Vim.  If it reads from
		stdin the job and Vim will be fighting over input, that
		doesn't work.  Redirect stdin and stdout to avoid problems:
<code class="example">	let job = job_start(['sh', '-c', "myserver <code class="special">&lt;/dev/null &gt;</code>/dev/null"])</code>

		The returned Job object can be used to get the status with
		|<a href="eval.html#job_status()">job_status()</a>| and stop the job with |<a href="eval.html#job_stop()">job_stop()</a>|.

		<code class="special">{options}</code> must be a Dictionary.  It can contain many optional
		items, see |<a href="channel.html#job-options">job-options</a>|.

		{only available when compiled with the |<a href="various.html#+job">+job</a>| feature}

job_status(<code class="special">{job}</code>)					<b class="vimtag">*<a name="job_status()">job_status()</a>*</b> <b class="vimtag">*<a name="E916">E916</a>*</b>
		Returns a String with the status of <code class="special">{job}</code>:
			"run"	job is running
			"fail"	job failed to start
			"dead"	job died or was stopped after running

		If an exit callback was set with the "exit_cb" option and the
		job is now detected to be "dead" the callback will be invoked.

		For more information see |<a href="eval.html#job_info()">job_info()</a>|.

		{only available when compiled with the |<a href="various.html#+job">+job</a>| feature}

job_stop(<code class="special">{job}</code> [, <code class="special">{how}</code>])					<b class="vimtag">*<a name="job_stop()">job_stop()</a>*</b>
		Stop the <code class="special">{job}</code>.  This can also be used to signal the job.

		When <code class="special">{how}</code> is omitted or is "term" the job will be terminated.
		For Unix SIGTERM is sent.  On MS-Windows the job will be
		terminated forcedly (there is no "gentle" way).
		This goes to the process group, thus children may also be
		affected.

		Effect for Unix:
			"term"	 SIGTERM (default)
			"hup"	 SIGHUP
			"quit"	 SIGQUIT
			"int"	 SIGINT
			"kill"	 SIGKILL (strongest way to stop)
			number	 signal with that number

		Effect for MS-Windows:
			"term"	 terminate process forcedly (default)
			"hup"	 CTRL_BREAK
			"quit"	 CTRL_BREAK
			"int"	 CTRL_C
			"kill"	 terminate process forcedly
			Others	 CTRL_BREAK

		On Unix the signal is sent to the process group.  This means
		that when the job is "sh -c command" it affects both the shell
		and the command.

		The result is a Number: 1 if the operation could be executed,
		0 if "how" is not supported on the system.
		<code class="note">Note</code> that even when the operation was executed, whether the
		job was actually stopped needs to be checked with
		job_status().
		The status of the job isn't checked, the operation will even
		be done when Vim thinks the job isn't running.

		{only available when compiled with the |<a href="various.html#+job">+job</a>| feature}

join(<code class="special">{list}</code> [, <code class="special">{sep}</code>])					<b class="vimtag">*<a name="join()">join()</a>*</b>
		Join the items in <code class="special">{list}</code> together into one String.
		When <code class="special">{sep}</code> is specified it is put in between the items.  If
		<code class="special">{sep}</code> is omitted a single space is used.
		<code class="note">Note</code> that <code class="special">{sep}</code> is not added at the end.  You might want to
		add it there too:
<code class="example">			let lines = join(mylist, "\n") . "\n"</code>
		String items are used as-is.  |<a href="eval.html#Lists">Lists</a>| and |<a href="eval.html#Dictionaries">Dictionaries</a>| are
		converted into a string like with |<a href="eval.html#string()">string()</a>|.
		The opposite function is |<a href="eval.html#split()">split()</a>|.

js_decode(<code class="special">{string}</code>)					<b class="vimtag">*<a name="js_decode()">js_decode()</a>*</b>
		This is similar to |<a href="eval.html#json_decode()">json_decode()</a>| with these differences:
		- Object key names do not have to be in quotes.
		- Empty items in an array (between two commas) are allowed and
		  result in v:none items.

js_encode(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="js_encode()">js_encode()</a>*</b>
		This is similar to |<a href="eval.html#json_encode()">json_encode()</a>| with these differences:
		- Object key names are not in quotes.
		- v:none items in an array result in an empty item between
		  commas.
		For example, the Vim object:
<code class="section">			[1,v:none,<code class="special">{"one":1}</code>,v:none] </code>
		Will be encoded as:
<code class="section">			[1,,<code class="special">{one:1}</code>,,] </code>
		While json_encode() would produce:
<code class="section">			[1,null,<code class="special">{"one":1}</code>,null] </code>
		This encoding is valid for JavaScript. It is more efficient
		than JSON, especially when using an array with optional items.


json_decode(<code class="special">{string}</code>)					<b class="vimtag">*<a name="json_decode()">json_decode()</a>*</b>
		This parses a JSON formatted string and returns the equivalent
		in Vim values.  See |<a href="eval.html#json_encode()">json_encode()</a>| for the relation between
		JSON and Vim values.
		The decoding is permissive:
		- A trailing comma in an array and object is ignored.
		- More floating point numbers are recognized, e.g. "1." for
		  "1.0".
		The result must be a valid Vim type:
		- An empty object member name is not allowed.
		- Duplicate object member names are not allowed.

json_encode(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="json_encode()">json_encode()</a>*</b>
		Encode <code class="special">{expr}</code> as JSON and return this as a string.
		The encoding is specified in:
		https://tools.ietf.org/html/rfc7159.html
		Vim values are converted as follows:
		   Number		decimal number
		   Float		floating point number
		   Float nan		"NaN"
		   Float inf		"Infinity"
		   String		in double quotes (possibly null)
		   Funcref		not possible, error
		   List			as an array (possibly null); when
					used recursively: []
		   Dict			as an object (possibly null); when
					used recursively: <code class="special">{}</code>
		   v:false		"false"
		   v:true		"true"
		   v:none		"null"
		   v:null		"null"
		<code class="note">Note</code> that NaN and Infinity are passed on as values.  This is
		missing in the JSON standard, but several implementations do
		allow it.  If not then you will get an error.

keys(<code class="special">{dict}</code>)						<b class="vimtag">*<a name="keys()">keys()</a>*</b>
		Return a |<a href="eval.html#List">List</a>| with all the keys of <code class="special">{dict}</code>.  The |<a href="eval.html#List">List</a>| is in
		arbitrary order.

							<b class="vimtag">*<a name="len()">len()</a>*</b> <b class="vimtag">*<a name="E701">E701</a>*</b>
len(<code class="special">{expr}</code>)	The result is a Number, which is the length of the argument.
		When <code class="special">{expr}</code> is a String or a Number the length in bytes is
		used, as with |<a href="eval.html#strlen()">strlen()</a>|.
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| the number of items in the |<a href="eval.html#List">List</a>| is
		returned.
		When <code class="special">{expr}</code> is a |<a href="eval.html#Dictionary">Dictionary</a>| the number of entries in the
		|<a href="eval.html#Dictionary">Dictionary</a>| is returned.
		Otherwise an error is given.

						<b class="vimtag">*<a name="libcall()">libcall()</a>*</b> <b class="vimtag">*<a name="E364">E364</a>*</b> <b class="vimtag">*<a name="E368">E368</a>*</b>
libcall(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)
		Call function <code class="special">{funcname}</code> in the run-time library <code class="special">{libname}</code>
		with single argument <code class="special">{argument}</code>.
		This is useful to call functions in a library that you
		especially made to be used with Vim.  Since only one argument
		is possible, calling standard library functions is rather
		limited.
		The result is the String returned by the function.  If the
		function returns NULL, this will appear as an empty string ""
		to Vim.
		If the function returns a number, use libcallnr()!
		If <code class="special">{argument}</code> is a number, it is passed to the function as an
		int; if <code class="special">{argument}</code> is a string, it is passed as a
		null-terminated string.
		This function will fail in |<a href="starting.html#restricted-mode">restricted-mode</a>|.

		libcall() allows you to write your own 'plug-in' extensions to
		Vim without having to recompile the program.  It is NOT a
		means to call system functions!  If you try to do so Vim will
		very probably crash.

		For Win32, the functions you write must be placed in a DLL
		and use the normal C calling convention (NOT Pascal which is
		used in Windows System DLLs).  The function must take exactly
		one parameter, either a character pointer or a long integer,
		and must return a character pointer or NULL.  The character
		pointer returned must point to memory that will remain valid
		after the function has returned (e.g. in static data in the
		DLL).  If it points to allocated memory, that memory will
		leak away.  Using a static buffer in the function should work,
		it's then freed when the DLL is unloaded.

		WARNING: If the function returns a non-valid pointer, Vim may
		crash!	This also happens if the function returns a number,
		because Vim thinks it's a pointer.
		For Win32 systems, <code class="special">{libname}</code> should be the filename of the DLL
		without the ".DLL" suffix.  A full path is only required if
		the DLL is not in the usual places.
		For Unix: When compiling your own plugins, remember that the
		object code must be compiled as position-independent ('PIC').
		{only in Win32 and some Unix versions, when the |<a href="various.html#+libcall">+libcall</a>|
		feature is present}
		Examples:
<code class="example">			:echo libcall("libc.so", "getenv", "HOME")</code>

							<b class="vimtag">*<a name="libcallnr()">libcallnr()</a>*</b>
libcallnr(<code class="special">{libname}</code>, <code class="special">{funcname}</code>, <code class="special">{argument}</code>)
		Just like |<a href="eval.html#libcall()">libcall()</a>|, but used for a function that returns an
		int instead of a string.
		{only in Win32 on some Unix versions, when the |<a href="various.html#+libcall">+libcall</a>|
		feature is present}
		Examples:
<code class="example">			:echo libcallnr("/usr/lib/libc.so", "getpid", "")</code>
<code class="example">			:call libcallnr("libc.so", "printf", "Hello World!\n")</code>
<code class="example">			:call libcallnr("libc.so", "sleep", 10)</code>

							<b class="vimtag">*<a name="line()">line()</a>*</b>
line(<code class="special">{expr}</code>)	The result is a Number, which is the line number of the file
		position given with <code class="special">{expr}</code>.  The accepted positions are:
		    .	    the cursor position
		    $	    the last line in the current buffer
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    w0	    first line visible in current window
		    w$	    last line visible in current window
		    v	    In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |<a href="motion.html#'%3C">'&lt;</a>| in
			    that it's updated right away.
		<code class="note">Note</code> that a mark in another file can be used.  The line number
		then applies to another buffer.
		To get the column number use |<a href="eval.html#col()">col()</a>|.  To get both use
		|<a href="eval.html#getpos()">getpos()</a>|.
		Examples:
<code class="example">			line(".")		line number of the cursor</code>
<code class="example">			line("'t")		line number of mark t</code>
<code class="example">			line("'" . marker)	line number of mark marker</code>
							<b class="vimtag">*<a name="last-position-jump">last-position-jump</a>*</b>
		This autocommand jumps to the last known position in a file
		just after opening it, if the '" mark is set:
<code class="example">	:au BufReadPost * if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") |<code class="badlink"> exe "normal! g`\"" </code>| endif</code>
<code class="example"></code>
line2byte(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="line2byte()">line2byte()</a>*</b>
		Return the byte count from the start of the buffer for line
		<code class="special">{lnum}</code>.  This includes the end-of-line character, depending on
		the 'fileformat' option for the current buffer.  The first
		line returns 1. 'encoding' matters, 'fileencoding' is ignored.
		This can also be used to get the byte count for the line just
		below the last line:
<code class="example">			line2byte(line("$") + 1)</code>
		This is the buffer size plus one.  If 'fileencoding' is empty
		it is the file size plus one.
		When <code class="special">{lnum}</code> is invalid, or the |<a href="various.html#+byte_offset">+byte_offset</a>| feature has been
		disabled at compile time, -1 is returned.
		Also see |<a href="eval.html#byte2line()">byte2line()</a>|, |<a href="motion.html#go">go</a>| and |<a href="motion.html#:goto">:goto</a>|.

lispindent(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="lispindent()">lispindent()</a>*</b>
		Get the amount of indent for line <code class="special">{lnum}</code> according the lisp
		indenting rules, as with 'lisp'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  <code class="special">{lnum}</code> is used just like in |<a href="eval.html#getline()">getline()</a>|.
		When <code class="special">{lnum}</code> is invalid or Vim was not compiled the
		|<a href="various.html#+lispindent">+lispindent</a>| feature, -1 is returned.

localtime()						<b class="vimtag">*<a name="localtime()">localtime()</a>*</b>
		Return the current time, measured as seconds since 1st Jan
		1970.  See also |<a href="eval.html#strftime()">strftime()</a>| and |<a href="eval.html#getftime()">getftime()</a>|.


log(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="log()">log()</a>*</b>
		Return the natural logarithm (base e) of <code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>| in the range
		(0, inf].
		Examples:
<code class="example">			:echo log(10)</code>
&lt;			2.302585
<code class="example">			:echo log(exp(5))</code>
			5.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


log10(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="log10()">log10()</a>*</b>
		Return the logarithm of Float <code class="special">{expr}</code> to base 10 as a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo log10(1000)</code>
&lt;			3.0
<code class="example">			:echo log10(0.01)</code>
			-2.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}

luaeval(<code class="special">{expr}</code>[, <code class="special">{expr}</code>])					<b class="vimtag">*<a name="luaeval()">luaeval()</a>*</b>
		Evaluate Lua expression <code class="special">{expr}</code> and return its result converted
		to Vim data structures. Second <code class="special">{expr}</code> may hold additional
		argument accessible as _A inside first <code class="special">{expr}</code>.
		Strings are returned as they are.
		Boolean objects are converted to numbers.
		Numbers are converted to |<a href="eval.html#Float">Float</a>| values if vim was compiled
		with |<a href="various.html#+float">+float</a>| and to numbers otherwise.
		Dictionaries and lists obtained by vim.eval() are returned
		as-is.
		Other objects are returned as zero without any errors.
		See |<a href="if_lua.html#lua-luaeval">lua-luaeval</a>| for more details.
		{only available when compiled with the |<a href="various.html#+lua">+lua</a>| feature}

map(<code class="special">{expr}</code>, <code class="special">{string}</code>)					<b class="vimtag">*<a name="map()">map()</a>*</b>
		<code class="special">{expr}</code> must be a |<a href="eval.html#List">List</a>| or a |<a href="eval.html#Dictionary">Dictionary</a>|.
		Replace each item in <code class="special">{expr}</code> with the result of evaluating
		<code class="special">{string}</code>.
		Inside <code class="special">{string}</code> |<a href="eval.html#v:val">v:val</a>| has the value of the current item.
		For a |<a href="eval.html#Dictionary">Dictionary</a>| |<a href="eval.html#v:key">v:key</a>| has the key of the current item
		and for a |<a href="eval.html#List">List</a>| |<a href="eval.html#v:key">v:key</a>| has the index of the current item.
		Example:
<code class="example">			:call map(mylist, '"&gt; " . v:val . " &lt;"')</code>
		This puts "&gt; " before and " &lt;" after each item in "mylist".

		<code class="note">Note</code> that <code class="special">{string}</code> is the result of an expression and is then
		used as an expression again.  Often it is good to use a
		|<a href="eval.html#literal-string">literal-string</a>| to avoid having to double backslashes.  You
		still have to double ' quotes

		The operation is done in-place.  If you want a |<a href="eval.html#List">List</a>| or
		|<a href="eval.html#Dictionary">Dictionary</a>| to remain unmodified make a copy first:
<code class="example">			:let tlist = map(copy(mylist), ' v:val . "\t"')</code>
<code class="example"></code>
		Returns <code class="special">{expr}</code>, the |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| that was filtered.
		When an error is encountered while evaluating <code class="special">{string}</code> no
		further items in <code class="special">{expr}</code> are processed.


maparg(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code> [, <code class="special">{dict}</code>]]])			<b class="vimtag">*<a name="maparg()">maparg()</a>*</b>
		When <code class="special">{dict}</code> is omitted or zero: Return the rhs of mapping
		<code class="special">{name}</code> in mode <code class="special">{mode}</code>.  The returned String has special
		characters translated like in the output of the ":map" command
		listing.

		When there is no mapping for <code class="special">{name}</code>, an empty String is
		returned.

		The <code class="special">{name}</code> can have special key names, like in the ":map"
		command.

		<code class="special">{mode}</code> can be one of these strings:
			"n"	Normal
			"v"	Visual (including Select)
			"o"	Operator-pending
			"i"	Insert
			"c"	Cmd-line
			"s"	Select
			"x"	Visual
			"l"	langmap |<a href="map.html#language-mapping">language-mapping</a>|
			""	Normal, Visual and Operator-pending
		When <code class="special">{mode}</code> is omitted, the modes for "" are used.

		When <code class="special">{abbr}</code> is there and it is non-zero use abbreviations
		instead of mappings.

		When <code class="special">{dict}</code> is there and it is non-zero return a dictionary
		containing all the information of the mapping with the
		following items:
		  "lhs"	     The <code class="special">{lhs}</code> of the mapping.
		  "rhs"	     The <code class="special">{rhs}</code> of the mapping as typed.
		  "silent"   1 for a |<a href="map.html#:map-silent">:map-silent</a>| mapping, else 0.
		  "noremap"  1 if the <code class="special">{rhs}</code> of the mapping is not remappable.
		  "expr"     1 for an expression mapping (|<a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a>|).
		  "buffer"   1 for a buffer local mapping (|<a href="map.html#:map-local">:map-local</a>|).
		  "mode"     Modes for which the mapping is defined. In
			     addition to the modes mentioned above, these
			     characters will be used:
			     " "     Normal, Visual and Operator-pending
			     "!"     Insert and Commandline mode
				     (|<a href="map.html#mapmode-ic">mapmode-ic</a>|)
		  "sid"	     The script local ID, used for <code class="special">&lt;sid&gt;</code> mappings
			     (|<a href="map.html#%3CSID%3E">&lt;SID&gt;</a>|).
		  "nowait"   Do not wait for other, longer mappings.
			     (|<a href="map.html#:map-%3Cnowait%3E">:map-&lt;nowait&gt;</a>|).

		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to map a key even when it's already
		mapped, and have it do the original mapping too.  Sketch:
<code class="example">			exe 'nnoremap <code class="special">&lt;Tab&gt;</code> ==' . maparg('<code class="special">&lt;Tab&gt;</code>', 'n')</code>
<code class="example"></code>
<code class="example"></code>
mapcheck(<code class="special">{name}</code>[, <code class="special">{mode}</code> [, <code class="special">{abbr}</code>]])			<b class="vimtag">*<a name="mapcheck()">mapcheck()</a>*</b>
		Check if there is a mapping that matches with <code class="special">{name}</code> in mode
		<code class="special">{mode}</code>.  See |<a href="eval.html#maparg()">maparg()</a>| for <code class="special">{mode}</code> and special names in
		<code class="special">{name}</code>.
		When <code class="special">{abbr}</code> is there and it is non-zero use abbreviations
		instead of mappings.
		A match happens with a mapping that starts with <code class="special">{name}</code> and
		with a mapping which is equal to the start of <code class="special">{name}</code>.

<code class="section">			matches mapping "a"	"ab"	"abc" </code>
		   mapcheck("a")	yes	yes	 yes
		   mapcheck("abc")	yes	yes	 yes
		   mapcheck("ax")	yes	no	 no
		   mapcheck("b")	no	no	 no

		The difference with maparg() is that mapcheck() finds a
		mapping that matches with <code class="special">{name}</code>, while maparg() only finds a
		mapping for <code class="special">{name}</code> exactly.
		When there is no mapping that starts with <code class="special">{name}</code>, an empty
		String is returned.  If there is one, the rhs of that mapping
		is returned.  If there are several mappings that start with
		<code class="special">{name}</code>, the rhs of one of them is returned.
		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to check if a mapping can be added
		without being ambiguous.  Example:
<code class="example">	:if mapcheck("_vv") == ""</code>
<code class="example">	:   map _vv :set guifont=7x13<code class="special">&lt;CR&gt;</code></code>
<code class="example">	:endif</code>
		This avoids adding the "_vv" mapping when there already is a
		mapping for "_v" or for "_vvv".

match(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])			<b class="vimtag">*<a name="match()">match()</a>*</b>
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| then this returns the index of the
		first item where <code class="special">{pat}</code> matches.  Each item is used as a
		String, |<a href="eval.html#Lists">Lists</a>| and |<a href="eval.html#Dictionaries">Dictionaries</a>| are used as echoed.
		Otherwise, <code class="special">{expr}</code> is used as a String.	The result is a
		Number, which gives the index (byte offset) in <code class="special">{expr}</code> where
		<code class="special">{pat}</code> matches.
		A match at the first character or |<a href="eval.html#List">List</a>| item returns zero.
		If there is no match -1 is returned.
		For getting submatches see |<a href="eval.html#matchlist()">matchlist()</a>|.
		Example:
<code class="example">			:echo match("testing", "ing")	" results in 4</code>
<code class="example">			:echo match([1, 'x'], '\a')	" results in 1</code>
		See |<a href="eval.html#string-match">string-match</a>| for how <code class="special">{pat}</code> is used.
								<b class="vimtag">*<a name="strpbrk()">strpbrk()</a>*</b>
		Vim doesn't have a strpbrk() function.	But you can do:
<code class="example">			:let sepidx = match(line, '[.,;: \t]')</code>
								<b class="vimtag">*<a name="strcasestr()">strcasestr()</a>*</b>
		Vim doesn't have a strcasestr() function.  But you can add
		"\c" to the pattern to ignore case:
<code class="example">			:let idx = match(haystack, '\cneedle')</code>

		If <code class="special">{start}</code> is given, the search starts from byte index
		<code class="special">{start}</code> in a String or item <code class="special">{start}</code> in a |<a href="eval.html#List">List</a>|.
		The result, however, is still the index counted from the
		first character/item.  Example:
<code class="example">			:echo match("testing", "ing", 2)</code>
&lt;		result is again "4".
<code class="example">			:echo match("testing", "ing", 4)</code>
&lt;		result is again "4".
<code class="example">			:echo match("testing", "t", 2)</code>
		result is "3".
		For a String, if <code class="special">{start}</code> &gt; 0 then it is like the string starts
		<code class="special">{start}</code> bytes later, thus "^" will match at <code class="special">{start}</code>.  Except
		when <code class="special">{count}</code> is given, then it's like matches before the
		<code class="special">{start}</code> byte are ignored (this is a bit complicated to keep it
		backwards compatible).
		For a String, if <code class="special">{start}</code> &lt; 0, it will be set to 0.  For a list
		the index is counted from the end.
		If <code class="special">{start}</code> is out of range (<code class="special">{start}</code> &gt; strlen(<code class="special">{expr}</code>) for a
		String or <code class="special">{start}</code> &gt; len(<code class="special">{expr}</code>) for a |<a href="eval.html#List">List</a>|) -1 is returned.

		When <code class="special">{count}</code> is given use the <code class="special">{count}</code>'th match.  When a match
		is found in a String the search for the next one starts one
		character further.  Thus this example results in 1:
<code class="example">			echo match("testing", "..", 0, 2)</code>
		In a |<a href="eval.html#List">List</a>| the search continues in the next item.
		<code class="note">Note</code> that when <code class="special">{count}</code> is added the way <code class="special">{start}</code> works changes,
		see above.

		See |<a href="pattern.html#pattern">pattern</a>| for the patterns that are accepted.
		The 'ignorecase' option is used to set the ignore-caseness of
		the pattern.  'smartcase' is NOT used.	The matching is always
		done like 'magic' is set and 'cpoptions' is empty.

					<b class="vimtag">*<a name="matchadd()">matchadd()</a>*</b> <b class="vimtag">*<a name="E798">E798</a>*</b> <b class="vimtag">*<a name="E799">E799</a>*</b> <b class="vimtag">*<a name="E801">E801</a>*</b>
matchadd(<code class="special">{group}</code>, <code class="special">{pattern}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code>[, <code class="special">{dict}</code>]]])
		Defines a pattern to be highlighted in the current window (a
		"match").  It will be highlighted with <code class="special">{group}</code>.  Returns an
		identification number (ID), which can be used to delete the
		match using |<a href="eval.html#matchdelete()">matchdelete()</a>|.
		Matching is case sensitive and magic, unless case sensitivity
		or magicness are explicitly overridden in <code class="special">{pattern}</code>.  The
		'magic', 'smartcase' and 'ignorecase' options are not used.
		The "Conceal" value is special, it causes the match to be
		concealed.

		The optional <code class="special">{priority}</code> argument assigns a priority to the
		match.	A match with a high priority will have its
		highlighting overrule that of a match with a lower priority.
		A priority is specified as an integer (negative numbers are no
		exception).  If the <code class="special">{priority}</code> argument is not specified, the
		default priority is 10.  The priority of 'hlsearch' is zero,
		hence all matches with a priority greater than zero will
		overrule it.  Syntax highlighting (see 'syntax') is a separate
		mechanism, and regardless of the chosen priority a match will
		always overrule syntax highlighting.

		The optional <code class="special">{id}</code> argument allows the request for a specific
		match ID.  If a specified ID is already taken, an error
		message will appear and the match will not be added.  An ID
		is specified as a positive integer (zero excluded).  IDs 1, 2
		and 3 are reserved for |<a href="pattern.html#:match">:match</a>|, |<a href="pattern.html#:2match">:2match</a>| and |<a href="pattern.html#:3match">:3match</a>|,
		respectively.  If the <code class="special">{id}</code> argument is not specified or -1,
		|<a href="eval.html#matchadd()">matchadd()</a>| automatically chooses a free ID.

		The optional <code class="special">{dict}</code> argument allows for further custom
		values. Currently this is used to specify a match specific
		conceal character that will be shown for |<a href="syntax.html#hl-Conceal">hl-Conceal</a>|
		highlighted matches. The dict can have the following members:

			conceal	    Special character to show instead of the
				    match (only for |<a href="syntax.html#hl-Conceal">hl-Conceal</a>| highlighted
				    matches, see |<a href="syntax.html#:syn-cchar">:syn-cchar</a>|)

		The number of matches is not limited, as it is the case with
		the |<a href="pattern.html#:match">:match</a>| commands.

		Example:
<code class="example">			:highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">			:let m = matchadd("MyGroup", "TODO")</code>
&lt;		Deletion of the pattern:
<code class="example">			:call matchdelete(m)</code>
<code class="example"></code>
		A list of matches defined by |<a href="eval.html#matchadd()">matchadd()</a>| and |<a href="pattern.html#:match">:match</a>| are
		available from |<a href="eval.html#getmatches()">getmatches()</a>|.	All matches can be deleted in
		one operation by |<a href="eval.html#clearmatches()">clearmatches()</a>|.

matchaddpos(<code class="special">{group}</code>, <code class="special">{pos}</code>[, <code class="special">{priority}</code>[, <code class="special">{id}</code>[, <code class="special">{dict}</code>]]])		<b class="vimtag">*<a name="matchaddpos()">matchaddpos()</a>*</b>
		Same as |<a href="eval.html#matchadd()">matchadd()</a>|, but requires a list of positions <code class="special">{pos}</code>
		instead of a pattern. This command is faster than |<a href="eval.html#matchadd()">matchadd()</a>|
		because it does not require to handle regular expressions and
		sets buffer line boundaries to redraw screen. It is supposed
		to be used when fast match additions and deletions are
		required, for example to highlight matching parentheses.

		The list <code class="special">{pos}</code> can contain one of these items:
		- A number.  This whole line will be highlighted.  The first
		  line has number 1.
		- A list with one number, e.g., [23]. The whole line with this
		  number will be highlighted.
		- A list with two numbers, e.g., [23, 11]. The first number is
		  the line number, the second one is the column number (first
		  column is 1, the value must correspond to the byte index as
		  |<a href="eval.html#col()">col()</a>| would return).  The character at this position will
		  be highlighted.
		- A list with three numbers, e.g., [23, 11, 3]. As above, but
		  the third number gives the length of the highlight in bytes.

		The maximum number of positions is 8.

		Example:
<code class="example">			:highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">			:let m = matchaddpos("MyGroup", [[23, 24], 34])</code>
&lt;		Deletion of the pattern:
<code class="example">			:call matchdelete(m)</code>
<code class="example"></code>
		Matches added by |<a href="eval.html#matchaddpos()">matchaddpos()</a>| are returned by
		|<a href="eval.html#getmatches()">getmatches()</a>| with an entry "pos1", "pos2", etc., with the
		value a list like the <code class="special">{pos}</code> item.
		These matches cannot be set via |<a href="eval.html#setmatches()">setmatches()</a>|, however they
		can still be deleted by |<a href="eval.html#clearmatches()">clearmatches()</a>|.

matcharg(<code class="special">{nr}</code>)							<b class="vimtag">*<a name="matcharg()">matcharg()</a>*</b>
		Selects the <code class="special">{nr}</code> match item, as set with a |<a href="pattern.html#:match">:match</a>|,
		|<a href="pattern.html#:2match">:2match</a>| or |<a href="pattern.html#:3match">:3match</a>| command.
		Return a |<a href="eval.html#List">List</a>| with two elements:
			The name of the highlight group used
			The pattern used.
		When <code class="special">{nr}</code> is not 1, 2 or 3 returns an empty |<a href="eval.html#List">List</a>|.
		When there is no match item set returns ['', ''].
		This is useful to save and restore a |<a href="pattern.html#:match">:match</a>|.
		Highlighting matches using the |<a href="pattern.html#:match">:match</a>| commands are limited
		to three matches. |<a href="eval.html#matchadd()">matchadd()</a>| does not have this limitation.

matchdelete(<code class="special">{id}</code>)			       <b class="vimtag">*<a name="matchdelete()">matchdelete()</a>*</b> <b class="vimtag">*<a name="E802">E802</a>*</b> <b class="vimtag">*<a name="E803">E803</a>*</b>
		Deletes a match with ID <code class="special">{id}</code> previously defined by |<a href="eval.html#matchadd()">matchadd()</a>|
		or one of the |<a href="pattern.html#:match">:match</a>| commands.  Returns 0 if successful,
		otherwise -1.  See example for |<a href="eval.html#matchadd()">matchadd()</a>|.  All matches can
		be deleted in one operation by |<a href="eval.html#clearmatches()">clearmatches()</a>|.

matchend(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])			<b class="vimtag">*<a name="matchend()">matchend()</a>*</b>
		Same as |<a href="eval.html#match()">match()</a>|, but return the index of first character
		after the match.  Example:
<code class="example">			:echo matchend("testing", "ing")</code>
		results in "7".
							<b class="vimtag">*<a name="strspn()">strspn()</a>*</b> <b class="vimtag">*<a name="strcspn()">strcspn()</a>*</b>
		Vim doesn't have a strspn() or strcspn() function, but you can
		do it with matchend():
<code class="example">			:let span = matchend(line, '[a-zA-Z]')</code>
<code class="example">			:let span = matchend(line, '[^a-zA-Z]')</code>
		Except that -1 is returned when there are no matches.

		The <code class="special">{start}</code>, if given, has the same meaning as for |<a href="eval.html#match()">match()</a>|.
<code class="example">			:echo matchend("testing", "ing", 2)</code>
&lt;		results in "7".
<code class="example">			:echo matchend("testing", "ing", 5)</code>
		result is "-1".
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| the result is equal to |<a href="eval.html#match()">match()</a>|.

matchlist(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])			<b class="vimtag">*<a name="matchlist()">matchlist()</a>*</b>
		Same as |<a href="eval.html#match()">match()</a>|, but return a |<a href="eval.html#List">List</a>|.  The first item in the
		list is the matched string, same as what matchstr() would
		return.  Following items are submatches, like "\1", "\2", etc.
		in |<a href="change.html#:substitute">:substitute</a>|.  When an optional submatch didn't match an
		empty string is used.  Example:
<code class="example">			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')</code>
		Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		When there is no match an empty list is returned.

matchstr(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])			<b class="vimtag">*<a name="matchstr()">matchstr()</a>*</b>
		Same as |<a href="eval.html#match()">match()</a>|, but return the matched string.  Example:
<code class="example">			:echo matchstr("testing", "ing")</code>
		results in "ing".
		When there is no match "" is returned.
		The <code class="special">{start}</code>, if given, has the same meaning as for |<a href="eval.html#match()">match()</a>|.
<code class="example">			:echo matchstr("testing", "ing", 2)</code>
&lt;		results in "ing".
<code class="example">			:echo matchstr("testing", "ing", 5)</code>
		result is "".
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| then the matching item is returned.
		The type isn't changed, it's not necessarily a String.

matchstrpos(<code class="special">{expr}</code>, <code class="special">{pat}</code>[, <code class="special">{start}</code>[, <code class="special">{count}</code>]])		<b class="vimtag">*<a name="matchstrpos()">matchstrpos()</a>*</b>
		Same as |<a href="eval.html#matchstr()">matchstr()</a>|, but return the matched string, the start
		position and the end position of the match.  Example:
<code class="example">			:echo matchstrpos("testing", "ing")</code>
		results in ["ing", 4, 7].
		When there is no match ["", -1, -1] is returned.
		The <code class="special">{start}</code>, if given, has the same meaning as for |<a href="eval.html#match()">match()</a>|.
<code class="example">			:echo matchstrpos("testing", "ing", 2)</code>
&lt;		results in ["ing", 4, 7].
<code class="example">			:echo matchstrpos("testing", "ing", 5)</code>
		result is ["", -1, -1].
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| then the matching item, the index
		of first item where <code class="special">{pat}</code> matches, the start position and the
		end position of the match are returned.
<code class="example">			:echo matchstrpos([1, '__x'], '\a')</code>
		result is ["x", 1, 2, 3].
		The type isn't changed, it's not necessarily a String.

							<b class="vimtag">*<a name="max()">max()</a>*</b>
max(<code class="special">{list}</code>)	Return the maximum value of all items in <code class="special">{list}</code>.
		If <code class="special">{list}</code> is not a list or one of the items in <code class="special">{list}</code> cannot
		be used as a Number this results in an error.
		An empty |<a href="eval.html#List">List</a>| results in zero.

							<b class="vimtag">*<a name="min()">min()</a>*</b>
min(<code class="special">{list}</code>)	Return the minimum value of all items in <code class="special">{list}</code>.
		If <code class="special">{list}</code> is not a list or one of the items in <code class="special">{list}</code> cannot
		be used as a Number this results in an error.
		An empty |<a href="eval.html#List">List</a>| results in zero.

							<b class="vimtag">*<a name="mkdir()">mkdir()</a>*</b> <b class="vimtag">*<a name="E739">E739</a>*</b>
mkdir(<code class="special">{name}</code> [, <code class="special">{path}</code> [, <code class="special">{prot}</code>]])
		Create directory <code class="special">{name}</code>.
		If <code class="special">{path}</code> is "p" then intermediate directories are created as
		necessary.  Otherwise it must be "".
		If <code class="special">{prot}</code> is given it is used to set the protection bits of
		the new directory.  The default is 0755 (rwxr-xr-x: r/w for
		the user readable for others).	Use 0700 to make it unreadable
		for others.  This is only used for the last part of <code class="special">{name}</code>.
		Thus if you create /tmp/foo/bar then /tmp/foo will be created
		with 0755.
		Example:
<code class="example">			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)</code>
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.
		Not available on all systems.  To check use:
<code class="example">			:if exists("*mkdir")</code>

							<b class="vimtag">*<a name="mode()">mode()</a>*</b>
mode([expr])	Return a string that indicates the current mode.
		If [expr] is supplied and it evaluates to a non-zero Number or
		a non-empty String (|<a href="eval.html#non-zero-arg">non-zero-arg</a>|), then the full mode is
		returned, otherwise only the first letter is returned.  <code class="note">Note</code>
		that " " and "0" are also non-empty strings.

			n	Normal
			no	Operator-pending
			v	Visual by character
			V	Visual by line
			<code class="keystroke">CTRL-V</code>	Visual blockwise
			s	Select by character
			S	Select by line
			<code class="keystroke">CTRL-S</code>	Select blockwise
			i	Insert
			R	Replace |<a href="change.html#R">R</a>|
			Rv	Virtual Replace |<a href="change.html#gR">gR</a>|
			c	Command-line
			cv	Vim Ex mode |<a href="intro.html#gQ">gQ</a>|
			ce	Normal Ex mode |<a href="intro.html#Q">Q</a>|
			r	Hit-enter prompt
			rm	The -- more -- prompt
			r?	A |<a href="editing.html#:confirm">:confirm</a>| query of some sort
			!	Shell or external command is executing
		This is useful in the 'statusline' option or when used
		with |<a href="eval.html#remote_expr()">remote_expr()</a>| In most other places it always returns
		"c" or "n".
		Also see |<a href="eval.html#visualmode()">visualmode()</a>|.

mzeval(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="mzeval()">mzeval()</a>*</b>
		Evaluate MzScheme expression <code class="special">{expr}</code> and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are.
		Pairs (including lists and improper lists) and vectors are
		returned as Vim |<a href="eval.html#Lists">Lists</a>|.
		Hash tables are represented as Vim |<a href="eval.html#Dictionary">Dictionary</a>| type with keys
		converted to strings.
		All other types are converted to string with display function.
		Examples:
<code class="example">		    :mz (define l (list 1 2 3))</code>
<code class="example">		    :mz (define h (make-hash)) (hash-set! h "list" l)</code>
<code class="example">		    :echo mzeval("l")</code>
<code class="example">		    :echo mzeval("h")</code>

		{only available when compiled with the |<a href="various.html#+mzscheme">+mzscheme</a>| feature}

nextnonblank(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="nextnonblank()">nextnonblank()</a>*</b>
		Return the line number of the first line at or below <code class="special">{lnum}</code>
		that is not blank.  Example:
<code class="example">			if getline(nextnonblank(1)) =~ "Java"</code>
		When <code class="special">{lnum}</code> is invalid or there is no non-blank line at or
		below it, zero is returned.
		See also |<a href="eval.html#prevnonblank()">prevnonblank()</a>|.

nr2char(<code class="special">{expr}</code>[, <code class="special">{utf8}</code>])				<b class="vimtag">*<a name="nr2char()">nr2char()</a>*</b>
		Return a string with a single character, which has the number
		value <code class="special">{expr}</code>.  Examples:
<code class="example">			nr2char(64)		returns "@"</code>
<code class="example">			nr2char(32)		returns " "</code>
		When <code class="special">{utf8}</code> is omitted or zero, the current 'encoding' is used.
		Example for "utf-8":
<code class="example">			nr2char(300)		returns I with bow character</code>
		With <code class="special">{utf8}</code> set to 1, always return utf-8 characters.
		<code class="note">Note</code> that a NUL character in the file is specified with
		nr2char(10), because NULs are represented with newline
		characters.  nr2char(0) is a real NUL and terminates the
		string, thus results in an empty string.

or(<code class="special">{expr}</code>, <code class="special">{expr}</code>)					<b class="vimtag">*<a name="or()">or()</a>*</b>
		Bitwise OR on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example:
<code class="example">			:let bits = or(bits, 0x80)</code>
<code class="example"></code>
<code class="example"></code>
pathshorten(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="pathshorten()">pathshorten()</a>*</b>
		Shorten directory names in the path <code class="special">{expr}</code> and return the
		result.  The tail, the file name, is kept as-is.  The other
		components in the path are reduced to single letters.  Leading
		'~' and '.' characters are kept.  Example:
<code class="example">			:echo pathshorten('~/.vim/autoload/myfile.vim')</code>
<code class="section">			~/.v/a/myfile.vim </code>
		It doesn't matter if the path exists or not.

perleval(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="perleval()">perleval()</a>*</b>
		Evaluate Perl expression <code class="special">{expr}</code> in scalar context and return
		its result converted to Vim data structures. If value can't be
		converted, it is returned as a string Perl representation.
		<code class="note">Note:</code> If you want an array or hash, <code class="special">{expr}</code> must return a
		reference to it.
		Example:
<code class="example">			:echo perleval('[1 .. 4]')</code>
			[1, 2, 3, 4]
		{only available when compiled with the |<a href="various.html#+perl">+perl</a>| feature}

pow(<code class="special">{x}</code>, <code class="special">{y}</code>)						<b class="vimtag">*<a name="pow()">pow()</a>*</b>
		Return the power of <code class="special">{x}</code> to the exponent <code class="special">{y}</code> as a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{x}</code> and <code class="special">{y}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo pow(3, 3)</code>
&lt;			27.0
<code class="example">			:echo pow(2, 16)</code>
&lt;			65536.0
<code class="example">			:echo pow(32, 0.20)</code>
			2.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}

prevnonblank(<code class="special">{lnum}</code>)					<b class="vimtag">*<a name="prevnonblank()">prevnonblank()</a>*</b>
		Return the line number of the first line at or above <code class="special">{lnum}</code>
		that is not blank.  Example:
<code class="example">			let ind = indent(prevnonblank(v:lnum - 1))</code>
		When <code class="special">{lnum}</code> is invalid or there is no non-blank line at or
		above it, zero is returned.
		Also see |<a href="eval.html#nextnonblank()">nextnonblank()</a>|.


printf(<code class="special">{fmt}</code>, <code class="special">{expr1}</code> ...)				<b class="vimtag">*<a name="printf()">printf()</a>*</b>
		Return a String with <code class="special">{fmt}</code>, where "%" items are replaced by
		the formatted form of their respective arguments.  Example:
<code class="example">			printf("%4d: E%d %.30s", lnum, errno, msg)</code>
		May result in:
<code class="section">			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" </code>

		Often used items are:
		  %s	string
		  %6S	string right-aligned in 6 display cells
		  %6s	string right-aligned in 6 bytes
		  %.9s	string truncated to 9 bytes
		  %c	single byte
		  %d	decimal number
		  %5d	decimal number padded with spaces to 5 characters
		  %x	hex number
		  %04x	hex number padded with zeros to at least 4 characters
		  %X	hex number using upper case letters
		  %o	octal number
		  %f	floating point number in the form 123.456
		  %e	floating point number in the form 1.234e3
		  %E	floating point number in the form 1.234E3
		  %g	floating point number, as %f or %e depending on value
		  %G	floating point number, as %f or %E depending on value
		  %%	the % character itself

		Conversion specifications start with '%' and end with the
		conversion type.  All other characters are copied unchanged to
		the result.

		The "%" starts a conversion specification.  The following
		arguments appear in sequence:

			%  [flags]  [field-width]  [.precision]  type

		flags
			Zero or more of the following flags:

		    #	      The value should be converted to an "alternate
			      form".  For c, d, and s conversions, this option
			      has no effect.  For o conversions, the precision
			      of the number is increased to force the first
			      character of the output string to a zero (except
			      if a zero value is printed with an explicit
			      precision of zero).
			      For x and X conversions, a non-zero result has
			      the string "0x" (or "0X" for X conversions)
			      prepended to it.

		    0 (zero)  Zero padding.  For all conversions the converted
			      value is padded on the left with zeros rather
			      than blanks.  If a precision is given with a
			      numeric conversion (d, o, x, and X), the 0 flag
			      is ignored.

		    -	      A negative field width flag; the converted value
			      is to be left adjusted on the field boundary.
			      The converted value is padded on the right with
			      blanks, rather than on the left with blanks or
			      zeros.  A - overrides a 0 if both are given.

		    ' ' (space)  A blank should be left before a positive
			      number produced by a signed conversion (d).

		    +	      A sign must always be placed before a number
			      produced by a signed conversion.	A + overrides
			      a space if both are used.

		field-width
			An optional decimal digit string specifying a minimum
			field width.  If the converted value has fewer bytes
			than the field width, it will be padded with spaces on
			the left (or right, if the left-adjustment flag has
			been given) to fill out the field width.

		.precision
			An optional precision, in the form of a period '.'
			followed by an optional digit string.  If the digit
			string is omitted, the precision is taken as zero.
			This gives the minimum number of digits to appear for
			d, o, x, and X conversions, or the maximum number of
			bytes to be printed from a string for s conversions.
			For floating point it is the number of digits after
			the decimal point.

		type
			A character that specifies the type of conversion to
			be applied, see below.

		A field width or precision, or both, may be indicated by an
		asterisk '*' instead of a digit string.  In this case, a
		Number argument supplies the field width or precision.	A
		negative field width is treated as a left adjustment flag
		followed by a positive field width; a negative precision is
		treated as though it were missing.  Example:
<code class="example">			:echo printf("%d: %.*s", nr, width, line)</code>
		This limits the length of the text used from "line" to
		"width" bytes.

		The conversion specifiers and their meanings are:

				<b class="vimtag">*<a name="printf-d">printf-d</a>*</b> <b class="vimtag">*<a name="printf-o">printf-o</a>*</b> <b class="vimtag">*<a name="printf-x">printf-x</a>*</b> <b class="vimtag">*<a name="printf-X">printf-X</a>*</b>
		doxX	The Number argument is converted to signed decimal
			(d), unsigned octal (o), or unsigned hexadecimal (x
			and X) notation.  The letters "abcdef" are used for
			x conversions; the letters "ABCDEF" are used for X
			conversions.
			The precision, if any, gives the minimum number of
			digits that must appear; if the converted value
			requires fewer digits, it is padded on the left with
			zeros.
			In no case does a non-existent or small field width
			cause truncation of a numeric field; if the result of
			a conversion is wider than the field width, the field
			is expanded to contain the conversion result.

							<b class="vimtag">*<a name="printf-c">printf-c</a>*</b>
		c	The Number argument is converted to a byte, and the
			resulting character is written.

							<b class="vimtag">*<a name="printf-s">printf-s</a>*</b>
		s	The text of the String argument is used.  If a
			precision is specified, no more bytes than the number
			specified are used.
							<b class="vimtag">*<a name="printf-S">printf-S</a>*</b>
		S	The text of the String argument is used.  If a
			precision is specified, no more display cells than the
			number specified are used.  Without the |<a href="various.html#+multi_byte">+multi_byte</a>|
			feature works just like 's'.

							<b class="vimtag">*<a name="printf-f">printf-f</a>*</b> <b class="vimtag">*<a name="E807">E807</a>*</b>
		f	The Float argument is converted into a string of the
			form 123.456.  The precision specifies the number of
			digits after the decimal point.  When the precision is
			zero the decimal point is omitted.  When the precision
			is not specified 6 is used.  A really big number
			(out of range or dividing by zero) results in "inf".
			"0.0 / 0.0" results in "nan".
			Example:
<code class="example">				echo printf("%.2f", 12.115)</code>
				12.12
			<code class="note">Note</code> that roundoff depends on the system libraries.
			Use |<a href="eval.html#round()">round()</a>| when in doubt.

							<b class="vimtag">*<a name="printf-e">printf-e</a>*</b> <b class="vimtag">*<a name="printf-E">printf-E</a>*</b>
		e E	The Float argument is converted into a string of the
			form 1.234e+03 or 1.234E+03 when using 'E'.  The
			precision specifies the number of digits after the
			decimal point, like with 'f'.

							<b class="vimtag">*<a name="printf-g">printf-g</a>*</b> <b class="vimtag">*<a name="printf-G">printf-G</a>*</b>
		g G	The Float argument is converted like with 'f' if the
			value is between 0.001 (inclusive) and 10000000.0
			(exclusive).  Otherwise 'e' is used for 'g' and 'E'
			for 'G'.  When no precision is specified superfluous
			zeroes and '+' signs are removed, except for the zero
			immediately after the decimal point.  Thus 10000000.0
			results in 1.0e7.

							<b class="vimtag">*<a name="printf-%">printf-%</a>*</b>
		%	A '%' is written.  No argument is converted.  The
			complete conversion specification is "%%".

		When a Number argument is expected a String argument is also
		accepted and automatically converted.
		When a Float or String argument is expected a Number argument
		is also accepted and automatically converted.
		Any other argument type results in an error message.

							<b class="vimtag">*<a name="E766">E766</a>*</b> <b class="vimtag">*<a name="E767">E767</a>*</b>
		The number of <code class="special">{exprN}</code> arguments must exactly match the number
		of "%" items.  If there are not sufficient or too many
		arguments an error is given.  Up to 18 arguments can be used.


pumvisible()						<b class="vimtag">*<a name="pumvisible()">pumvisible()</a>*</b>
		Returns non-zero when the popup menu is visible, zero
		otherwise.  See |<a href="insert.html#ins-completion-menu">ins-completion-menu</a>|.
		This can be used to avoid some things that would remove the
		popup menu.

py3eval(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="py3eval()">py3eval()</a>*</b>
		Evaluate Python expression <code class="special">{expr}</code> and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are (strings are
		copied though, Unicode strings are additionally converted to
		'encoding').
		Lists are represented as Vim |<a href="eval.html#List">List</a>| type.
		Dictionaries are represented as Vim |<a href="eval.html#Dictionary">Dictionary</a>| type with
		keys converted to strings.
		{only available when compiled with the |<a href="various.html#+python3">+python3</a>| feature}

							<b class="vimtag">*<a name="E858">E858</a>*</b> <b class="vimtag">*<a name="E859">E859</a>*</b>
pyeval(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="pyeval()">pyeval()</a>*</b>
		Evaluate Python expression <code class="special">{expr}</code> and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are (strings are
		copied though).
		Lists are represented as Vim |<a href="eval.html#List">List</a>| type.
		Dictionaries are represented as Vim |<a href="eval.html#Dictionary">Dictionary</a>| type,
		non-string keys result in error.
		{only available when compiled with the |<a href="various.html#+python">+python</a>| feature}

							<b class="vimtag">*<a name="E726">E726</a>*</b> <b class="vimtag">*<a name="E727">E727</a>*</b>
range(<code class="special">{expr}</code> [, <code class="special">{max}</code> [, <code class="special">{stride}</code>]])				<b class="vimtag">*<a name="range()">range()</a>*</b>
		Returns a |<a href="eval.html#List">List</a>| with Numbers:
		- If only <code class="special">{expr}</code> is specified: [0, 1, ..., <code class="special">{expr}</code> - 1]
		- If <code class="special">{max}</code> is specified: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + 1, ..., <code class="special">{max}</code>]
		- If <code class="special">{stride}</code> is specified: [<code class="special">{expr}</code>, <code class="special">{expr}</code> + <code class="special">{stride}</code>, ...,
		  <code class="special">{max}</code>] (increasing <code class="special">{expr}</code> with <code class="special">{stride}</code> each time, not
		  producing a value past <code class="special">{max}</code>).
		When the maximum is one before the start the result is an
		empty list.  When the maximum is more than one before the
		start this is an error.
		Examples:
<code class="example">			range(4)		" [0, 1, 2, 3]</code>
<code class="example">			range(2, 4)		" [2, 3, 4]</code>
<code class="example">			range(2, 9, 3)		" [2, 5, 8]</code>
<code class="example">			range(2, -2, -1)	" [2, 1, 0, -1, -2]</code>
<code class="example">			range(0)		" []</code>
<code class="example">			range(2, 0)		" error!</code>

							<b class="vimtag">*<a name="readfile()">readfile()</a>*</b>
readfile(<code class="special">{fname}</code> [, <code class="special">{binary}</code> [, <code class="special">{max}</code>]])
		Read file <code class="special">{fname}</code> and return a |<a href="eval.html#List">List</a>|, each line of the file
		as an item.  Lines broken at NL characters.  Macintosh files
		separated with CR will result in a single long line (unless a
		NL appears somewhere).
		All NUL characters are replaced with a NL character.
		When <code class="special">{binary}</code> contains "b" binary mode is used:
		- When the last line ends in a NL an extra empty list item is
		  added.
		- No CR characters are removed.
		Otherwise:
		- CR characters that appear before a NL are removed.
		- Whether the last line ends in a NL or not does not matter.
		- When 'encoding' is Unicode any UTF-8 byte order mark is
		  removed from the text.
		When <code class="special">{max}</code> is given this specifies the maximum number of lines
		to be read.  Useful if you only want to check the first ten
		lines of a file:
<code class="example">			:for line in readfile(fname, '', 10)</code>
<code class="example">			:  if line =~ 'Date' |<code class="badlink"> echo line </code>| endif</code>
<code class="example">			:endfor</code>
		When <code class="special">{max}</code> is negative -<code class="special">{max}</code> lines from the end of the file
		are returned, or as many as there are.
		When <code class="special">{max}</code> is zero the result is an empty list.
		<code class="note">Note</code> that without <code class="special">{max}</code> the whole file is read into memory.
		Also <code class="note">note</code> that there is no recognition of encoding.  Read a
		file into a buffer if you need to.
		When the file can't be opened an error message is given and
		the result is an empty list.
		Also see |<a href="eval.html#writefile()">writefile()</a>|.

reltime([<code class="special">{start}</code> [, <code class="special">{end}</code>]])				<b class="vimtag">*<a name="reltime()">reltime()</a>*</b>
		Return an item that represents a time value.  The format of
		the item depends on the system.  It can be passed to
		|<a href="eval.html#reltimestr()">reltimestr()</a>| to convert it to a string  or |<a href="eval.html#reltimefloat()">reltimefloat()</a>|
		to convert to a Float.
		Without an argument it returns the current time.
		With one argument is returns the time passed since the time
		specified in the argument.
		With two arguments it returns the time passed between <code class="special">{start}</code>
		and <code class="special">{end}</code>.
		The <code class="special">{start}</code> and <code class="special">{end}</code> arguments must be values returned by
		reltime().
		{only available when compiled with the |<a href="various.html#+reltime">+reltime</a>| feature}

reltimefloat(<code class="special">{time}</code>)				<b class="vimtag">*<a name="reltimefloat()">reltimefloat()</a>*</b>
		Return a Float that represents the time value of <code class="special">{time}</code>.
		Example:
<code class="example">			let start = reltime()</code>
<code class="example">			call MyFunction()</code>
<code class="example">			let seconds = reltimefloat(reltime(start))</code>
		See the <code class="note">note</code> of reltimestr() about overhead.
		Also see |<a href="repeat.html#profiling">profiling</a>|.
		{only available when compiled with the |<a href="various.html#+reltime">+reltime</a>| feature}

reltimestr(<code class="special">{time}</code>)				<b class="vimtag">*<a name="reltimestr()">reltimestr()</a>*</b>
		Return a String that represents the time value of <code class="special">{time}</code>.
		This is the number of seconds, a dot and the number of
		microseconds.  Example:
<code class="example">			let start = reltime()</code>
<code class="example">			call MyFunction()</code>
<code class="example">			echo reltimestr(reltime(start))</code>
		<code class="note">Note</code> that overhead for the commands will be added to the time.
		The accuracy depends on the system.
		Leading spaces are used to make the string align nicely.  You
		can use split() to remove it.
<code class="example">			echo split(reltimestr(reltime(start)))[0]</code>
		Also see |<a href="repeat.html#profiling">profiling</a>|.
		{only available when compiled with the |<a href="various.html#+reltime">+reltime</a>| feature}

							<b class="vimtag">*<a name="remote_expr()">remote_expr()</a>*</b> <b class="vimtag">*<a name="E449">E449</a>*</b>
remote_expr(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
		Send the <code class="special">{string}</code> to <code class="special">{server}</code>.	The string is sent as an
		expression and the result is returned after evaluation.
		The result must be a String or a |<a href="eval.html#List">List</a>|.  A |<a href="eval.html#List">List</a>| is turned
		into a String by joining the items with a line break in
		between (not at the end), like with join(expr, "\n").
		If <code class="special">{idvar}</code> is present, it is taken as the name of a
		variable and a <code class="special">{serverid}</code> for later use with
		remote_read() is stored there.
		See also |<a href="remote.html#clientserver">clientserver</a>| |<a href="autocmd.html#RemoteReply">RemoteReply</a>|.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.
		{only available when compiled with the |<a href="various.html#+clientserver">+clientserver</a>| feature}
		<code class="note">Note:</code> Any errors will cause a local error message to be issued
		and the result will be the empty string.
		Examples:
<code class="example">			:echo remote_expr("gvim", "2+2")</code>
<code class="example">			:echo remote_expr("gvim1", "b:current_syntax")</code>


remote_foreground(<code class="special">{server}</code>)				<b class="vimtag">*<a name="remote_foreground()">remote_foreground()</a>*</b>
		Move the Vim server with the name <code class="special">{server}</code> to the foreground.
		This works like:
<code class="example">			remote_expr(<code class="special">{server}</code>, "foreground()")</code>
		Except that on Win32 systems the client does the work, to work
		around the problem that the OS doesn't always allow the server
		to bring itself to the foreground.
		<code class="note">Note:</code> This does not restore the window if it was minimized,
		like foreground() does.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.
		{only in the Win32, Athena, Motif and GTK GUI versions and the
		Win32 console version}


remote_peek(<code class="special">{serverid}</code> [, <code class="special">{retvar}</code>])		<b class="vimtag">*<a name="remote_peek()">remote_peek()</a>*</b>
		Returns a positive number if there are available strings
		from <code class="special">{serverid}</code>.  Copies any reply string into the variable
		<code class="special">{retvar}</code> if specified.	<code class="special">{retvar}</code> must be a string with the
		name of a variable.
		Returns zero if none are available.
		Returns -1 if something is wrong.
		See also |<a href="remote.html#clientserver">clientserver</a>|.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.
		{only available when compiled with the |<a href="various.html#+clientserver">+clientserver</a>| feature}
		Examples:
<code class="example">			:let repl = ""</code>
<code class="example">			:echo "PEEK: ".remote_peek(id, "repl").": ".repl</code>
<code class="example"></code>
remote_read(<code class="special">{serverid}</code>)				<b class="vimtag">*<a name="remote_read()">remote_read()</a>*</b>
		Return the oldest available reply from <code class="special">{serverid}</code> and consume
		it.  It blocks until a reply is available.
		See also |<a href="remote.html#clientserver">clientserver</a>|.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.
		{only available when compiled with the |<a href="various.html#+clientserver">+clientserver</a>| feature}
		Example:
<code class="example">			:echo remote_read(id)</code>

							<b class="vimtag">*<a name="remote_send()">remote_send()</a>*</b> <b class="vimtag">*<a name="E241">E241</a>*</b>
remote_send(<code class="special">{server}</code>, <code class="special">{string}</code> [, <code class="special">{idvar}</code>])
		Send the <code class="special">{string}</code> to <code class="special">{server}</code>.	The string is sent as input
		keys and the function returns immediately.  At the Vim server
		the keys are not mapped |<a href="map.html#:map">:map</a>|.
		If <code class="special">{idvar}</code> is present, it is taken as the name of a variable
		and a <code class="special">{serverid}</code> for later use with remote_read() is stored
		there.
		See also |<a href="remote.html#clientserver">clientserver</a>| |<a href="autocmd.html#RemoteReply">RemoteReply</a>|.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.
		{only available when compiled with the |<a href="various.html#+clientserver">+clientserver</a>| feature}
		<code class="note">Note:</code> Any errors will be reported in the server and may mess
		up the display.
		Examples:
<code class="example">		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").</code>
<code class="example">		 \ remote_read(serverid)</code>
<code class="example"></code>
<code class="example">		:autocmd NONE RemoteReply *</code>
<code class="example">		 \ echo remote_read(expand("<code class="special">&lt;amatch&gt;</code>"))</code>
<code class="example">		:echo remote_send("gvim", ":sleep 10 | echo ".</code>
<code class="example">		 \ 'server2client(expand("<code class="special">&lt;client&gt;</code>"), "HELLO")<code class="special">&lt;CR&gt;</code>')</code>

remove(<code class="special">{list}</code>, <code class="special">{idx}</code> [, <code class="special">{end}</code>])				<b class="vimtag">*<a name="remove()">remove()</a>*</b>
		Without <code class="special">{end}</code>: Remove the item at <code class="special">{idx}</code> from |<a href="eval.html#List">List</a>| <code class="special">{list}</code> and
		return the item.
		With <code class="special">{end}</code>: Remove items from <code class="special">{idx}</code> to <code class="special">{end}</code> (inclusive) and
		return a List with these items.  When <code class="special">{idx}</code> points to the same
		item as <code class="special">{end}</code> a list with one item is returned.  When <code class="special">{end}</code>
		points to an item before <code class="special">{idx}</code> this is an error.
		See |<a href="eval.html#list-index">list-index</a>| for possible values of <code class="special">{idx}</code> and <code class="special">{end}</code>.
		Example:
<code class="example">			:echo "last item: " . remove(mylist, -1)</code>
<code class="example">			:call remove(mylist, 0, 9)</code>
remove(<code class="special">{dict}</code>, <code class="special">{key}</code>)
		Remove the entry from <code class="special">{dict}</code> with key <code class="special">{key}</code>.  Example:
<code class="example">			:echo "removed " . remove(dict, "one")</code>
		If there is no <code class="special">{key}</code> in <code class="special">{dict}</code> this is an error.

		Use |<a href="eval.html#delete()">delete()</a>| to remove a file.

rename(<code class="special">{from}</code>, <code class="special">{to}</code>)					<b class="vimtag">*<a name="rename()">rename()</a>*</b>
		Rename the file by the name <code class="special">{from}</code> to the name <code class="special">{to}</code>.  This
		should also work to move files across file systems.  The
		result is a Number, which is 0 if the file was renamed
		successfully, and non-zero when the renaming failed.
		<code class="note">NOTE:</code> If <code class="special">{to}</code> exists it is overwritten without warning.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.

repeat(<code class="special">{expr}</code>, <code class="special">{count}</code>)					<b class="vimtag">*<a name="repeat()">repeat()</a>*</b>
		Repeat <code class="special">{expr}</code> <code class="special">{count}</code> times and return the concatenated
		result.  Example:
<code class="example">			:let separator = repeat('-', 80)</code>
		When <code class="special">{count}</code> is zero or negative the result is empty.
		When <code class="special">{expr}</code> is a |<a href="eval.html#List">List</a>| the result is <code class="special">{expr}</code> concatenated
		<code class="special">{count}</code> times.	Example:
<code class="example">			:let longlist = repeat(['a', 'b'], 3)</code>
		Results in ['a', 'b', 'a', 'b', 'a', 'b'].


resolve(<code class="special">{filename}</code>)					<b class="vimtag">*<a name="resolve()">resolve()</a>*</b> <b class="vimtag">*<a name="E655">E655</a>*</b>
		On MS-Windows, when <code class="special">{filename}</code> is a shortcut (a .lnk file),
		returns the path the shortcut points to in a simplified form.
		On Unix, repeat resolving symbolic links in all path
		components of <code class="special">{filename}</code> and return the simplified result.
		To cope with link cycles, resolving of symbolic links is
		stopped after 100 iterations.
		On other systems, return the simplified <code class="special">{filename}</code>.
		The simplification step is done as by |<a href="eval.html#simplify()">simplify()</a>|.
		resolve() keeps a leading path component specifying the
		current directory (provided the result is still a relative
		path name) and also keeps a trailing path separator.

							<b class="vimtag">*<a name="reverse()">reverse()</a>*</b>
reverse(<code class="special">{list}</code>)	Reverse the order of items in <code class="special">{list}</code> in-place.	Returns
		<code class="special">{list}</code>.
		If you want a list to remain unmodified make a copy first:
<code class="example">			:let revlist = reverse(copy(mylist))</code>
<code class="example"></code>
round(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="round()">round()</a>*</b>
		Round off <code class="special">{expr}</code> to the nearest integral value and return it
		as a |<a href="eval.html#Float">Float</a>|.  If <code class="special">{expr}</code> lies halfway between two integral
		values, then use the larger one (away from zero).
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			echo round(0.456)</code>
&lt;			0.0
<code class="example">			echo round(4.5)</code>
&lt;			5.0
<code class="example">			echo round(-4.5)</code>
			-5.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}

screenattr(row, col)						<b class="vimtag">*<a name="screenattr()">screenattr()</a>*</b>
		Like screenchar(), but return the attribute.  This is a rather
		arbitrary number that can only be used to compare to the
		attribute at other positions.

screenchar(row, col)						<b class="vimtag">*<a name="screenchar()">screenchar()</a>*</b>
		The result is a Number, which is the character at position
		[row, col] on the screen.  This works for every possible
		screen position, also status lines, window separators and the
		command line.  The top left position is row one, column one
		The character excludes composing characters.  For double-byte
		encodings it may only be the first byte.
		This is mainly to be used for testing.
		Returns -1 when row or col is out of range.

screencol()							<b class="vimtag">*<a name="screencol()">screencol()</a>*</b>
		The result is a Number, which is the current screen column of
		the cursor. The leftmost column has number 1.
		This function is mainly used for testing.

		<code class="note">Note:</code> Always returns the current screen column, thus if used
		in a command (e.g. ":echo screencol()") it will return the
		column inside the command line, which is 1 when the command is
		executed. To get the cursor position in the file use one of
		the following mappings:
<code class="example">			nnoremap <code class="special">&lt;expr&gt;</code> GG ":echom ".screencol()."\n"</code>
<code class="example">			nnoremap <code class="special">&lt;silent&gt;</code> GG :echom screencol()<code class="special">&lt;CR&gt;</code></code>

screenrow()							<b class="vimtag">*<a name="screenrow()">screenrow()</a>*</b>
		The result is a Number, which is the current screen row of the
		cursor.  The top line has number one.
		This function is mainly used for testing.

		<code class="note">Note:</code> Same restrictions as with |<a href="eval.html#screencol()">screencol()</a>|.

search(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])	<b class="vimtag">*<a name="search()">search()</a>*</b>
		Search for regexp pattern <code class="special">{pattern}</code>.  The search starts at the
		cursor position (you can use |<a href="eval.html#cursor()">cursor()</a>| to set it).

		When a match has been found its line number is returned.
		If there is no match a 0 is returned and the cursor doesn't
		move.  No error message is given.

		<code class="special">{flags}</code> is a String, which can contain these character flags:
		'b'	search Backward instead of forward
		'c'	accept a match at the Cursor position
		'e'	move to the End of the match
		'n'	do Not move the cursor
		'p'	return number of matching sub-Pattern (see below)
		's'	Set the ' mark at the previous location of the cursor
		'w'	Wrap around the end of the file
		'W'	don't Wrap around the end of the file
		'z'	start searching at the cursor column instead of zero
		If neither 'w' or 'W' is given, the 'wrapscan' option applies.

		If the 's' flag is supplied, the ' mark is set, only if the
		cursor is moved. The 's' flag cannot be combined with the 'n'
		flag.

		'ignorecase', 'smartcase' and 'magic' are used.

		When the 'z' flag is not given, searching always starts in
		column zero and then matches before the cursor are skipped.
		When the 'c' flag is present in 'cpo' the next search starts
		after the match.  Without the 'c' flag the next search starts
		one column further.

		When the <code class="special">{stopline}</code> argument is given then the search stops
		after searching this line.  This is useful to restrict the
		search to a range of lines.  Examples:
<code class="example">			let match = search('(', 'b', line("w0"))</code>
<code class="example">			let end = search('END', '', line("w$"))</code>
		When <code class="special">{stopline}</code> is used and it is not zero this also implies
		that the search does not wrap around the end of the file.
		A zero value is equal to not giving the argument.

		When the <code class="special">{timeout}</code> argument is given the search stops when
		more than this many milliseconds have passed.	Thus when
		<code class="special">{timeout}</code> is 500 the search stops after half a second.
		The value must not be negative.  A zero value is like not
		giving the argument.
		{only available when compiled with the |<a href="various.html#+reltime">+reltime</a>| feature}

							<b class="vimtag">*<a name="search()-sub-match">search()-sub-match</a>*</b>
		With the 'p' flag the returned value is one more than the
		first sub-match in \(\).  One if none of them matched but the
		whole pattern did match.
		To get the column number too use |<a href="eval.html#searchpos()">searchpos()</a>|.

		The cursor will be positioned at the match, unless the 'n'
		flag is used.

		Example (goes over all files in the argument list):
<code class="example">		    :let n = 1</code>
<code class="example">		    :while n &lt;= argc()	    " loop over all files in arglist</code>
<code class="example">		    :  exe "argument " . n</code>
<code class="example">		    :  " start at the last char in the file and wrap for the</code>
<code class="example">		    :  " first search to find match at start of file</code>
<code class="example">		    :  normal G$</code>
<code class="example">		    :  let flags = "w"</code>
<code class="example">		    :  while search("foo", flags) &gt; 0</code>
<code class="example">		    :	 s/foo/bar/g</code>
<code class="example">		    :	 let flags = "W"</code>
<code class="example">		    :  endwhile</code>
<code class="example">		    :  update		    " write the file if modified</code>
<code class="example">		    :  let n = n + 1</code>
<code class="example">		    :endwhile</code>

		Example for using some flags:
<code class="example">		    :echo search('\&lt;if\|<code class="badlink">\(else\)\</code>|\(endif\)', 'ncpe')</code>
		This will search for the keywords "if", "else", and "endif"
		under or after the cursor.  Because of the 'p' flag, it
		returns 1, 2, or 3 depending on which keyword is found, or 0
		if the search fails.  With the cursor on the first word of the
		line:
		    if (foo == 0) |<code class="badlink"> let foo = foo + 1 </code>|<code class="section"> endif </code>
		the function returns 1.  Without the 'c' flag, the function
		finds the "endif" and returns 3.  The same thing happens
		without the 'e' flag if the cursor is on the "f" of "if".
		The 'n' flag tells the function not to move the cursor.


searchdecl(<code class="special">{name}</code> [, <code class="special">{global}</code> [, <code class="special">{thisblock}</code>]])			<b class="vimtag">*<a name="searchdecl()">searchdecl()</a>*</b>
		Search for the declaration of <code class="special">{name}</code>.

		With a non-zero <code class="special">{global}</code> argument it works like |<a href="pattern.html#gD">gD</a>|, find
		first match in the file.  Otherwise it works like |<a href="pattern.html#gd">gd</a>|, find
		first match in the function.

		With a non-zero <code class="special">{thisblock}</code> argument matches in a <code class="special">{}</code> block
		that ends before the cursor position are ignored.  Avoids
		finding variable declarations only valid in another scope.

		Moves the cursor to the found match.
		Returns zero for success, non-zero for failure.
		Example:
<code class="example">			if searchdecl('myvar') == 0</code>
<code class="example">			   echo getline('.')</code>
<code class="example">			endif</code>

							<b class="vimtag">*<a name="searchpair()">searchpair()</a>*</b>
searchpair(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
				[, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
		Search for the match of a nested start-end pair.  This can be
		used to find the "endif" that matches an "if", while other
		if/endif pairs in between are ignored.
		The search starts at the cursor.  The default is to search
		forward, include 'b' in <code class="special">{flags}</code> to search backward.
		If a match is found, the cursor is positioned at it and the
		line number is returned.  If no match is found 0 or -1 is
		returned and the cursor doesn't move.  No error message is
		given.

		<code class="special">{start}</code>, <code class="special">{middle}</code> and <code class="special">{end}</code> are patterns, see |<a href="pattern.html#pattern">pattern</a>|.  They
		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
		<code class="special">{middle}</code> is not empty, it is found when searching from either
		direction, but only when not in a nested start-end pair.  A
		typical use is:
<code class="example">			searchpair('\<code class="special">&lt;if\&gt;</code>', '\<code class="special">&lt;else\&gt;</code>', '\<code class="special">&lt;endif\&gt;</code>')</code>
		By leaving <code class="special">{middle}</code> empty the "else" is skipped.

		<code class="special">{flags}</code> 'b', 'c', 'n', 's', 'w' and 'W' are used like with
		|<a href="eval.html#search()">search()</a>|.  Additionally:
		'r'	Repeat until no more matches found; will find the
			outer pair.  Implies the 'W' flag.
		'm'	Return number of matches instead of line number with
			the match; will be &gt; 1 when 'r' is used.
		<code class="note">Note:</code> it's nearly always a good idea to use the 'W' flag, to
		avoid wrapping around the end of the file.

		When a match for <code class="special">{start}</code>, <code class="special">{middle}</code> or <code class="special">{end}</code> is found, the
		<code class="special">{skip}</code> expression is evaluated with the cursor positioned on
		the start of the match.  It should return non-zero if this
		match is to be skipped.  E.g., because it is inside a comment
		or a string.
		When <code class="special">{skip}</code> is omitted or empty, every match is accepted.
		When evaluating <code class="special">{skip}</code> causes an error the search is aborted
		and -1 returned.

		For <code class="special">{stopline}</code> and <code class="special">{timeout}</code> see |<a href="eval.html#search()">search()</a>|.

		The value of 'ignorecase' is used.  'magic' is ignored, the
		patterns are used like it's on.

		The search starts exactly at the cursor.  A match with
		<code class="special">{start}</code>, <code class="special">{middle}</code> or <code class="special">{end}</code> at the next character, in the
		direction of searching, is the first one found.  Example:
<code class="example">			if 1</code>
<code class="example">			  if 2</code>
<code class="example">			  endif 2</code>
<code class="example">			endif 1</code>
		When starting at the "if 2", with the cursor on the "i", and
		searching forwards, the "endif 2" is found.  When starting on
		the character just before the "if 2", the "endif 1" will be
		found.	That's because the "if 2" will be found first, and
		then this is considered to be a nested if/endif from "if 2" to
		"endif 2".
		When searching backwards and <code class="special">{end}</code> is more than one character,
		it may be useful to put "\zs" at the end of the pattern, so
		that when the cursor is inside a match with the end it finds
		the matching start.

		Example, to find the "endif" command in a Vim script:
<code class="example"></code>
<code class="example">	:echo searchpair('\<code class="special">&lt;if\&gt;</code>', '\<code class="special">&lt;el\%[seif]\&gt;</code>', '\<code class="special">&lt;en\%[dif]\&gt;</code>', 'W',</code>
<code class="example">			\ 'getline(".") =~ "^\\s*\""')</code>
<code class="example"></code>
		The cursor must be at or after the "if" for which a match is
		to be found.  <code class="note">Note</code> that single-quote strings are used to avoid
		having to double the backslashes.  The skip expression only
		catches comments at the start of a line, not after a command.
		Also, a word "en" or "if" halfway a line is considered a
		match.
		Another example, to search for the matching "<code class="special">{" of a "}</code>":
<code class="example"></code>
<code class="example">	:echo searchpair('<code class="special">{', '', '}</code>', 'bW')</code>
<code class="example"></code>
		This works when the cursor is at or before the "}" for which a
		match is to be found.  To reject matches that syntax
		highlighting recognized as strings:
<code class="example"></code>
<code class="example">	:echo searchpair('<code class="special">{', '', '}</code>', 'bW',</code>
<code class="example">	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')</code>

							<b class="vimtag">*<a name="searchpairpos()">searchpairpos()</a>*</b>
searchpairpos(<code class="special">{start}</code>, <code class="special">{middle}</code>, <code class="special">{end}</code> [, <code class="special">{flags}</code> [, <code class="special">{skip}</code>
				[, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]]])
		Same as |<a href="eval.html#searchpair()">searchpair()</a>|, but returns a |<a href="eval.html#List">List</a>| with the line and
		column position of the match. The first element of the |<a href="eval.html#List">List</a>|
		is the line number and the second element is the byte index of
		the column position of the match.  If no match is found,
		returns [0, 0].
<code class="example"></code>
<code class="example">			:let [lnum,col] = searchpairpos('<code class="special">{', '', '}</code>', 'n')</code>

		See |<a href="tips.html#match-parens">match-parens</a>| for a bigger and more useful example.

searchpos(<code class="special">{pattern}</code> [, <code class="special">{flags}</code> [, <code class="special">{stopline}</code> [, <code class="special">{timeout}</code>]]])	<b class="vimtag">*<a name="searchpos()">searchpos()</a>*</b>
		Same as |<a href="eval.html#search()">search()</a>|, but returns a |<a href="eval.html#List">List</a>| with the line and
		column position of the match. The first element of the |<a href="eval.html#List">List</a>|
		is the line number and the second element is the byte index of
		the column position of the match. If no match is found,
		returns [0, 0].
		Example:
<code class="example">	:let [lnum, col] = searchpos('mypattern', 'n')</code>
<code class="example"></code>
		When the 'p' flag is given then there is an extra item with
		the sub-pattern match number |<a href="eval.html#search()-sub-match">search()-sub-match</a>|.  Example:
<code class="example">	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')</code>
		In this example "submatch" is 2 when a lowercase letter is
		found |<a href="pattern.html#%2F\l">/\l</a>|, 3 when an uppercase letter is found |<a href="pattern.html#%2F\u">/\u</a>|.

server2client(<code class="special">{clientid}</code>, <code class="special">{string}</code>)			<b class="vimtag">*<a name="server2client()">server2client()</a>*</b>
		Send a reply string to <code class="special">{clientid}</code>.  The most recent <code class="special">{clientid}</code>
		that sent a string can be retrieved with expand("<code class="special">&lt;client&gt;</code>").
		{only available when compiled with the |<a href="various.html#+clientserver">+clientserver</a>| feature}
		<code class="note">Note:</code>
		This id has to be stored before the next command can be
		received.  I.e. before returning from the received command and
		before calling any commands that waits for input.
		See also |<a href="remote.html#clientserver">clientserver</a>|.
		Example:
<code class="example">			:echo server2client(expand("<code class="special">&lt;client&gt;</code>"), "HELLO")</code>

serverlist()					<b class="vimtag">*<a name="serverlist()">serverlist()</a>*</b>
		Return a list of available server names, one per line.
		When there are no servers or the information is not available
		an empty string is returned.  See also |<a href="remote.html#clientserver">clientserver</a>|.
		{only available when compiled with the |<a href="various.html#+clientserver">+clientserver</a>| feature}
		Example:
<code class="example">			:echo serverlist()</code>

setbufvar(<code class="special">{expr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)			<b class="vimtag">*<a name="setbufvar()">setbufvar()</a>*</b>
		Set option or local variable <code class="special">{varname}</code> in buffer <code class="special">{expr}</code> to
		<code class="special">{val}</code>.
		This also works for a global or local window option, but it
		doesn't work for a global or local window variable.
		For a local window option the global value is unchanged.
		For the use of <code class="special">{expr}</code>, see |<a href="eval.html#bufname()">bufname()</a>| above.
		<code class="note">Note</code> that the variable name without "b:" must be used.
		Examples:
<code class="example">			:call setbufvar(1, "&amp;mod", 1)</code>
<code class="example">			:call setbufvar("todo", "myvar", "foobar")</code>
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.

setcharsearch(<code class="special">{dict}</code>)					<b class="vimtag">*<a name="setcharsearch()">setcharsearch()</a>*</b>
		Set the current character search information to <code class="special">{dict}</code>,
		which contains one or more of the following entries:

		    char	character which will be used for a subsequent
				|<a href="motion.html#,">,</a>| or |<a href="motion.html#;">;</a>| command; an empty string clears the
				character search
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |<a href="motion.html#t">t</a>| or |<a href="motion.html#T">T</a>|
				character search, 0 for an |<a href="motion.html#f">f</a>| or |<a href="motion.html#F">F</a>|
				character search

		This can be useful to save/restore a user's character search
		from a script:
<code class="example">			:let prevsearch = getcharsearch()</code>
<code class="example">			:" Perform a command which clobbers user's search</code>
<code class="example">			:call setcharsearch(prevsearch)</code>
		Also see |<a href="eval.html#getcharsearch()">getcharsearch()</a>|.

setcmdpos(<code class="special">{pos}</code>)					<b class="vimtag">*<a name="setcmdpos()">setcmdpos()</a>*</b>
		Set the cursor position in the command line to byte position
		<code class="special">{pos}</code>.	The first position is 1.
		Use |<a href="eval.html#getcmdpos()">getcmdpos()</a>| to obtain the current position.
		Only works while editing the command line, thus you must use
		|<a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>|, |<a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>| or |<a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a>| with '='.  For
		|<a href="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</a>| and |<a href="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</a>| with '=' the position is
		set after the command line is set to the expression.  For
		|<a href="cmdline.html#c_CTRL-R_%20">c_CTRL-R_=</a>| it is set after evaluating the expression but
		before inserting the resulting text.
		When the number is too big the cursor is put at the end of the
		line.  A number smaller than one has undefined results.
		Returns 0 when successful, 1 when not editing the command
		line.

setfperm(<code class="special">{fname}</code>, <code class="special">{mode}</code>)				<b class="vimtag">*<a name="setfperm()">setfperm()</a>*</b> <b class="vimtag">*<a name="chmod">chmod</a>*</b>
		Set the file permissions for <code class="special">{fname}</code> to <code class="special">{mode}</code>.
		<code class="special">{mode}</code> must be a string with 9 characters.  It is of the form
		"rwxrwxrwx", where each group of "rwx" flags represent, in
		turn, the permissions of the owner of the file, the group the
		file belongs to, and other users.  A '-' character means the
		permission is off, any other character means on.  Multi-byte
		characters are not supported.

		For example "rw-r-----" means read-write for the user,
		readable by the group, not accessible by others.  "xx-x-----"
		would do the same thing.

		Returns non-zero for success, zero for failure.

		To read permissions see |<a href="eval.html#getfperm()">getfperm()</a>|.


setline(<code class="special">{lnum}</code>, <code class="special">{text}</code>)					<b class="vimtag">*<a name="setline()">setline()</a>*</b>
		Set line <code class="special">{lnum}</code> of the current buffer to <code class="special">{text}</code>.  To insert
		lines use |<a href="eval.html#append()">append()</a>|.
		<code class="special">{lnum}</code> is used like with |<a href="eval.html#getline()">getline()</a>|.
		When <code class="special">{lnum}</code> is just below the last line the <code class="special">{text}</code> will be
		added as a new line.
		If this succeeds, 0 is returned.  If this fails (most likely
		because <code class="special">{lnum}</code> is invalid) 1 is returned.  Example:
<code class="example">			:call setline(5, strftime("%c"))</code>
		When <code class="special">{text}</code> is a |<a href="eval.html#List">List</a>| then line <code class="special">{lnum}</code> and following lines
		will be set to the items in the list.  Example:
<code class="example">			:call setline(5, ['aaa', 'bbb', 'ccc'])</code>
&lt;		This is equivalent to:
<code class="example">			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]</code>
<code class="example">			:  call setline(n, l)</code>
<code class="example">			:endfor</code>
		<code class="note">Note:</code> The '[ and '] marks are not set.

setloclist(<code class="special">{nr}</code>, <code class="special">{list}</code> [, <code class="special">{action}</code>])			<b class="vimtag">*<a name="setloclist()">setloclist()</a>*</b>
		Create or replace or add to the location list for window <code class="special">{nr}</code>.
		When <code class="special">{nr}</code> is zero the current window is used. For a location
		list window, the displayed location list is modified.  For an
		invalid window number <code class="special">{nr}</code>, -1 is returned.
		Otherwise, same as |<a href="eval.html#setqflist()">setqflist()</a>|.
		Also see |<a href="quickfix.html#location-list">location-list</a>|.

setmatches(<code class="special">{list}</code>)					<b class="vimtag">*<a name="setmatches()">setmatches()</a>*</b>
		Restores a list of matches saved by |<a href="eval.html#getmatches()">getmatches()</a>|.  Returns 0
		if successful, otherwise -1.  All current matches are cleared
		before the list is restored.  See example for |<a href="eval.html#getmatches()">getmatches()</a>|.

							<b class="vimtag">*<a name="setpos()">setpos()</a>*</b>
setpos(<code class="special">{expr}</code>, <code class="special">{list}</code>)
		Set the position for <code class="special">{expr}</code>.  Possible values:
			.	the cursor
			'x	mark x

		<code class="special">{list}</code> must be a |<a href="eval.html#List">List</a>| with four or five numbers:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" is the buffer number.	Zero can be used for the
		current buffer.  Setting the cursor is only possible for
		the current buffer.  To set a mark in another buffer you can
		use the |<a href="eval.html#bufnr()">bufnr()</a>| function to turn a file name into a buffer
		number.
		Does not change the jumplist.

		"lnum" and "col" are the position in the buffer.  The first
		column is 1.  Use a zero "lnum" to delete a mark.  If "col" is
		smaller than 1 then 1 is used.

		The "off" number is only used when 'virtualedit' is set. Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <code class="special">&lt;Tab&gt;</code> or after the last
		character.

		The "curswant" number is only used when setting the cursor
		position.  It sets the preferred column for when moving the
		cursor vertically.  When the "curswant" number is missing the
		preferred column is not set.  When it is present and setting a
		mark position it is not used.

		<code class="note">Note</code> that for '<code class="special">&lt; and '&gt;</code> changing the line number may result in
		the marks to be effectively be swapped, so that '&lt; is always
		before '&gt;.

		Returns 0 when the position could be set, -1 otherwise.
		An error message is given if <code class="special">{expr}</code> is invalid.

		Also see |<a href="eval.html#getpos()">getpos()</a>| and |<a href="eval.html#getcurpos()">getcurpos()</a>|.

		This does not restore the preferred column for moving
		vertically; if you set the cursor position with this, |<a href="motion.html#j">j</a>| and
		|<a href="motion.html#k">k</a>| motions will jump to previous columns!  Use |<a href="eval.html#cursor()">cursor()</a>| to
		also set the preferred column.  Also see the "curswant" key in
		|<a href="eval.html#winrestview()">winrestview()</a>|.


setqflist(<code class="special">{list}</code> [, <code class="special">{action}</code>])				<b class="vimtag">*<a name="setqflist()">setqflist()</a>*</b>
		Create or replace or add to the quickfix list using the items
		in <code class="special">{list}</code>.  Each item in <code class="special">{list}</code> is a dictionary.
		Non-dictionary items in <code class="special">{list}</code> are ignored.  Each dictionary
		item can contain the following entries:

		    bufnr	buffer number; must be the number of a valid
				buffer
		    filename	name of a file; only used when "bufnr" is not
				present or it is invalid.
		    lnum	line number in the file
		    pattern	search pattern used to locate the error
		    col		column number
		    vcol	when non-zero: "col" is visual column
				when zero: "col" is byte index
		    nr		error number
		    text	description of the error
		    type	single-character error type, 'E', 'W', etc.

		The "col", "vcol", "nr", "type" and "text" entries are
		optional.  Either "lnum" or "pattern" entry can be used to
		locate a matching error line.
		If the "filename" and "bufnr" entries are not present or
		neither the "lnum" or "pattern" entries are present, then the
		item will not be handled as an error line.
		If both "pattern" and "lnum" are present then "pattern" will
		be used.
		If you supply an empty <code class="special">{list}</code>, the quickfix list will be
		cleared.
		<code class="note">Note</code> that the list is not exactly the same as what
		|<a href="eval.html#getqflist()">getqflist()</a>| returns.

							<b class="vimtag">*<a name="E927">E927</a>*</b>
		If <code class="special">{action}</code> is set to 'a', then the items from <code class="special">{list}</code> are
		added to the existing quickfix list. If there is no existing
		list, then a new list is created. If <code class="special">{action}</code> is set to 'r',
		then the items from the current quickfix list are replaced
		with the items from <code class="special">{list}</code>. If <code class="special">{action}</code> is not present or is
		set to ' ', then a new list is created.

		Returns zero for success, -1 for failure.

		This function can be used to create a quickfix list
		independent of the 'errorformat' setting.  Use a command like
		":cc 1" to jump to the first position.


							<b class="vimtag">*<a name="setreg()">setreg()</a>*</b>
setreg(<code class="special">{regname}</code>, <code class="special">{value}</code> [, <code class="special">{options}</code>])
		Set the register <code class="special">{regname}</code> to <code class="special">{value}</code>.
		<code class="special">{value}</code> may be any value returned by |<a href="eval.html#getreg()">getreg()</a>|, including
		a |<a href="eval.html#List">List</a>|.
		If <code class="special">{options}</code> contains "a" or <code class="special">{regname}</code> is upper case,
		then the value is appended.
		<code class="special">{options}</code> can also contain a register type specification:
		    "c" or "v"	      |<a href="motion.html#characterwise">characterwise</a>| mode
		    "l" or "V"	      |<a href="motion.html#linewise">linewise</a>| mode
		    "b" or "<code class="special">&lt;<code class="keystroke">CTRL-V</code>&gt;</code>" |<a href="visual.html#blockwise-visual">blockwise-visual</a>| mode
		If a number immediately follows "b" or "<code class="special">&lt;<code class="keystroke">CTRL-V</code>&gt;</code>" then this is
		used as the width of the selection - if it is not specified
		then the width of the block is set to the number of characters
		in the longest line (counting a <code class="special">&lt;Tab&gt;</code> as 1 character).

		If <code class="special">{options}</code> contains no register settings, then the default
		is to use character mode unless <code class="special">{value}</code> ends in a <code class="special">&lt;NL&gt;</code> for
		string <code class="special">{value}</code> and linewise mode for list <code class="special">{value}</code>. Blockwise
		mode is never selected automatically.
		Returns zero for success, non-zero for failure.

							<b class="vimtag">*<a name="E883">E883</a>*</b>
		<code class="note">Note:</code> you may not use |<a href="eval.html#List">List</a>| containing more than one item to
		      set search and expression registers. Lists containing no
		      items act like empty strings.

		Examples:
<code class="example">			:call setreg(v:register, @*)</code>
<code class="example">			:call setreg('*', @%, 'ac')</code>
<code class="example">			:call setreg('a', "1\n2\n3", 'b5')</code>
<code class="example"></code>
		This example shows using the functions to save and restore a
		register (<code class="note">note:</code> you may not reliably restore register value
		without using the third argument to |<a href="eval.html#getreg()">getreg()</a>| as without it
		newlines are represented as newlines AND Nul bytes are
		represented as newlines as well, see |<a href="pattern.html#NL-used-for-Nul">NL-used-for-Nul</a>|).
<code class="example">			:let var_a = getreg('a', 1, 1)</code>
<code class="example">			:let var_amode = getregtype('a')</code>
<code class="example">			    ....</code>
<code class="example">			:call setreg('a', var_a, var_amode)</code>
<code class="example"></code>
		You can also change the type of a register by appending
		nothing:
<code class="example">			:call setreg('a', '', 'al')</code>
<code class="example"></code>
settabvar(<code class="special">{tabnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)			<b class="vimtag">*<a name="settabvar()">settabvar()</a>*</b>
		Set tab-local variable <code class="special">{varname}</code> to <code class="special">{val}</code> in tab page <code class="special">{tabnr}</code>.
		|<a href="eval.html#t:var">t:var</a>|
		<code class="note">Note</code> that the variable name without "t:" must be used.
		Tabs are numbered starting with one.
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.

settabwinvar(<code class="special">{tabnr}</code>, <code class="special">{winnr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)	<b class="vimtag">*<a name="settabwinvar()">settabwinvar()</a>*</b>
		Set option or local variable <code class="special">{varname}</code> in window <code class="special">{winnr}</code> to
		<code class="special">{val}</code>.
		Tabs are numbered starting with one.  For the current tabpage
		use |<a href="eval.html#setwinvar()">setwinvar()</a>|.
		When <code class="special">{winnr}</code> is zero the current window is used.
		This also works for a global or local buffer option, but it
		doesn't work for a global or local buffer variable.
		For a local buffer option the global value is unchanged.
		<code class="note">Note</code> that the variable name without "w:" must be used.
		Examples:
<code class="example">			:call settabwinvar(1, 1, "&amp;list", 0)</code>
<code class="example">			:call settabwinvar(3, 2, "myvar", "foobar")</code>
		This function is not available in the |<a href="eval.html#sandbox">sandbox</a>|.

setwinvar(<code class="special">{nr}</code>, <code class="special">{varname}</code>, <code class="special">{val}</code>)			<b class="vimtag">*<a name="setwinvar()">setwinvar()</a>*</b>
		Like |<a href="eval.html#settabwinvar()">settabwinvar()</a>| for the current tab page.
		Examples:
<code class="example">			:call setwinvar(1, "&amp;list", 0)</code>
<code class="example">			:call setwinvar(2, "myvar", "foobar")</code>
<code class="example"></code>
sha256(<code class="special">{string}</code>)						<b class="vimtag">*<a name="sha256()">sha256()</a>*</b>
		Returns a String with 64 hex characters, which is the SHA256
		checksum of <code class="special">{string}</code>.
		{only available when compiled with the |<a href="various.html#+cryptv">+cryptv</a>| feature}

shellescape(<code class="special">{string}</code> [, <code class="special">{special}</code>])			<b class="vimtag">*<a name="shellescape()">shellescape()</a>*</b>
		Escape <code class="special">{string}</code> for use as a shell command argument.
		On MS-Windows and MS-DOS, when 'shellslash' is not set, it
		will enclose <code class="special">{string}</code> in double quotes and double all double
		quotes within <code class="special">{string}</code>.
		For other systems, it will enclose <code class="special">{string}</code> in single quotes
		and replace all "'" with "'\''".
		When the <code class="special">{special}</code> argument is present and it's a non-zero
		Number or a non-empty String (|<a href="eval.html#non-zero-arg">non-zero-arg</a>|), then special
		items such as "!", "%", "#" and "<code class="special">&lt;cword&gt;</code>" will be preceded by
		a backslash.  This backslash will be removed again by the |<a href="various.html#:!">:!</a>|
		command.
		The "!" character will be escaped (again with a |<a href="eval.html#non-zero-arg">non-zero-arg</a>|
		<code class="special">{special}</code>) when 'shell' contains "csh" in the tail.  That is
		because for csh and tcsh "!" is used for history replacement
		even when inside single quotes.
		The <code class="special">&lt;NL&gt;</code> character is also escaped.  With a |<a href="eval.html#non-zero-arg">non-zero-arg</a>|
		<code class="special">{special}</code> and 'shell' containing "csh" in the tail it's
		escaped a second time.
		Example of use with a |<a href="various.html#:!">:!</a>| command:
<code class="example">		    :exe '!dir ' . shellescape(expand('<code class="special">&lt;cfile&gt;</code>'), 1)</code>
		This results in a directory listing for the file under the
		cursor.  Example of use with |<a href="eval.html#system()">system()</a>|:
<code class="example">		    :call system("chmod +w -- " . shellescape(expand("%")))</code>
		See also |<a href="cmdline.html#::S">::S</a>|.


shiftwidth()						<b class="vimtag">*<a name="shiftwidth()">shiftwidth()</a>*</b>
		Returns the effective value of 'shiftwidth'. This is the
		'shiftwidth' value unless it is zero, in which case it is the
		'tabstop' value.  This function was introduced with patch
		7.3.694 in 2012, everybody should have it by now.


simplify(<code class="special">{filename}</code>)					<b class="vimtag">*<a name="simplify()">simplify()</a>*</b>
		Simplify the file name as much as possible without changing
		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
		Unix) are not resolved.  If the first path component in
		<code class="special">{filename}</code> designates the current directory, this will be
		valid for the result as well.  A trailing path separator is
		not removed either.
		Example:
<code class="example">			simplify("./dir/.././/file/") == "./file/"</code>
		<code class="note">Note:</code> The combination "dir/.." is only removed if "dir" is
		a searchable directory or does not exist.  On Unix, it is also
		removed when "dir" is a symbolic link within the same
		directory.  In order to resolve all the involved symbolic
		links before simplifying the path name, use |<a href="eval.html#resolve()">resolve()</a>|.


sin(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="sin()">sin()</a>*</b>
		Return the sine of <code class="special">{expr}</code>, measured in radians, as a |<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo sin(100)</code>
&lt;			-0.506366
<code class="example">			:echo sin(-4.01)</code>
			0.763301
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


sinh(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="sinh()">sinh()</a>*</b>
		Return the hyperbolic sine of <code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| in the range
		[-inf, inf].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo sinh(0.5)</code>
&lt;			0.521095
<code class="example">			:echo sinh(-0.9)</code>
			-1.026517
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


sort(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])			<b class="vimtag">*<a name="sort()">sort()</a>*</b> <b class="vimtag">*<a name="E702">E702</a>*</b>
		Sort the items in <code class="special">{list}</code> in-place.  Returns <code class="special">{list}</code>.

		If you want a list to remain unmodified make a copy first:
<code class="example">			:let sortedlist = sort(copy(mylist))</code>
<code class="example"></code>
		When <code class="special">{func}</code> is omitted, is empty or zero, then sort() uses the
		string representation of each item to sort on.  Numbers sort
		after Strings, |<a href="eval.html#Lists">Lists</a>| after Numbers.  For sorting text in the
		current buffer use |<a href="change.html#:sort">:sort</a>|.

		When <code class="special">{func}</code> is given and it is '1' or 'i' then case is
		ignored.

		When <code class="special">{func}</code> is given and it is 'n' then all items will be
		sorted numerical (Implementation detail: This uses the
		strtod() function to parse numbers, Strings, Lists, Dicts and
		Funcrefs will be considered as being 0).

		When <code class="special">{func}</code> is given and it is 'N' then all items will be
		sorted numerical. This is like 'n' but a string containing
		digits will be used as the number they represent.

		When <code class="special">{func}</code> is given and it is 'f' then all items will be
		sorted numerical. All values must be a Number or a Float.

		When <code class="special">{func}</code> is a |<a href="eval.html#Funcref">Funcref</a>| or a function name, this function
		is called to compare items.  The function is invoked with two
		items as argument and must return zero if they are equal, 1 or
		bigger if the first one sorts after the second one, -1 or
		smaller if the first one sorts before the second one.

		<code class="special">{dict}</code> is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |<a href="eval.html#Dictionary-function">Dictionary-function</a>|

		The sort is stable, items which compare equal (as number or as
		string) will keep their relative position. E.g., when sorting
		on numbers, text strings will sort next to each other, in the
		same order as they were originally.

		Also see |<a href="eval.html#uniq()">uniq()</a>|.

		Example:
<code class="example">			func MyCompare(i1, i2)</code>
<code class="example">			   return a:i1 == a:i2 ? 0 : a:i1 &gt; a:i2 ? 1 : -1</code>
<code class="example">			endfunc</code>
<code class="example">			let sortedlist = sort(mylist, "MyCompare")</code>
		A shorter compare version for this specific simple case, which
		ignores overflow:
<code class="example">			func MyCompare(i1, i2)</code>
<code class="example">			   return a:i1 - a:i2</code>
<code class="example">			endfunc</code>

							<b class="vimtag">*<a name="soundfold()">soundfold()</a>*</b>
soundfold(<code class="special">{word}</code>)
		Return the sound-folded equivalent of <code class="special">{word}</code>.  Uses the first
		language in 'spelllang' for the current window that supports
		soundfolding.  'spell' must be set.  When no sound folding is
		possible the <code class="special">{word}</code> is returned unmodified.
		This can be used for making spelling suggestions.  <code class="note">Note</code> that
		the method can be quite slow.

							<b class="vimtag">*<a name="spellbadword()">spellbadword()</a>*</b>
spellbadword([<code class="special">{sentence}</code>])
		Without argument: The result is the badly spelled word under
		or after the cursor.  The cursor is moved to the start of the
		bad word.  When no bad word is found in the cursor line the
		result is an empty string and the cursor doesn't move.

		With argument: The result is the first word in <code class="special">{sentence}</code> that
		is badly spelled.  If there are no spelling mistakes the
		result is an empty string.

		The return value is a list with two items:
		- The badly spelled word or an empty string.
		- The type of the spelling error:
			"bad"		spelling mistake
			"rare"		rare word
			"local"		word only valid in another region
			"caps"		word should start with Capital
		Example:
<code class="example">			echo spellbadword("the quik brown fox")</code>
<code class="section">			['quik', 'bad'] </code>

		The spelling information for the current window is used.  The
		'spell' option must be set and the value of 'spelllang' is
		used.

							<b class="vimtag">*<a name="spellsuggest()">spellsuggest()</a>*</b>
spellsuggest(<code class="special">{word}</code> [, <code class="special">{max}</code> [, <code class="special">{capital}</code>]])
		Return a |<a href="eval.html#List">List</a>| with spelling suggestions to replace <code class="special">{word}</code>.
		When <code class="special">{max}</code> is given up to this number of suggestions are
		returned.  Otherwise up to 25 suggestions are returned.

		When the <code class="special">{capital}</code> argument is given and it's non-zero only
		suggestions with a leading capital will be given.  Use this
		after a match with 'spellcapcheck'.

		<code class="special">{word}</code> can be a badly spelled word followed by other text.
		This allows for joining two words that were split.  The
		suggestions also include the following text, thus you can
		replace a line.

		<code class="special">{word}</code> may also be a good word.  Similar words will then be
		returned.  <code class="special">{word}</code> itself is not included in the suggestions,
		although it may appear capitalized.

		The spelling information for the current window is used.  The
		'spell' option must be set and the values of 'spelllang' and
		'spellsuggest' are used.


split(<code class="special">{expr}</code> [, <code class="special">{pattern}</code> [, <code class="special">{keepempty}</code>]])			<b class="vimtag">*<a name="split()">split()</a>*</b>
		Make a |<a href="eval.html#List">List</a>| out of <code class="special">{expr}</code>.  When <code class="special">{pattern}</code> is omitted or
		empty each white-separated sequence of characters becomes an
		item.
		Otherwise the string is split where <code class="special">{pattern}</code> matches,
		removing the matched characters. 'ignorecase' is not used
		here, add \c to ignore case. |<a href="pattern.html#%2F\c">/\c</a>|
		When the first or last item is empty it is omitted, unless the
		<code class="special">{keepempty}</code> argument is given and it's non-zero.
		Other empty items are kept when <code class="special">{pattern}</code> matches at least one
		character or when <code class="special">{keepempty}</code> is non-zero.
		Example:
<code class="example">			:let words = split(getline('.'), '\W\+')</code>
&lt;		To split a string in individual characters:
<code class="example">			:for c in split(mystring, '\zs')</code>
		If you want to keep the separator you can also use '\zs' at
		the end of the pattern:
<code class="example">			:echo split('abc:def:ghi', ':\zs')</code>
<code class="section">			['abc:', 'def:', 'ghi'] </code>
		Splitting a table where the first element can be empty:
<code class="example">			:let items = split(line, ':', 1)</code>
		The opposite function is |<a href="eval.html#join()">join()</a>|.


sqrt(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="sqrt()">sqrt()</a>*</b>
		Return the non-negative square root of Float <code class="special">{expr}</code> as a
		|<a href="eval.html#Float">Float</a>|.
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.  When <code class="special">{expr}</code>
		is negative the result is NaN (Not a Number).
		Examples:
<code class="example">			:echo sqrt(100)</code>
&lt;			10.0
<code class="example">			:echo sqrt(-4.01)</code>
			nan
		"nan" may be different, it depends on system libraries.
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


str2float(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="str2float()">str2float()</a>*</b>
		Convert String <code class="special">{expr}</code> to a Float.  This mostly works the same
		as when using a floating point number in an expression, see
		|<a href="eval.html#floating-point-format">floating-point-format</a>|.  But it's a bit more permissive.
		E.g., "1e40" is accepted, while in an expression you need to
		write "1.0e40".
		Text after the number is silently ignored.
		The decimal point is always '.', no matter what the locale is
		set to.  A comma ends the number: "12,345.67" is converted to
		12.0.  You can strip out thousands separators with
		|<a href="eval.html#substitute()">substitute()</a>|:
<code class="example">			let f = str2float(substitute(text, ',', '', 'g'))</code>
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


str2nr(<code class="special">{expr}</code> [, <code class="special">{base}</code>])				<b class="vimtag">*<a name="str2nr()">str2nr()</a>*</b>
		Convert string <code class="special">{expr}</code> to a number.
		<code class="special">{base}</code> is the conversion base, it can be 2, 8, 10 or 16.
		When <code class="special">{base}</code> is omitted base 10 is used.  This also means that
		a leading zero doesn't cause octal conversion to be used, as
		with the default String to Number conversion.
		When <code class="special">{base}</code> is 16 a leading "0x" or "0X" is ignored.  With a
		different base the result will be zero.  Similarly, when
		<code class="special">{base}</code> is 8 a leading "0" is ignored, and when <code class="special">{base}</code> is 2 a
		leading "0b" or "0B" is ignored.
		Text after the number is silently ignored.


strchars(<code class="special">{expr}</code> [, <code class="special">{skipcc}</code>])					<b class="vimtag">*<a name="strchars()">strchars()</a>*</b>
		The result is a Number, which is the number of characters
		in String <code class="special">{expr}</code>.
		When <code class="special">{skipcc}</code> is omitted or zero, composing characters are
		counted separately.
		When <code class="special">{skipcc}</code> set to 1, Composing characters are ignored.
		Also see |<a href="eval.html#strlen()">strlen()</a>|, |<a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>| and |<a href="eval.html#strwidth()">strwidth()</a>|.

		<code class="special">{skipcc}</code> is only available after 7.4.755.  For backward
		compatibility, you can define a wrapper function:
<code class="example">		    if has("patch-7.4.755")</code>
<code class="example">		      function s:strchars(str, skipcc)</code>
<code class="example">			return strchars(a:str, a:skipcc)</code>
<code class="example">		      endfunction</code>
<code class="example">		    else</code>
<code class="example">		      function s:strchars(str, skipcc)</code>
<code class="example">			if a:skipcc</code>
<code class="example">			  return strlen(substitute(a:str, ".", "x", "g"))</code>
<code class="example">			else</code>
<code class="example">			  return strchars(a:str)</code>
<code class="example">			endif</code>
<code class="example">		      endfunction</code>
<code class="example">		    endif</code>

strcharpart(<code class="special">{src}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])			<b class="vimtag">*<a name="strcharpart()">strcharpart()</a>*</b>
		Like |<a href="eval.html#strpart()">strpart()</a>| but using character index and length instead
		of byte index and length.
		When a character index is used where a character does not
		exist it is assumed to be one byte.  For example:
<code class="example">			strcharpart('abc', -1, 2)</code>
		results in 'a'.

strdisplaywidth(<code class="special">{expr}</code>[, <code class="special">{col}</code>])			<b class="vimtag">*<a name="strdisplaywidth()">strdisplaywidth()</a>*</b>
		The result is a Number, which is the number of display cells
		String <code class="special">{expr}</code> occupies on the screen when it starts at <code class="special">{col}</code>.
		When <code class="special">{col}</code> is omitted zero is used.  Otherwise it is the
		screen column where to start.  This matters for Tab
		characters.
		The option settings of the current window are used.  This
		matters for anything that's displayed differently, such as
		'tabstop' and 'display'.
		When <code class="special">{expr}</code> contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on 'ambiwidth'.
		Also see |<a href="eval.html#strlen()">strlen()</a>|, |<a href="eval.html#strwidth()">strwidth()</a>| and |<a href="eval.html#strchars()">strchars()</a>|.

strftime(<code class="special">{format}</code> [, <code class="special">{time}</code>])				<b class="vimtag">*<a name="strftime()">strftime()</a>*</b>
		The result is a String, which is a formatted date and time, as
		specified by the <code class="special">{format}</code> string.  The given <code class="special">{time}</code> is used,
		or the current time if no time is given.  The accepted
		<code class="special">{format}</code> depends on your system, thus this is not portable!
		See the manual page of the C function strftime() for the
		format.  The maximum length of the result is 80 characters.
		See also |<a href="eval.html#localtime()">localtime()</a>| and |<a href="eval.html#getftime()">getftime()</a>|.
		The language can be changed with the |<a href="mlang.html#:language">:language</a>| command.
		Examples:
<code class="example">		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997</code>
<code class="example">		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25</code>
<code class="example">		  :echo strftime("%y%m%d %T")	   970427 11:53:55</code>
<code class="example">		  :echo strftime("%H:%M")	   11:55</code>
<code class="example">		  :echo strftime("%c", getftime("file.c"))</code>
<code class="example">						   Show mod time of file.c.</code>
&lt;		Not available on all systems.  To check use:
<code class="example">			:if exists("*strftime")</code>
<code class="example"></code>
strgetchar(<code class="special">{str}</code>, <code class="special">{index}</code>)				<b class="vimtag">*<a name="strgetchar()">strgetchar()</a>*</b>
		Get character <code class="special">{index}</code> from <code class="special">{str}</code>.  This uses a character
		index, not a byte index.  Composing characters are considered
		separate characters here.
		Also see |<a href="eval.html#strcharpart()">strcharpart()</a>| and |<a href="eval.html#strchars()">strchars()</a>|.

stridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])		<b class="vimtag">*<a name="stridx()">stridx()</a>*</b>
		The result is a Number, which gives the byte index in
		<code class="special">{haystack}</code> of the first occurrence of the String <code class="special">{needle}</code>.
		If <code class="special">{start}</code> is specified, the search starts at index <code class="special">{start}</code>.
		This can be used to find a second match:
<code class="example">			:let colon1 = stridx(line, ":")</code>
<code class="example">			:let colon2 = stridx(line, ":", colon1 + 1)</code>
		The search is done case-sensitive.
		For pattern searches use |<a href="eval.html#match()">match()</a>|.
		-1 is returned if the <code class="special">{needle}</code> does not occur in <code class="special">{haystack}</code>.
		See also |<a href="eval.html#strridx()">strridx()</a>|.
		Examples:
<code class="example">		  :echo stridx("An Example", "Example")	     3</code>
<code class="example">		  :echo stridx("Starting point", "Start")    0</code>
<code class="example">		  :echo stridx("Starting point", "start")   -1</code>
						<b class="vimtag">*<a name="strstr()">strstr()</a>*</b> <b class="vimtag">*<a name="strchr()">strchr()</a>*</b>
		stridx() works similar to the C function strstr().  When used
		with a single character it works similar to strchr().

							<b class="vimtag">*<a name="string()">string()</a>*</b>
string(<code class="special">{expr}</code>)	Return <code class="special">{expr}</code> converted to a String.  If <code class="special">{expr}</code> is a Number,
		Float, String or a composition of them, then the result can be
		parsed back with |<a href="eval.html#eval()">eval()</a>|.
<code class="section">			<code class="special">{expr}</code> type	result </code>
			String		'string' (single quotes are doubled)
			Number		123
			Float		123.123456 or 1.123456e8
			Funcref		function('name')
			List		[item, item]
			Dictionary	<code class="special">{key: value, key: value}</code>

		When a List or Dictionary has a recursive reference it is
		replaced by "[...]" or "<code class="special">{...}</code>".  Using eval() on the result
		will then fail.

		Also see |<a href="eval.html#strtrans()">strtrans()</a>|.

							<b class="vimtag">*<a name="strlen()">strlen()</a>*</b>
strlen(<code class="special">{expr}</code>)	The result is a Number, which is the length of the String
		<code class="special">{expr}</code> in bytes.
		If the argument is a Number it is first converted to a String.
		For other types an error is given.
		If you want to count the number of multi-byte characters use
		|<a href="eval.html#strchars()">strchars()</a>|.
		Also see |<a href="eval.html#len()">len()</a>|, |<a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>| and |<a href="eval.html#strwidth()">strwidth()</a>|.

strpart(<code class="special">{src}</code>, <code class="special">{start}</code>[, <code class="special">{len}</code>])			<b class="vimtag">*<a name="strpart()">strpart()</a>*</b>
		The result is a String, which is part of <code class="special">{src}</code>, starting from
		byte <code class="special">{start}</code>, with the byte length <code class="special">{len}</code>.
		To count characters instead of bytes use |<a href="eval.html#strcharpart()">strcharpart()</a>|.

		When bytes are selected which do not exist, this doesn't
		result in an error, the bytes are simply omitted.
		If <code class="special">{len}</code> is missing, the copy continues from <code class="special">{start}</code> till the
		end of the <code class="special">{src}</code>.
<code class="example">			strpart("abcdefg", 3, 2)    == "de"</code>
<code class="example">			strpart("abcdefg", -2, 4)   == "ab"</code>
<code class="example">			strpart("abcdefg", 5, 4)    == "fg"</code>
<code class="example">			strpart("abcdefg", 3)	    == "defg"</code>
<code class="example"></code>
		<code class="note">Note:</code> To get the first character, <code class="special">{start}</code> must be 0.  For
		example, to get three bytes under and after the cursor:
<code class="example">			strpart(getline("."), col(".") - 1, 3)</code>

strridx(<code class="special">{haystack}</code>, <code class="special">{needle}</code> [, <code class="special">{start}</code>])			<b class="vimtag">*<a name="strridx()">strridx()</a>*</b>
		The result is a Number, which gives the byte index in
		<code class="special">{haystack}</code> of the last occurrence of the String <code class="special">{needle}</code>.
		When <code class="special">{start}</code> is specified, matches beyond this index are
		ignored.  This can be used to find a match before a previous
		match:
<code class="example">			:let lastcomma = strridx(line, ",")</code>
<code class="example">			:let comma2 = strridx(line, ",", lastcomma - 1)</code>
		The search is done case-sensitive.
		For pattern searches use |<a href="eval.html#match()">match()</a>|.
		-1 is returned if the <code class="special">{needle}</code> does not occur in <code class="special">{haystack}</code>.
		If the <code class="special">{needle}</code> is empty the length of <code class="special">{haystack}</code> is returned.
		See also |<a href="eval.html#stridx()">stridx()</a>|.  Examples:
<code class="example">		  :echo strridx("an angry armadillo", "an")	     3</code>
							<b class="vimtag">*<a name="strrchr()">strrchr()</a>*</b>
		When used with a single character it works similar to the C
		function strrchr().

strtrans(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="strtrans()">strtrans()</a>*</b>
		The result is a String, which is <code class="special">{expr}</code> with all unprintable
		characters translated into printable characters |<a href="options.html#'isprint'">'isprint'</a>|.
		Like they are shown in a window.  Example:
<code class="example">			echo strtrans(@a)</code>
		This displays a newline in register a as "^@" instead of
		starting a new line.

strwidth(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="strwidth()">strwidth()</a>*</b>
		The result is a Number, which is the number of display cells
		String <code class="special">{expr}</code> occupies.  A Tab character is counted as one
		cell, alternatively use |<a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>|.
		When <code class="special">{expr}</code> contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on 'ambiwidth'.
		Also see |<a href="eval.html#strlen()">strlen()</a>|, |<a href="eval.html#strdisplaywidth()">strdisplaywidth()</a>| and |<a href="eval.html#strchars()">strchars()</a>|.

submatch(<code class="special">{nr}</code>[, <code class="special">{list}</code>])				<b class="vimtag">*<a name="submatch()">submatch()</a>*</b>
		Only for an expression in a |<a href="change.html#:substitute">:substitute</a>| command or
		substitute() function.
		Returns the <code class="special">{nr}</code>'th submatch of the matched text.  When <code class="special">{nr}</code>
		is 0 the whole matched text is returned.
		<code class="note">Note</code> that a NL in the string can stand for a line break of a
		multi-line match or a NUL character in the text.
		Also see |<a href="change.html#sub-replace-expression">sub-replace-expression</a>|.

		If <code class="special">{list}</code> is present and non-zero then submatch() returns
		a list of strings, similar to |<a href="eval.html#getline()">getline()</a>| with two arguments.
		NL characters in the text represent NUL characters in the
		text.
		Only returns more than one item for |<a href="change.html#:substitute">:substitute</a>|, inside
		|<a href="eval.html#substitute()">substitute()</a>| this list will always contain one or zero
		items, since there are no real line breaks.

		Example:
<code class="example">			:s/\d\+/\=submatch(0) + 1/</code>
		This finds the first number in the line and adds one to it.
		A line break is included as a newline character.

substitute(<code class="special">{expr}</code>, <code class="special">{pat}</code>, <code class="special">{sub}</code>, <code class="special">{flags}</code>)		<b class="vimtag">*<a name="substitute()">substitute()</a>*</b>
		The result is a String, which is a copy of <code class="special">{expr}</code>, in which
		the first match of <code class="special">{pat}</code> is replaced with <code class="special">{sub}</code>.
		When <code class="special">{flags}</code> is "g", all matches of <code class="special">{pat}</code> in <code class="special">{expr}</code> are
		replaced.  Otherwise <code class="special">{flags}</code> should be "".

		This works like the ":substitute" command (without any flags).
		But the matching with <code class="special">{pat}</code> is always done like the 'magic'
		option is set and 'cpoptions' is empty (to make scripts
		portable).  'ignorecase' is still relevant, use |<a href="pattern.html#%2F\c">/\c</a>| or |<a href="pattern.html#%2F\C">/\C</a>|
		if you want to ignore or match case and ignore 'ignorecase'.
		'smartcase' is not used.  See |<a href="eval.html#string-match">string-match</a>| for how <code class="special">{pat}</code> is
		used.

		A "~" in <code class="special">{sub}</code> is not replaced with the previous <code class="special">{sub}</code>.
		<code class="note">Note</code> that some codes in <code class="special">{sub}</code> have a special meaning
		|<a href="change.html#sub-replace-special">sub-replace-special</a>|.	For example, to replace something with
		"\n" (two characters), use "\\\\n" or '\\n'.

		When <code class="special">{pat}</code> does not match in <code class="special">{expr}</code>, <code class="special">{expr}</code> is returned
		unmodified.

		Example:
<code class="example">			:let &amp;path = substitute(&amp;path, ",\\=[^,]*$", "", "")</code>
&lt;		This removes the last component of the 'path' option.
<code class="example">			:echo substitute("testing", ".*", "\\U\\0", "")</code>
		results in "TESTING".

		When <code class="special">{sub}</code> starts with "\=", the remainder is interpreted as
		an expression. See |<a href="change.html#sub-replace-expression">sub-replace-expression</a>|.  Example:
<code class="example">			:echo substitute(s, '%\(\x\x\)',</code>
<code class="example">			   \ '\=nr2char("0x" . submatch(1))', 'g')</code>
<code class="example"></code>
synID(<code class="special">{lnum}</code>, <code class="special">{col}</code>, <code class="special">{trans}</code>)				<b class="vimtag">*<a name="synID()">synID()</a>*</b>
		The result is a Number, which is the syntax ID at the position
		<code class="special">{lnum}</code> and <code class="special">{col}</code> in the current window.
		The syntax ID can be used with |<a href="eval.html#synIDattr()">synIDattr()</a>| and
		|<a href="eval.html#synIDtrans()">synIDtrans()</a>| to obtain syntax information about text.

		<code class="special">{col}</code> is 1 for the leftmost column, <code class="special">{lnum}</code> is 1 for the first
		line.  'synmaxcol' applies, in a longer line zero is returned.
		<code class="note">Note</code> that when the position is after the last character,
		that's where the cursor can be in Insert mode, synID() returns
		zero.

		When <code class="special">{trans}</code> is non-zero, transparent items are reduced to the
		item that they reveal.	This is useful when wanting to know
		the effective color.  When <code class="special">{trans}</code> is zero, the transparent
		item is returned.  This is useful when wanting to know which
		syntax item is effective (e.g. inside parens).
		Warning: This function can be very slow.  Best speed is
		obtained by going through the file in forward direction.

		Example (echoes the name of the syntax item under the cursor):
<code class="example">			:echo synIDattr(synID(line("."), col("."), 1), "name")</code>


synIDattr(<code class="special">{synID}</code>, <code class="special">{what}</code> [, <code class="special">{mode}</code>])			<b class="vimtag">*<a name="synIDattr()">synIDattr()</a>*</b>
		The result is a String, which is the <code class="special">{what}</code> attribute of
		syntax ID <code class="special">{synID}</code>.  This can be used to obtain information
		about a syntax item.
		<code class="special">{mode}</code> can be "gui", "cterm" or "term", to get the attributes
		for that mode.	When <code class="special">{mode}</code> is omitted, or an invalid value is
		used, the attributes for the currently active highlighting are
		used (GUI, cterm or term).
		Use synIDtrans() to follow linked highlight groups.
		<code class="special">{what}</code>		result
		"name"		the name of the syntax item
		"fg"		foreground color (GUI: color name used to set
				the color, cterm: color number as a string,
				term: empty string)
		"bg"		background color (as with "fg")
		"font"		font name (only available in the GUI)
				|<a href="syntax.html#highlight-font">highlight-font</a>|
		"sp"		special color (as with "fg") |<a href="syntax.html#highlight-guisp">highlight-guisp</a>|
		"fg#"		like "fg", but for the GUI and the GUI is
				running the name in "#RRGGBB" form
		"bg#"		like "fg#" for "bg"
		"sp#"		like "fg#" for "sp"
		"bold"		"1" if bold
		"italic"	"1" if italic
		"reverse"	"1" if reverse
		"inverse"	"1" if inverse (= reverse)
		"standout"	"1" if standout
		"underline"	"1" if underlined
		"undercurl"	"1" if undercurled

		Example (echoes the color of the syntax item under the
		cursor):
<code class="example">	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")</code>

synIDtrans(<code class="special">{synID}</code>)					<b class="vimtag">*<a name="synIDtrans()">synIDtrans()</a>*</b>
		The result is a Number, which is the translated syntax ID of
		<code class="special">{synID}</code>.  This is the syntax group ID of what is being used to
		highlight the character.  Highlight links given with
		":highlight link" are followed.

synconcealed(<code class="special">{lnum}</code>, <code class="special">{col}</code>)				<b class="vimtag">*<a name="synconcealed()">synconcealed()</a>*</b>
		The result is a List. The first item in the list is 0 if the
		character at the position <code class="special">{lnum}</code> and <code class="special">{col}</code> is not part of a
		concealable region, 1 if it is. The second item in the list is
		a string. If the first item is 1, the second item contains the
		text which will be displayed in place of the concealed text,
		depending on the current setting of 'conceallevel'. The third
		and final item in the list is a unique number representing the
		specific syntax region matched. This allows detection of the
		beginning of a new concealable region if there are two
		consecutive regions with the same replacement character.
		For an example use see $VIMRUNTIME/syntax/2html.vim .


synstack(<code class="special">{lnum}</code>, <code class="special">{col}</code>)					<b class="vimtag">*<a name="synstack()">synstack()</a>*</b>
		Return a |<a href="eval.html#List">List</a>|, which is the stack of syntax items at the
		position <code class="special">{lnum}</code> and <code class="special">{col}</code> in the current window.  Each item in
		the List is an ID like what |<a href="eval.html#synID()">synID()</a>| returns.
		The first item in the List is the outer region, following are
		items contained in that one.  The last one is what |<a href="eval.html#synID()">synID()</a>|
		returns, unless not the whole item is highlighted or it is a
		transparent item.
		This function is useful for debugging a syntax file.
		Example that shows the syntax stack under the cursor:
<code class="example">			for id in synstack(line("."), col("."))</code>
<code class="example">			   echo synIDattr(id, "name")</code>
<code class="example">			endfor</code>
		When the position specified with <code class="special">{lnum}</code> and <code class="special">{col}</code> is invalid
		nothing is returned.  The position just after the last
		character in a line and the first column in an empty line are
		valid positions.

system(<code class="special">{expr}</code> [, <code class="special">{input}</code>])				<b class="vimtag">*<a name="system()">system()</a>*</b> <b class="vimtag">*<a name="E677">E677</a>*</b>
		Get the output of the shell command <code class="special">{expr}</code> as a string.  See
		|<a href="eval.html#systemlist()">systemlist()</a>| to get the output as a List.

		When <code class="special">{input}</code> is given and is a string this string is written
		to a file and passed as stdin to the command.  The string is
		written as-is, you need to take care of using the correct line
		separators yourself.
		If <code class="special">{input}</code> is given and is a |<a href="eval.html#List">List</a>| it is written to the file
		in a way |<a href="eval.html#writefile()">writefile()</a>| does with <code class="special">{binary}</code> set to "b" (i.e.
		with a newline between each list item with newlines inside
		list items converted to NULs).
		Pipes are not used.

		When prepended by |<a href="various.html#:silent">:silent</a>| the shell will not be set to
		cooked mode.  This is meant to be used for commands that do
		not need the user to type.  It avoids stray characters showing
		up on the screen which require |<a href="various.html#CTRL-L">CTRL-L</a>| to remove.
<code class="example">			:silent let f = system('ls *.vim')</code>

		<code class="note">Note:</code> Use |<a href="eval.html#shellescape()">shellescape()</a>| or |<a href="cmdline.html#::S">::S</a>| with |<a href="eval.html#expand()">expand()</a>| or
		|<a href="eval.html#fnamemodify()">fnamemodify()</a>| to escape special characters in a command
		argument.  Newlines in <code class="special">{expr}</code> may cause the command to fail.
		The characters in 'shellquote' and 'shellxquote' may also
		cause trouble.
		This is not to be used for interactive commands.

		The result is a String.  Example:
<code class="example">		    :let files = system("ls " .  shellescape(expand('%:h')))</code>
<code class="example">		    :let files = system('ls ' . expand('%:h:S'))</code>
<code class="example"></code>
		To make the result more system-independent, the shell output
		is filtered to replace <code class="special">&lt;CR&gt;</code> with <code class="special">&lt;NL&gt;</code> for Macintosh, and
		<code class="special">&lt;CR&gt;</code><code class="special">&lt;NL&gt;</code> with <code class="special">&lt;NL&gt;</code> for DOS-like systems.
		To avoid the string being truncated at a NUL, all NUL
		characters are replaced with SOH (0x01).

		The command executed is constructed using several options:
	'shell' 'shellcmdflag' 'shellxquote' <code class="special">{expr}</code> 'shellredir' <code class="special">{tmp}</code> 'shellxquote'
		(<code class="special">{tmp}</code> is an automatically generated file name).
		For Unix and OS/2 braces are put around <code class="special">{expr}</code> to allow for
		concatenated commands.

		The command will be executed in "cooked" mode, so that a
		<code class="keystroke">CTRL-C</code> will interrupt the command (on Unix at least).

		The resulting error code can be found in |<a href="eval.html#v:shell_error">v:shell_error</a>|.
		This function will fail in |<a href="starting.html#restricted-mode">restricted-mode</a>|.

		<code class="note">Note</code> that any wrong value in the options mentioned above may
		make the function fail.  It has also been reported to fail
		when using a security agent application.
		Unlike ":!cmd" there is no automatic check for changed files.
		Use |<a href="editing.html#:checktime">:checktime</a>| to force a check.


systemlist(<code class="special">{expr}</code> [, <code class="special">{input}</code>])				<b class="vimtag">*<a name="systemlist()">systemlist()</a>*</b>
		Same as |<a href="eval.html#system()">system()</a>|, but returns a |<a href="eval.html#List">List</a>| with lines (parts of
		output separated by NL) with NULs transformed into NLs. Output
		is the same as |<a href="eval.html#readfile()">readfile()</a>| will output with <code class="special">{binary}</code> argument
		set to "b".

		Returns an empty string on error.


tabpagebuflist([<code class="special">{arg}</code>])					<b class="vimtag">*<a name="tabpagebuflist()">tabpagebuflist()</a>*</b>
		The result is a |<a href="eval.html#List">List</a>|, where each item is the number of the
		buffer associated with each window in the current tab page.
		<code class="special">{arg}</code> specifies the number of tab page to be used.  When
		omitted the current tab page is used.
		When <code class="special">{arg}</code> is invalid the number zero is returned.
		To get a list of all buffers in all tabs use this:
<code class="example">			let buflist = []</code>
<code class="example">			for i in range(tabpagenr('$'))</code>
<code class="example">			   call extend(buflist, tabpagebuflist(i + 1))</code>
<code class="example">			endfor</code>
		<code class="note">Note</code> that a buffer may appear in more than one window.


tabpagenr([<code class="special">{arg}</code>])					<b class="vimtag">*<a name="tabpagenr()">tabpagenr()</a>*</b>
		The result is a Number, which is the number of the current
		tab page.  The first tab page has number 1.
		When the optional argument is "$", the number of the last tab
		page is returned (the tab page count).
		The number can be used with the |<a href="tabpage.html#:tab">:tab</a>| command.


tabpagewinnr(<code class="special">{tabarg}</code> [, <code class="special">{arg}</code>])			<b class="vimtag">*<a name="tabpagewinnr()">tabpagewinnr()</a>*</b>
		Like |<a href="eval.html#winnr()">winnr()</a>| but for tab page <code class="special">{tabarg}</code>.
		<code class="special">{tabarg}</code> specifies the number of tab page to be used.
		<code class="special">{arg}</code> is used like with |<a href="eval.html#winnr()">winnr()</a>|:
		- When omitted the current window number is returned.  This is
		  the window which will be used when going to this tab page.
		- When "$" the number of windows is returned.
		- When "#" the previous window nr is returned.
		Useful examples:
<code class="example">		    tabpagewinnr(1)	    " current window of tab page 1</code>
<code class="example">		    tabpagewinnr(4, '$')    " number of windows in tab page 4</code>
		When <code class="special">{tabarg}</code> is invalid zero is returned.

							<b class="vimtag">*<a name="tagfiles()">tagfiles()</a>*</b>
tagfiles()	Returns a |<a href="eval.html#List">List</a>| with the file names used to search for tags
		for the current buffer.  This is the 'tags' option expanded.


taglist(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="taglist()">taglist()</a>*</b>
		Returns a list of tags matching the regular expression <code class="special">{expr}</code>.
		Each list item is a dictionary with at least the following
		entries:
			name		Name of the tag.
			filename	Name of the file where the tag is
					defined.  It is either relative to the
					current directory or a full path.
			cmd		Ex command used to locate the tag in
					the file.
			kind		Type of the tag.  The value for this
					entry depends on the language specific
					kind values.  Only available when
					using a tags file generated by
					Exuberant ctags or hdrtag.
			static		A file specific tag.  Refer to
					|<a href="tagsrch.html#static-tag">static-tag</a>| for more information.
		More entries may be present, depending on the content of the
		tags file: access, implementation, inherits and signature.
		Refer to the ctags documentation for information about these
		fields.  For C code the fields "struct", "class" and "enum"
		may appear, they give the name of the entity the tag is
		contained in.

		The ex-command 'cmd' can be either an ex search pattern, a
		line number or a line number followed by a byte number.

		If there are no matching tags, then an empty list is returned.

		To get an exact tag match, the anchors '^' and '$' should be
		used in <code class="special">{expr}</code>.  This also make the function work faster.
		Refer to |<a href="tagsrch.html#tag-regexp">tag-regexp</a>| for more information about the tag
		search regular expression pattern.

		Refer to |<a href="options.html#'tags'">'tags'</a>| for information about how the tags file is
		located by Vim. Refer to |<a href="tagsrch.html#tags-file-format">tags-file-format</a>| for the format of
		the tags file generated by the different ctags tools.

tempname()					<b class="vimtag">*<a name="tempname()">tempname()</a>*</b> <b class="vimtag">*<a name="temp-file-name">temp-file-name</a>*</b>
		The result is a String, which is the name of a file that
		doesn't exist.	It can be used for a temporary file.  The name
		is different for at least 26 consecutive calls.  Example:
<code class="example">			:let tmpfile = tempname()</code>
<code class="example">			:exe "redir &gt; " . tmpfile</code>
		For Unix, the file will be in a private directory |<a href="change.html#tempfile">tempfile</a>|.
		For MS-Windows forward slashes are used when the 'shellslash'
		option is set or when 'shellcmdflag' starts with '-'.


tan(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="tan()">tan()</a>*</b>
		Return the tangent of <code class="special">{expr}</code>, measured in radians, as a |<a href="eval.html#Float">Float</a>|
		in the range [-inf, inf].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo tan(10)</code>
&lt;			0.648361
<code class="example">			:echo tan(-4.01)</code>
			-1.181502
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


tanh(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="tanh()">tanh()</a>*</b>
		Return the hyperbolic tangent of <code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| in the
		range [-1, 1].
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			:echo tanh(0.5)</code>
&lt;			0.462117
<code class="example">			:echo tanh(-1)</code>
			-0.761594
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}


							<b class="vimtag">*<a name="timer_start()">timer_start()</a>*</b>
timer_start(<code class="special">{time}</code>, <code class="special">{callback}</code> [, <code class="special">{options}</code>])
		Create a timer and return the timer ID.

		<code class="special">{time}</code> is the waiting time in milliseconds. This is the
		minimum time before invoking the callback.  When the system is
		busy or Vim is not waiting for input the time will be longer.

		<code class="special">{callback}</code> is the function to call.  It can be the name of a
		function or a Funcref.  It is called with one argument, which
		is the timer ID.  The callback is only invoked when Vim is
		waiting for input.

		<code class="special">{options}</code> is a dictionary.  Supported entries:
		   "repeat"	Number of times to repeat calling the
				callback.  -1 means forever.

		Example:
<code class="example">			func MyHandler(timer)</code>
<code class="example">			  echo 'Handler called'</code>
<code class="example">			endfunc</code>
<code class="example">			let timer = timer_start(500, 'MyHandler',</code>
<code class="example">				\ <code class="special">{'repeat': 3}</code>)</code>
		This will invoke MyHandler() three times at 500 msec
		intervals.
		{only available when compiled with the |<a href="various.html#+timers">+timers</a>| feature}

timer_stop(<code class="special">{timer}</code>)					<b class="vimtag">*<a name="timer_stop()">timer_stop()</a>*</b>
		Stop a timer.  <code class="special">{timer}</code> is an ID returned by timer_start().
		The timer callback will no longer be invoked.

tolower(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="tolower()">tolower()</a>*</b>
		The result is a copy of the String given, with all uppercase
		characters turned into lowercase (just like applying |<a href="change.html#gu">gu</a>| to
		the string).

toupper(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="toupper()">toupper()</a>*</b>
		The result is a copy of the String given, with all lowercase
		characters turned into uppercase (just like applying |<a href="change.html#gU">gU</a>| to
		the string).

tr(<code class="special">{src}</code>, <code class="special">{fromstr}</code>, <code class="special">{tostr}</code>)				<b class="vimtag">*<a name="tr()">tr()</a>*</b>
		The result is a copy of the <code class="special">{src}</code> string with all characters
		which appear in <code class="special">{fromstr}</code> replaced by the character in that
		position in the <code class="special">{tostr}</code> string.  Thus the first character in
		<code class="special">{fromstr}</code> is translated into the first character in <code class="special">{tostr}</code>
		and so on.  Exactly like the unix "tr" command.
		This code also deals with multibyte characters properly.

		Examples:
<code class="example">			echo tr("hello there", "ht", "HT")</code>
&lt;		returns "Hello THere"
<code class="example">			echo tr("<code class="special">&lt;blob&gt;</code>", "<code class="special">&lt;&gt;</code>", "<code class="special">{}</code>")</code>
		returns "<code class="special">{blob}</code>"

trunc(<code class="special">{expr}</code>)							<b class="vimtag">*<a name="trunc()">trunc()</a>*</b>
		Return the largest integral value with magnitude less than or
		equal to <code class="special">{expr}</code> as a |<a href="eval.html#Float">Float</a>| (truncate towards zero).
		<code class="special">{expr}</code> must evaluate to a |<a href="eval.html#Float">Float</a>| or a |<a href="eval.html#Number">Number</a>|.
		Examples:
<code class="example">			echo trunc(1.456)</code>
&lt;			1.0
<code class="example">			echo trunc(-5.456)</code>
&lt;			-5.0
<code class="example">			echo trunc(4.0)</code>
			4.0
		{only available when compiled with the |<a href="various.html#+float">+float</a>| feature}

							<b class="vimtag">*<a name="type()">type()</a>*</b>
type(<code class="special">{expr}</code>)	The result is a Number, depending on the type of <code class="special">{expr}</code>:
			Number:	    0
			String:	    1
			Funcref:    2
			List:	    3
			Dictionary: 4
			Float:	    5
			Boolean:    6 (v:false and v:true)
			None	    7 (v:null and v:none)
			Job	    8
			Channel	    9
		To avoid the magic numbers it should be used this way:
<code class="example">			:if type(myvar) == type(0)</code>
<code class="example">			:if type(myvar) == type("")</code>
<code class="example">			:if type(myvar) == type(function("tr"))</code>
<code class="example">			:if type(myvar) == type([])</code>
<code class="example">			:if type(myvar) == type(<code class="special">{}</code>)</code>
<code class="example">			:if type(myvar) == type(0.0)</code>
<code class="example">			:if type(myvar) == type(v:false)</code>
<code class="example">			:if type(myvar) == type(v:none)</code>
<code class="example"></code>
undofile(<code class="special">{name}</code>)					<b class="vimtag">*<a name="undofile()">undofile()</a>*</b>
		Return the name of the undo file that would be used for a file
		with name <code class="special">{name}</code> when writing.  This uses the 'undodir'
		option, finding directories that exist.  It does not check if
		the undo file exists.
		<code class="special">{name}</code> is always expanded to the full path, since that is what
		is used internally.
		If <code class="special">{name}</code> is empty undofile() returns an empty string, since a
		buffer without a file name will not write an undo file.
		Useful in combination with |<a href="undo.html#:wundo">:wundo</a>| and |<a href="undo.html#:rundo">:rundo</a>|.
		When compiled without the +persistent_undo option this always
		returns an empty string.

undotree()						<b class="vimtag">*<a name="undotree()">undotree()</a>*</b>
		Return the current state of the undo tree in a dictionary with
		the following items:
		  "seq_last"	The highest undo sequence number used.
		  "seq_cur"	The sequence number of the current position in
				the undo tree.  This differs from "seq_last"
				when some changes were undone.
		  "time_cur"	Time last used for |<a href="undo.html#:earlier">:earlier</a>| and related
				commands.  Use |<a href="eval.html#strftime()">strftime()</a>| to convert to
				something readable.
		  "save_last"	Number of the last file write.  Zero when no
				write yet.
		  "save_cur"	Number of the current position in the undo
				tree.
		  "synced"	Non-zero when the last undo block was synced.
				This happens when waiting from input from the
				user.  See |<a href="undo.html#undo-blocks">undo-blocks</a>|.
		  "entries"	A list of dictionaries with information about
				undo blocks.

		The first item in the "entries" list is the oldest undo item.
		Each List item is a Dictionary with these items:
		  "seq"		Undo sequence number.  Same as what appears in
				|<a href="undo.html#:undolist">:undolist</a>|.
		  "time"	Timestamp when the change happened.  Use
				|<a href="eval.html#strftime()">strftime()</a>| to convert to something readable.
		  "newhead"	Only appears in the item that is the last one
				that was added.  This marks the last change
				and where further changes will be added.
		  "curhead"	Only appears in the item that is the last one
				that was undone.  This marks the current
				position in the undo tree, the block that will
				be used by a redo command.  When nothing was
				undone after the last change this item will
				not appear anywhere.
		  "save"	Only appears on the last block before a file
				write.  The number is the write count.  The
				first write has number 1, the last one the
				"save_last" mentioned above.
		  "alt"		Alternate entry.  This is again a List of undo
				blocks.  Each item may again have an "alt"
				item.

uniq(<code class="special">{list}</code> [, <code class="special">{func}</code> [, <code class="special">{dict}</code>]])			<b class="vimtag">*<a name="uniq()">uniq()</a>*</b> <b class="vimtag">*<a name="E882">E882</a>*</b>
		Remove second and succeeding copies of repeated adjacent
		<code class="special">{list}</code> items in-place.  Returns <code class="special">{list}</code>.  If you want a list
		to remain unmodified make a copy first:
<code class="example">			:let newlist = uniq(copy(mylist))</code>
		The default compare function uses the string representation of
		each item.  For the use of <code class="special">{func}</code> and <code class="special">{dict}</code> see |<a href="eval.html#sort()">sort()</a>|.

values(<code class="special">{dict}</code>)						<b class="vimtag">*<a name="values()">values()</a>*</b>
		Return a |<a href="eval.html#List">List</a>| with all the values of <code class="special">{dict}</code>.	The |<a href="eval.html#List">List</a>| is
		in arbitrary order.


virtcol(<code class="special">{expr}</code>)						<b class="vimtag">*<a name="virtcol()">virtcol()</a>*</b>
		The result is a Number, which is the screen column of the file
		position given with <code class="special">{expr}</code>.  That is, the last screen position
		occupied by the character at that position, when the screen
		would be of unlimited width.  When there is a <code class="special">&lt;Tab&gt;</code> at the
		position, the returned Number will be the column at the end of
		the <code class="special">&lt;Tab&gt;</code>.  For example, for a <code class="special">&lt;Tab&gt;</code> in column 1, with 'ts'
		set to 8, it returns 8. |<a href="syntax.html#conceal">conceal</a>| is ignored.
		For the byte position use |<a href="eval.html#col()">col()</a>|.
		For the use of <code class="special">{expr}</code> see |<a href="eval.html#col()">col()</a>|.
		When 'virtualedit' is used <code class="special">{expr}</code> can be [lnum, col, off], where
		"off" is the offset in screen columns from the start of the
		character.  E.g., a position within a <code class="special">&lt;Tab&gt;</code> or after the last
		character.  When "off" is omitted zero is used.
		When Virtual editing is active in the current mode, a position
		beyond the end of the line can be returned. |<a href="options.html#'virtualedit'">'virtualedit'</a>|
		The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of displayed characters in the cursor line
			    plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |<a href="motion.html#'%3C">'&lt;</a>| in
			    that it's updated right away.
		<code class="note">Note</code> that only marks in the current file can be used.
		Examples:
<code class="example">  virtcol(".")	   with text "foo^Lbar", with cursor on the "^L", returns 5</code>
<code class="example">  virtcol("$")	   with text "foo^Lbar", returns 9</code>
<code class="example">  virtcol("'t")    with text "	  there", with 't at 'h', returns 6</code>
		The first column is 1.	0 is returned for an error.
		A more advanced example that echoes the maximum length of
		all lines:
<code class="example">		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))</code>
<code class="example"></code>
<code class="example"></code>
visualmode([expr])						<b class="vimtag">*<a name="visualmode()">visualmode()</a>*</b>
		The result is a String, which describes the last Visual mode
		used in the current buffer.  Initially it returns an empty
		string, but once Visual mode has been used, it returns "v",
		"V", or "<code class="special">&lt;<code class="keystroke">CTRL-V</code>&gt;</code>" (a single <code class="keystroke">CTRL-V</code> character) for
		character-wise, line-wise, or block-wise Visual mode
		respectively.
		Example:
<code class="example">			:exe "normal " . visualmode()</code>
		This enters the same Visual mode as before.  It is also useful
		in scripts if you wish to act differently depending on the
		Visual mode that was used.
		If Visual mode is active, use |<a href="eval.html#mode()">mode()</a>| to get the Visual mode
		(e.g., in a |<a href="map.html#:vmap">:vmap</a>|).
							<b class="vimtag">*<a name="non-zero-arg">non-zero-arg</a>*</b>
		If [expr] is supplied and it evaluates to a non-zero Number or
		a non-empty String, then the Visual mode will be cleared and
		the old value is returned.  <code class="note">Note</code> that " " and "0" are also
		non-empty strings, thus cause the mode to be cleared.  A List,
		Dictionary or Float is not a Number or String, thus does not
		cause the mode to be cleared.

wildmenumode()					<b class="vimtag">*<a name="wildmenumode()">wildmenumode()</a>*</b>
		Returns non-zero when the wildmenu is active and zero
		otherwise.  See 'wildmenu' and 'wildmode'.
		This can be used in mappings to handle the 'wildcharm' option
		gracefully. (Makes only sense with |<a href="map.html#mapmode-c">mapmode-c</a>| mappings).

		For example to make <code class="special">&lt;c-j&gt;</code> work like <code class="special">&lt;down&gt;</code> in wildmode, use:
<code class="example">    :cnoremap <code class="special">&lt;expr&gt;</code> <code class="special">&lt;C-j&gt;</code> wildmenumode() ? "\<code class="special">&lt;Down&gt;</code>\<code class="special">&lt;Tab&gt;</code>" : "\<code class="special">&lt;c-j&gt;</code>"</code>

		(<code class="note">Note</code>, this needs the 'wildcharm' option set appropriately).


win_findbuf(<code class="special">{bufnr}</code>)					<b class="vimtag">*<a name="win_findbuf()">win_findbuf()</a>*</b>
		Returns a list with window IDs for windows that contain buffer
		<code class="special">{bufnr}</code>.  When there is none the list is empty.

win_getid([<code class="special">{win}</code> [, <code class="special">{tab}</code>]])				<b class="vimtag">*<a name="win_getid()">win_getid()</a>*</b>
		Get the window ID for the specified window.
		When <code class="special">{win}</code> is missing use the current window.
		With <code class="special">{win}</code> this is the window number.  The top window has
		number 1.
		Without <code class="special">{tab}</code> use the current tab, otherwise the tab with
		number <code class="special">{tab}</code>.  The first tab has number one.
		Return zero if the window cannot be found.

win_gotoid(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="win_gotoid()">win_gotoid()</a>*</b>
		Go to window with ID <code class="special">{expr}</code>.  This may also change the current
		tabpage.
		Return 1 if successful, 0 if the window cannot be found.

win_id2tabwin(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="win_id2tabwin()">win_id2tabwin()</a>*</b>
		Return a list with the tab number and window number of window
		with ID <code class="special">{expr}</code>: [tabnr, winnr].
		Return [0, 0] if the window cannot be found.

win_id2win(<code class="special">{expr}</code>)					<b class="vimtag">*<a name="win_id2win()">win_id2win()</a>*</b>
		Return the window number of window with ID <code class="special">{expr}</code>.
		Return 0 if the window cannot be found in the current tabpage.

							<b class="vimtag">*<a name="winbufnr()">winbufnr()</a>*</b>
winbufnr(<code class="special">{nr}</code>)	The result is a Number, which is the number of the buffer
		associated with window <code class="special">{nr}</code>.  When <code class="special">{nr}</code> is zero, the number of
		the buffer in the current window is returned.  When window
		<code class="special">{nr}</code> doesn't exist, -1 is returned.
		Example:
<code class="example">  :echo "The file in the current window is " . bufname(winbufnr(0))</code>

							<b class="vimtag">*<a name="wincol()">wincol()</a>*</b>
wincol()	The result is a Number, which is the virtual column of the
		cursor in the window.  This is counting screen cells from the
		left side of the window.  The leftmost column is one.

winheight(<code class="special">{nr}</code>)						<b class="vimtag">*<a name="winheight()">winheight()</a>*</b>
		The result is a Number, which is the height of window <code class="special">{nr}</code>.
		When <code class="special">{nr}</code> is zero, the height of the current window is
		returned.  When window <code class="special">{nr}</code> doesn't exist, -1 is returned.
		An existing window always has a height of zero or more.
		Examples:
<code class="example">  :echo "The current window has " . winheight(0) . " lines."</code>

							<b class="vimtag">*<a name="winline()">winline()</a>*</b>
winline()	The result is a Number, which is the screen line of the cursor
		in the window.	This is counting screen lines from the top of
		the window.  The first line is one.
		If the cursor was moved the view on the file will be updated
		first, this may cause a scroll.

							<b class="vimtag">*<a name="winnr()">winnr()</a>*</b>
winnr([<code class="special">{arg}</code>])	The result is a Number, which is the number of the current
		window.  The top window has number 1.
		When the optional argument is "$", the number of the
		last window is returned (the window count).
<code class="example">			let window_count = winnr('$')</code>
		When the optional argument is "#", the number of the last
		accessed window is returned (where |<a href="windows.html#CTRL-W_p">CTRL-W_p</a>| goes to).
		If there is no previous window or it is in another tab page 0
		is returned.
		The number can be used with |<a href="windows.html#CTRL-W_w">CTRL-W_w</a>| and ":wincmd w"
		|<a href="windows.html#:wincmd">:wincmd</a>|.
		Also see |<a href="eval.html#tabpagewinnr()">tabpagewinnr()</a>|.

							<b class="vimtag">*<a name="winrestcmd()">winrestcmd()</a>*</b>
winrestcmd()	Returns a sequence of |<a href="windows.html#:resize">:resize</a>| commands that should restore
		the current window sizes.  Only works properly when no windows
		are opened or closed and the current window and tab page is
		unchanged.
		Example:
<code class="example">			:let cmd = winrestcmd()</code>
<code class="example">			:call MessWithWindowSizes()</code>
<code class="example">			:exe cmd</code>

							<b class="vimtag">*<a name="winrestview()">winrestview()</a>*</b>
winrestview(<code class="special">{dict}</code>)
		Uses the |<a href="eval.html#Dictionary">Dictionary</a>| returned by |<a href="eval.html#winsaveview()">winsaveview()</a>| to restore
		the view of the current window.
		<code class="note">Note:</code> The <code class="special">{dict}</code> does not have to contain all values, that are
		returned by |<a href="eval.html#winsaveview()">winsaveview()</a>|. If values are missing, those
		settings won't be restored. So you can use:
<code class="example">		    :call winrestview(<code class="special">{'curswant': 4}</code>)</code>

		This will only set the curswant value (the column the cursor
		wants to move on vertical movements) of the cursor to column 5
		(yes, that is 5), while all other settings will remain the
		same. This is useful, if you set the cursor position manually.

		If you have changed the values the result is unpredictable.
		If the window size changed the result won't be the same.

							<b class="vimtag">*<a name="winsaveview()">winsaveview()</a>*</b>
winsaveview()	Returns a |<a href="eval.html#Dictionary">Dictionary</a>| that contains information to restore
		the view of the current window.  Use |<a href="eval.html#winrestview()">winrestview()</a>| to
		restore the view.
		This is useful if you have a mapping that jumps around in the
		buffer and you want to go back to the original view.
		This does not save fold information.  Use the 'foldenable'
		option to temporarily switch off folding, so that folds are
		not opened when moving around. This may have side effects.
		The return value includes:
			lnum		cursor line number
			col		cursor column (<code class="note">Note:</code> the first column
					zero, as opposed to what getpos()
					returns)
			coladd		cursor column offset for 'virtualedit'
			curswant	column for vertical movement
			topline		first line in the window
			topfill		filler lines, only in diff mode
			leftcol		first column displayed
			skipcol		columns skipped
		<code class="note">Note</code> that no option values are saved.


winwidth(<code class="special">{nr}</code>)						<b class="vimtag">*<a name="winwidth()">winwidth()</a>*</b>
		The result is a Number, which is the width of window <code class="special">{nr}</code>.
		When <code class="special">{nr}</code> is zero, the width of the current window is
		returned.  When window <code class="special">{nr}</code> doesn't exist, -1 is returned.
		An existing window always has a width of zero or more.
		Examples:
<code class="example">  :echo "The current window has " . winwidth(0) . " columns."</code>
<code class="example">  :if winwidth(0) &lt;= 50</code>
<code class="example">  :  exe "normal 50\<code class="special">&lt;C-W&gt;</code>|"</code>
<code class="example">  :endif</code>

wordcount()						<b class="vimtag">*<a name="wordcount()">wordcount()</a>*</b>
		The result is a dictionary of byte/chars/word statistics for
		the current buffer.  This is the same info as provided by
		|<a href="editing.html#g_CTRL-G">g_CTRL-G</a>|
		The return value includes:
			bytes		Number of bytes in the buffer
			chars		Number of chars in the buffer
			words		Number of words in the buffer
			cursor_bytes    Number of bytes before cursor position
					(not in Visual mode)
			cursor_chars    Number of chars before cursor position
					(not in Visual mode)
			cursor_words    Number of words before cursor position
					(not in Visual mode)
			visual_bytes    Number of bytes visually selected
			                (only in Visual mode)
			visual_chars    Number of chars visually selected
			                (only in Visual mode)
			visual_words    Number of chars visually selected
			                (only in Visual mode)


							<b class="vimtag">*<a name="writefile()">writefile()</a>*</b>
writefile(<code class="special">{list}</code>, <code class="special">{fname}</code> [, <code class="special">{flags}</code>])
		Write |<a href="eval.html#List">List</a>| <code class="special">{list}</code> to file <code class="special">{fname}</code>.  Each list item is
		separated with a NL.  Each list item must be a String or
		Number.
		When <code class="special">{flags}</code> contains "b" then binary mode is used: There will
		not be a NL after the last list item.  An empty item at the
		end does cause the last line in the file to end in a NL.

		When <code class="special">{flags}</code> contains "a" then append mode is used, lines are
		append to the file:
<code class="example">			:call writefile(["foo"], "event.log", "a")</code>
<code class="example">			:call writefile(["bar"], "event.log", "a")</code>

		All NL characters are replaced with a NUL character.
		Inserting CR characters needs to be done before passing <code class="special">{list}</code>
		to writefile().
		An existing file is overwritten, if possible.
		When the write fails -1 is returned, otherwise 0.  There is an
		error message if the file can't be created or when writing
		fails.
		Also see |<a href="eval.html#readfile()">readfile()</a>|.
		To copy a file byte for byte:
<code class="example">			:let fl = readfile("foo", "b")</code>
<code class="example">			:call writefile(fl, "foocopy", "b")</code>
<code class="example"></code>
<code class="example"></code>
xor(<code class="special">{expr}</code>, <code class="special">{expr}</code>)					<b class="vimtag">*<a name="xor()">xor()</a>*</b>
		Bitwise XOR on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example:
<code class="example">			:let bits = xor(bits, 0x80)</code>



							<b class="vimtag">*<a name="feature-list">feature-list</a>*</b>
There are four types of features:
1.  Features that are only supported when they have been enabled when Vim
    was compiled |<a href="various.html#+feature-list">+feature-list</a>|.  Example:
<code class="example">	:if has("cindent")</code>
2.  Features that are only supported when certain conditions have been met.
    Example:
<code class="example">	:if has("gui_running")</code>
							<b class="vimtag">*<a name="has-patch">has-patch</a>*</b>
3.  Included patches.  The "patch123" feature means that patch 123 has been
    included.  <code class="note">Note</code> that this form does not check the version of Vim, you need
    to inspect |<a href="eval.html#v:version">v:version</a>| for that.
    Example (checking version 6.2.148 or later):
<code class="example">	:if v:version &gt; 602 || v:version == 602 &amp;&amp; has("patch148")</code>
    <code class="note">Note</code> that it's possible for patch 147 to be omitted even though 148 is
    included.

4.  Beyond a certain version or at a certain version and including a specific
    patch.  The "patch-7.4.237" feature means that the Vim version is 7.5 or
    later, or it is version 7.4 and patch 237 was included.
    <code class="note">Note</code> that this only works for patch 7.4.237 and later, before that you
    need to use the example above that checks v:version.  Example:
<code class="example">	:if has("patch-7.4.248")</code>
    <code class="note">Note</code> that it's possible for patch 147 to be omitted even though 148 is
    included.

acl			Compiled with |<a href="editing.html#ACL">ACL</a>| support.
all_builtin_terms	Compiled with all builtin terminals enabled.
amiga			Amiga version of Vim.
arabic			Compiled with Arabic support |<a href="arabic.html#Arabic">Arabic</a>|.
arp			Compiled with ARP support (Amiga).
autocmd			Compiled with autocommand support. |<a href="autocmd.html#autocommand">autocommand</a>|
balloon_eval		Compiled with |<a href="debugger.html#balloon-eval">balloon-eval</a>| support.
balloon_multiline	GUI supports multiline balloons.
beos			BeOS version of Vim.
browse			Compiled with |<a href="editing.html#:browse">:browse</a>| support, and browse() will
			work.
browsefilter		Compiled with support for |<a href="editing.html#browsefilter">browsefilter</a>|.
builtin_terms		Compiled with some builtin terminals.
byte_offset		Compiled with support for 'o' in 'statusline'
cindent			Compiled with 'cindent' support.
clientserver		Compiled with remote invocation support |<a href="remote.html#clientserver">clientserver</a>|.
clipboard		Compiled with 'clipboard' support.
cmdline_compl		Compiled with |<a href="cmdline.html#cmdline-completion">cmdline-completion</a>| support.
cmdline_hist		Compiled with |<a href="cmdline.html#cmdline-history">cmdline-history</a>| support.
cmdline_info		Compiled with 'showcmd' and 'ruler' support.
comments		Compiled with |<a href="options.html#'comments'">'comments'</a>| support.
compatible		Compiled to be very Vi compatible.
cryptv			Compiled with encryption support |<a href="editing.html#encryption">encryption</a>|.
cscope			Compiled with |<a href="if_cscop.html#cscope">cscope</a>| support.
debug			Compiled with "DEBUG" defined.
dialog_con		Compiled with console dialog support.
dialog_gui		Compiled with GUI dialog support.
diff			Compiled with |<a href="diff.html#vimdiff">vimdiff</a>| and 'diff' support.
digraphs		Compiled with support for digraphs.
directx			Compiled with support for Direct-X and 'renderoptions'.
dnd			Compiled with support for the "~ register |<a href="change.html#quote_%7E">quote_~</a>|.
dos16			16 bits DOS version of Vim.
dos32			32 bits DOS (DJGPP) version of Vim.
ebcdic			Compiled on a machine with ebcdic character set.
emacs_tags		Compiled with support for Emacs tags.
eval			Compiled with expression evaluation support.  Always
			true, of course!
ex_extra		|<a href="various.html#+ex_extra">+ex_extra</a>|, always true now
extra_search		Compiled with support for |<a href="options.html#'incsearch'">'incsearch'</a>| and
			|<a href="options.html#'hlsearch'">'hlsearch'</a>|
farsi			Compiled with Farsi support |<a href="farsi.html#farsi">farsi</a>|.
file_in_path		Compiled with support for |<a href="editing.html#gf">gf</a>| and |<a href="cmdline.html#%3Ccfile%3E">&lt;cfile&gt;</a>|
filterpipe		When 'shelltemp' is off pipes are used for shell
			read/write/filter commands
find_in_path		Compiled with support for include file searches
			|<a href="various.html#+find_in_path">+find_in_path</a>|.
float			Compiled with support for |<a href="eval.html#Float">Float</a>|.
fname_case		Case in file names matters (for Amiga, MS-DOS, and
			Windows this is not present).
folding			Compiled with |<a href="fold.html#folding">folding</a>| support.
footer			Compiled with GUI footer support. |<a href="debugger.html#gui-footer">gui-footer</a>|
fork			Compiled to use fork()/exec() instead of system().
gettext			Compiled with message translation |<a href="mlang.html#multi-lang">multi-lang</a>|
gui			Compiled with GUI enabled.
gui_athena		Compiled with Athena GUI.
gui_gnome		Compiled with Gnome support (gui_gtk is also defined).
gui_gtk			Compiled with GTK+ GUI (any version).
gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
gui_gtk3		Compiled with GTK+ 3 GUI (gui_gtk is also defined).
gui_mac			Compiled with Macintosh GUI.
gui_motif		Compiled with Motif GUI.
gui_photon		Compiled with Photon GUI.
gui_running		Vim is running in the GUI, or it will start soon.
gui_win32		Compiled with MS Windows Win32 GUI.
gui_win32s		idem, and Win32s system being used (Windows 3.1)
hangul_input		Compiled with Hangul input support. |<a href="hangulin.html#hangul">hangul</a>|
iconv			Can use iconv() for conversion.
insert_expand		Compiled with support for <code class="keystroke">CTRL-X</code> expansion commands in
			Insert mode.
jumplist		Compiled with |<a href="motion.html#jumplist">jumplist</a>| support.
keymap			Compiled with 'keymap' support.
langmap			Compiled with 'langmap' support.
libcall			Compiled with |<a href="eval.html#libcall()">libcall()</a>| support.
linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
			'breakindent' support.
lispindent		Compiled with support for lisp indenting.
listcmds		Compiled with commands for the buffer list |<a href="windows.html#:files">:files</a>|
			and the argument list |<a href="editing.html#arglist">arglist</a>|.
localmap		Compiled with local mappings and abbr. |<a href="map.html#:map-local">:map-local</a>|
lua			Compiled with Lua interface |<a href="if_lua.html#Lua">Lua</a>|.
mac			Any Macintosh version of Vim.
macunix			Compiled for OS X, with darwin
osx			Compiled for OS X, with or without darwin
menu			Compiled with support for |<a href="gui.html#:menu">:menu</a>|.
mksession		Compiled with support for |<a href="starting.html#:mksession">:mksession</a>|.
modify_fname		Compiled with file name modifiers. |<a href="cmdline.html#filename-modifiers">filename-modifiers</a>|
mouse			Compiled with support mouse.
mouse_dec		Compiled with support for Dec terminal mouse.
mouse_gpm		Compiled with support for gpm (Linux console mouse)
mouse_netterm		Compiled with support for netterm mouse.
mouse_pterm		Compiled with support for qnx pterm mouse.
mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
mouse_sgr		Compiled with support for sgr mouse.
mouse_urxvt		Compiled with support for urxvt mouse.
mouse_xterm		Compiled with support for xterm mouse.
mouseshape		Compiled with support for 'mouseshape'.
multi_byte		Compiled with support for 'encoding'
multi_byte_encoding	'encoding' is set to a multi-byte encoding.
multi_byte_ime		Compiled with support for IME input method.
multi_lang		Compiled with support for multiple languages.
mzscheme		Compiled with MzScheme interface |<a href="if_mzsch.html#mzscheme">mzscheme</a>|.
netbeans_enabled	Compiled with support for |<a href="netbeans.html#netbeans">netbeans</a>| and connected.
netbeans_intg		Compiled with support for |<a href="netbeans.html#netbeans">netbeans</a>|.
ole			Compiled with OLE automation support for Win32.
os2			OS/2 version of Vim.
path_extra		Compiled with up/downwards search in 'path' and 'tags'
perl			Compiled with Perl interface.
persistent_undo		Compiled with support for persistent undo history.
postscript		Compiled with PostScript file printing.
printer			Compiled with |<a href="print.html#:hardcopy">:hardcopy</a>| support.
profile			Compiled with |<a href="repeat.html#:profile">:profile</a>| support.
python			Compiled with Python 2.x interface. |<a href="if_pyth.html#has-python">has-python</a>|
python3			Compiled with Python 3.x interface. |<a href="if_pyth.html#has-python">has-python</a>|
qnx			QNX version of Vim.
quickfix		Compiled with |<a href="quickfix.html#quickfix">quickfix</a>| support.
reltime			Compiled with |<a href="eval.html#reltime()">reltime()</a>| support.
rightleft		Compiled with 'rightleft' support.
ruby			Compiled with Ruby interface |<a href="if_ruby.html#ruby">ruby</a>|.
scrollbind		Compiled with 'scrollbind' support.
showcmd			Compiled with 'showcmd' support.
signs			Compiled with |<a href="sign.html#:sign">:sign</a>| support.
smartindent		Compiled with 'smartindent' support.
spell			Compiled with spell checking support |<a href="spell.html#spell">spell</a>|.
startuptime		Compiled with |<a href="starting.html#--startuptime">--startuptime</a>| support.
statusline		Compiled with support for 'statusline', 'rulerformat'
			and special formats of 'titlestring' and 'iconstring'.
sun_workshop		Compiled with support for Sun |<a href="workshop.html#workshop">workshop</a>|.
syntax			Compiled with syntax highlighting support |<a href="syntax.html#syntax">syntax</a>|.
syntax_items		There are active syntax highlighting items for the
			current buffer.
system			Compiled to use system() instead of fork()/exec().
tag_binary		Compiled with binary searching in tags files
			|<a href="tagsrch.html#tag-binary-search">tag-binary-search</a>|.
tag_old_static		Compiled with support for old static tags
			|<a href="tagsrch.html#tag-old-static">tag-old-static</a>|.
tag_any_white		Compiled with support for any white characters in tags
			files |<a href="tagsrch.html#tag-any-white">tag-any-white</a>|.
tcl			Compiled with Tcl interface.
terminfo		Compiled with terminfo instead of termcap.
termresponse		Compiled with support for |<a href="term.html#t_RV">t_RV</a>| and |<a href="eval.html#v:termresponse">v:termresponse</a>|.
termtruecolor		Compiled with true color in terminal support.
textobjects		Compiled with support for |<a href="motion.html#text-objects">text-objects</a>|.
tgetent			Compiled with tgetent support, able to use a termcap
			or terminfo file.
timers			Compiled with |<a href="eval.html#timer_start()">timer_start()</a>| support.
title			Compiled with window title support |<a href="options.html#'title'">'title'</a>|.
toolbar			Compiled with support for |<a href="gui.html#gui-toolbar">gui-toolbar</a>|.
unix			Unix version of Vim.
user_commands		User-defined commands.
vertsplit		Compiled with vertically split windows |<a href="windows.html#:vsplit">:vsplit</a>|.
vim_starting		True while initial source'ing takes place. |<a href="starting.html#startup">startup</a>|
			<b class="vimtag">*<a name="vim_starting">vim_starting</a>*</b>
viminfo			Compiled with viminfo support.
virtualedit		Compiled with 'virtualedit' option.
visual			Compiled with Visual mode.
visualextra		Compiled with extra Visual mode commands.
			|<a href="visual.html#blockwise-operators">blockwise-operators</a>|.
vms			VMS version of Vim.
vreplace		Compiled with |<a href="change.html#gR">gR</a>| and |<a href="change.html#gr">gr</a>| commands.
wildignore		Compiled with 'wildignore' option.
wildmenu		Compiled with 'wildmenu' option.
win32			Win32 version of Vim (MS-Windows 95 and later, 32 or
			64 bits)
win32unix		Win32 version of Vim, using Unix files (Cygwin)
win64			Win64 version of Vim (MS-Windows 64 bit).
win95			Win32 version for MS-Windows 95/98/ME.
winaltkeys		Compiled with 'winaltkeys' option.
windows			Compiled with support for more than one window.
writebackup		Compiled with 'writebackup' default on.
xfontset		Compiled with X fontset support |<a href="mbyte.html#xfontset">xfontset</a>|.
xim			Compiled with X input method support |<a href="mbyte.html#xim">xim</a>|.
xpm			Compiled with pixmap support.
xpm_w32			Compiled with pixmap support for Win32. (Only for
			backward compatibility. Use "xpm" instead.)
xsmp			Compiled with X session management support.
xsmp_interact		Compiled with interactive X session management support.
xterm_clipboard		Compiled with support for xterm clipboard.
xterm_save		Compiled with support for saving and restoring the
			xterm screen.
x11			Compiled with X11 support.

							<b class="vimtag">*<a name="string-match">string-match</a>*</b>
Matching a pattern in a String

A regexp pattern as explained at |<a href="pattern.html#pattern">pattern</a>| is normally used to find a match in
the buffer lines.  When a pattern is used to find a match in a String, almost
everything works in the same way.  The difference is that a String is handled
like it is one line.  When it contains a "\n" character, this is not seen as a
line break for the pattern.  It can be matched with a "\n" in the pattern, or
with ".".  Example:
<code class="example">	:let a = "aaaa\nxxxx"</code>
<code class="example">	:echo matchstr(a, "..\n..")</code>
<code class="example">	aa</code>
<code class="example">	xx</code>
<code class="example">	:echo matchstr(a, "a.x")</code>
<code class="example">	a</code>
<code class="example">	x</code>
<code class="example"></code>
Don't forget that "^" will only match at the first character of the String and
"$" at the last character of the string.  They don't match after or before a
"\n".

</pre><hr><pre>5. Defining functions					<b class="vimtag">*<a name="user-functions">user-functions</a>*</b>

New functions can be defined.  These can be called just like builtin
functions.  The function executes a sequence of Ex commands.  Normal mode
commands can be executed with the |<a href="various.html#:normal">:normal</a>| command.

The function name must start with an uppercase letter, to avoid confusion with
builtin functions.  To prevent from using the same name in different scripts
avoid obvious, short names.  A good habit is to start the function name with
the name of the script, e.g., "HTMLcolor()".

It's also possible to use curly braces, see |<a href="eval.html#curly-braces-names">curly-braces-names</a>|.  And the
|<a href="eval.html#autoload">autoload</a>| facility is useful to define a function only when it's called.

							<b class="vimtag">*<a name="local-function">local-function</a>*</b>
A function local to a script must start with "s:".  A local script function
can only be called from within the script and from functions, user commands
and autocommands defined in the script.  It is also possible to call the
function from a mapping defined in the script, but then |<a href="map.html#%3CSID%3E">&lt;SID&gt;</a>| must be used
instead of "s:" when the mapping is expanded outside of the script.
There are only script-local functions, no buffer-local or window-local
functions.

					<b class="vimtag">*<a name=":fu">:fu</a>*</b> <b class="vimtag">*<a name=":function">:function</a>*</b> <b class="vimtag">*<a name="E128">E128</a>*</b> <b class="vimtag">*<a name="E129">E129</a>*</b> <b class="vimtag">*<a name="E123">E123</a>*</b>
:fu[nction]		List all functions and their arguments.

:fu[nction] <code class="special">{name}</code>	List function <code class="special">{name}</code>.
			<code class="special">{name}</code> can also be a |<a href="eval.html#Dictionary">Dictionary</a>| entry that is a
			|<a href="eval.html#Funcref">Funcref</a>|:
<code class="example">				:function dict.init</code>
<code class="example"></code>
:fu[nction] /<code class="special">{pattern}</code>	List functions with a name matching <code class="special">{pattern}</code>.
			Example that lists all functions ending with "File":
<code class="example">				:function /File$</code>

							<b class="vimtag">*<a name=":function-verbose">:function-verbose</a>*</b>
When 'verbose' is non-zero, listing a function will also display where it was
last defined. Example:
<code class="example"></code>
<code class="example">    :verbose function SetFileTypeSH</code>
<code class="example">	function SetFileTypeSH(name)</code>
<code class="example">	    Last set from /usr/share/vim/vim-7.0/filetype.vim</code>

See |<a href="various.html#:verbose-cmd">:verbose-cmd</a>| for more information.

						<b class="vimtag">*<a name="E124">E124</a>*</b> <b class="vimtag">*<a name="E125">E125</a>*</b> <b class="vimtag">*<a name="E853">E853</a>*</b> <b class="vimtag">*<a name="E884">E884</a>*</b>
:fu[nction][!] <code class="special">{name}</code>([arguments]) <code class="special">[range]</code> [abort] [dict]
			Define a new function by the name <code class="special">{name}</code>.  The name
			must be made of alphanumeric characters and '_', and
			must start with a capital or "s:" (see above).  <code class="note">Note</code>
			that using "b:" or "g:" is not allowed. (since patch
			7.4.260 E884 is given if the function name has a colon
			in the name, e.g. for "foo:bar()".  Before that patch
			no error was given).

			<code class="special">{name}</code> can also be a |<a href="eval.html#Dictionary">Dictionary</a>| entry that is a
			|<a href="eval.html#Funcref">Funcref</a>|:
<code class="example">				:function dict.init(arg)</code>
			"dict" must be an existing dictionary.	The entry
			"init" is added if it didn't exist yet.  Otherwise [!]
			is required to overwrite an existing function.	The
			result is a |<a href="eval.html#Funcref">Funcref</a>| to a numbered function.  The
			function can only be used with a |<a href="eval.html#Funcref">Funcref</a>| and will be
			deleted if there are no more references to it.
								<b class="vimtag">*<a name="E127">E127</a>*</b> <b class="vimtag">*<a name="E122">E122</a>*</b>
			When a function by this name already exists and [!] is
			not used an error message is given.  When [!] is used,
			an existing function is silently replaced.  Unless it
			is currently being executed, that is an error.

			For the <code class="special">{arguments}</code> see |<a href="eval.html#function-argument">function-argument</a>|.

					<b class="vimtag">*<a name=":func-range">:func-range</a>*</b> <b class="vimtag">*<a name="a:firstline">a:firstline</a>*</b> <b class="vimtag">*<a name="a:lastline">a:lastline</a>*</b>
			When the <code class="special">[range]</code> argument is added, the function is
			expected to take care of a range itself.  The range is
			passed as "a:firstline" and "a:lastline".  If <code class="special">[range]</code>
			is excluded, ":<code class="special">{range}</code>call" will call the function for
			each line in the range, with the cursor on the start
			of each line.  See |<a href="eval.html#function-range-example">function-range-example</a>|.
			The cursor is still moved to the first line of the
			range, as is the case with all Ex commands.
								<b class="vimtag">*<a name=":func-abort">:func-abort</a>*</b>
			When the [abort] argument is added, the function will
			abort as soon as an error is detected.
								<b class="vimtag">*<a name=":func-dict">:func-dict</a>*</b>
			When the [dict] argument is added, the function must
			be invoked through an entry in a |<a href="eval.html#Dictionary">Dictionary</a>|.	The
			local variable "self" will then be set to the
			dictionary.  See |<a href="eval.html#Dictionary-function">Dictionary-function</a>|.

						<b class="vimtag">*<a name="function-search-undo">function-search-undo</a>*</b>
			The last used search pattern and the redo command "."
			will not be changed by the function.  This also
			implies that the effect of |<a href="pattern.html#:nohlsearch">:nohlsearch</a>| is undone
			when the function returns.

					<b class="vimtag">*<a name=":endf">:endf</a>*</b> <b class="vimtag">*<a name=":endfunction">:endfunction</a>*</b> <b class="vimtag">*<a name="E126">E126</a>*</b> <b class="vimtag">*<a name="E193">E193</a>*</b>
:endf[unction]		The end of a function definition.  Must be on a line
			by its own, without other commands.

					<b class="vimtag">*<a name=":delf">:delf</a>*</b> <b class="vimtag">*<a name=":delfunction">:delfunction</a>*</b> <b class="vimtag">*<a name="E130">E130</a>*</b> <b class="vimtag">*<a name="E131">E131</a>*</b>
:delf[unction] <code class="special">{name}</code>	Delete function <code class="special">{name}</code>.
			<code class="special">{name}</code> can also be a |<a href="eval.html#Dictionary">Dictionary</a>| entry that is a
			|<a href="eval.html#Funcref">Funcref</a>|:
<code class="example">				:delfunc dict.init</code>
			This will remove the "init" entry from "dict".	The
			function is deleted if there are no more references to
			it.
							<b class="vimtag">*<a name=":retu">:retu</a>*</b> <b class="vimtag">*<a name=":return">:return</a>*</b> <b class="vimtag">*<a name="E133">E133</a>*</b>
:retu[rn] [expr]	Return from a function.  When "[expr]" is given, it is
			evaluated and returned as the result of the function.
			If "[expr]" is not given, the number 0 is returned.
			When a function ends without an explicit ":return",
			the number 0 is returned.
			<code class="note">Note</code> that there is no check for unreachable lines,
			thus there is no warning if commands follow ":return".

			If the ":return" is used after a |<a href="eval.html#:try">:try</a>| but before the
			matching |<a href="eval.html#:finally">:finally</a>| (if present), the commands
			following the ":finally" up to the matching |<a href="eval.html#:endtry">:endtry</a>|
			are executed first.  This process applies to all
			nested ":try"s inside the function.  The function
			returns at the outermost ":endtry".

						<b class="vimtag">*<a name="function-argument">function-argument</a>*</b> <b class="vimtag">*<a name="a:var">a:var</a>*</b>
An argument can be defined by giving its name.	In the function this can then
be used as "a:name" ("a:" for argument).
					<b class="vimtag">*<a name="a:0">a:0</a>*</b> <b class="vimtag">*<a name="a:1">a:1</a>*</b> <b class="vimtag">*<a name="a:000">a:000</a>*</b> <b class="vimtag">*<a name="E740">E740</a>*</b> <b class="vimtag">*<a name="...">...</a>*</b>
Up to 20 arguments can be given, separated by commas.  After the named
arguments an argument "..." can be specified, which means that more arguments
may optionally be following.  In the function the extra arguments can be used
as "a:1", "a:2", etc.  "a:0" is set to the number of extra arguments (which
can be 0).  "a:000" is set to a |<a href="eval.html#List">List</a>| that contains these arguments.  <code class="note">Note</code>
that "a:1" is the same as "a:000[0]".
								<b class="vimtag">*<a name="E742">E742</a>*</b>
The a: scope and the variables in it cannot be changed, they are fixed.
However, if a |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| is used, you can change their contents.
Thus you can pass a |<a href="eval.html#List">List</a>| to a function and have the function add an item to
it.  If you want to make sure the function cannot change a |<a href="eval.html#List">List</a>| or
|<a href="eval.html#Dictionary">Dictionary</a>| use |<a href="eval.html#:lockvar">:lockvar</a>|.

When not using "...", the number of arguments in a function call must be equal
to the number of named arguments.  When using "...", the number of arguments
may be larger.

It is also possible to define a function without any arguments.  You must
still supply the () then.  The body of the function follows in the next lines,
until the matching |<a href="eval.html#:endfunction">:endfunction</a>|.  It is allowed to define another function
inside a function body.

							<b class="vimtag">*<a name="local-variables">local-variables</a>*</b>
Inside a function variables can be used.  These are local variables, which
will disappear when the function returns.  Global variables need to be
accessed with "g:".

Example:
<code class="example">  :function Table(title, ...)</code>
<code class="example">  :  echohl Title</code>
<code class="example">  :  echo a:title</code>
<code class="example">  :  echohl None</code>
<code class="example">  :  echo a:0 . " items:"</code>
<code class="example">  :  for s in a:000</code>
<code class="example">  :    echon ' ' . s</code>
<code class="example">  :  endfor</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
This function can then be called with:
<code class="example">  call Table("Table", "line1", "line2")</code>
<code class="example">  call Table("Empty Table")</code>
<code class="example"></code>
To return more than one value, return a |<a href="eval.html#List">List</a>|:
<code class="example">  :function Compute(n1, n2)</code>
<code class="example">  :  if a:n2 == 0</code>
<code class="example">  :    return ["fail", 0]</code>
<code class="example">  :  endif</code>
<code class="example">  :  return ["ok", a:n1 / a:n2]</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
This function can then be called with:
<code class="example">  :let [success, div] = Compute(102, 6)</code>
<code class="example">  :if success == "ok"</code>
<code class="example">  :  echo div</code>
<code class="example">  :endif</code>

						<b class="vimtag">*<a name=":cal">:cal</a>*</b> <b class="vimtag">*<a name=":call">:call</a>*</b> <b class="vimtag">*<a name="E107">E107</a>*</b> <b class="vimtag">*<a name="E117">E117</a>*</b>
:<code class="special">[range]</code>cal[l] <code class="special">{name}</code>([arguments])
		Call a function.  The name of the function and its arguments
		are as specified with |<a href="eval.html#:function">:function</a>|.  Up to 20 arguments can be
		used.  The returned value is discarded.
		Without a range and for functions that accept a range, the
		function is called once.  When a range is given the cursor is
		positioned at the start of the first line before executing the
		function.
		When a range is given and the function doesn't handle it
		itself, the function is executed for each line in the range,
		with the cursor in the first column of that line.  The cursor
		is left at the last line (possibly moved by the last function
		call).	The arguments are re-evaluated for each line.  Thus
		this works:
						<b class="vimtag">*<a name="function-range-example">function-range-example</a>*</b>
<code class="example">	:function Mynumber(arg)</code>
<code class="example">	:  echo line(".") . " " . a:arg</code>
<code class="example">	:endfunction</code>
<code class="example">	:1,5call Mynumber(getline("."))</code>

		The "a:firstline" and "a:lastline" are defined anyway, they
		can be used to do something different at the start or end of
		the range.

		Example of a function that handles the range itself:
<code class="example"></code>
<code class="example">	:function Cont() range</code>
<code class="example">	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '</code>
<code class="example">	:endfunction</code>
<code class="example">	:4,8call Cont()</code>

		This function inserts the continuation character "\" in front
		of all the lines in the range, except the first one.

		When the function returns a composite value it can be further
		dereferenced, but the range will not be used then.  Example:
<code class="example">	:4,8call GetDict().method()</code>
		Here GetDict() gets the range but method() does not.

								<b class="vimtag">*<a name="E132">E132</a>*</b>
The recursiveness of user functions is restricted with the |<a href="options.html#'maxfuncdepth'">'maxfuncdepth'</a>|
option.


<code class="section">AUTOMATICALLY LOADING FUNCTIONS </code>
							<b class="vimtag">*<a name="autoload-functions">autoload-functions</a>*</b>
When using many or large functions, it's possible to automatically define them
only when they are used.  There are two methods: with an autocommand and with
the "autoload" directory in 'runtimepath'.


<code class="section">Using an autocommand </code>

This is introduced in the user manual, section |<a href="usr_41.html#41.14">41.14</a>|.

The autocommand is useful if you have a plugin that is a long Vim script file.
You can define the autocommand and quickly quit the script with |<a href="repeat.html#:finish">:finish</a>|.
That makes Vim startup faster.	The autocommand should then load the same file
again, setting a variable to skip the |<a href="repeat.html#:finish">:finish</a>| command.

Use the FuncUndefined autocommand event with a pattern that matches the
function(s) to be defined.  Example:
<code class="example"></code>
<code class="example">	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim</code>
<code class="example"></code>
The file "~/vim/bufnetfuncs.vim" should then define functions that start with
"BufNet".  Also see |<a href="autocmd.html#FuncUndefined">FuncUndefined</a>|.


<code class="section">Using an autoload script </code>
							<b class="vimtag">*<a name="autoload">autoload</a>*</b> <b class="vimtag">*<a name="E746">E746</a>*</b>
This is introduced in the user manual, section |<a href="usr_41.html#41.15">41.15</a>|.

Using a script in the "autoload" directory is simpler, but requires using
exactly the right file name.  A function that can be autoloaded has a name
like this:
<code class="example"></code>
<code class="example">	:call filename#funcname()</code>
<code class="example"></code>
When such a function is called, and it is not defined yet, Vim will search the
"autoload" directories in 'runtimepath' for a script file called
"filename.vim".  For example "~/.vim/autoload/filename.vim".  That file should
then define the function like this:
<code class="example"></code>
<code class="example">	function filename#funcname()</code>
<code class="example">	   echo "Done!"</code>
<code class="example">	endfunction</code>
<code class="example"></code>
The file name and the name used before the # in the function must match
exactly, and the defined function must have the name exactly as it will be
called.

It is possible to use subdirectories.  Every # in the function name works like
a path separator.  Thus when calling a function:
<code class="example"></code>
<code class="example">	:call foo#bar#func()</code>
<code class="example"></code>
Vim will look for the file "autoload/foo/bar.vim" in 'runtimepath'.

This also works when reading a variable that has not been set yet:
<code class="example"></code>
<code class="example">	:let l = foo#bar#lvar</code>
<code class="example"></code>
However, when the autoload script was already loaded it won't be loaded again
for an unknown variable.

When assigning a value to such a variable nothing special happens.  This can
be used to pass settings to the autoload script before it's loaded:
<code class="example"></code>
<code class="example">	:let foo#bar#toggle = 1</code>
<code class="example">	:call foo#bar#func()</code>
<code class="example"></code>
<code class="note">Note</code> that when you make a mistake and call a function that is supposed to be
defined in an autoload script, but the script doesn't actually define the
function, the script will be sourced every time you try to call the function.
And you will get an error message every time.

Also <code class="note">note</code> that if you have two script files, and one calls a function in the
other and vice versa, before the used function is defined, it won't work.
Avoid using the autoload functionality at the toplevel.

Hint: If you distribute a bunch of scripts you can pack them together with the
|<a href="pi_vimball.html#vimball">vimball</a>| utility.  Also read the user manual |<a href="usr_41.html#distribute-script">distribute-script</a>|.

</pre><hr><pre>6. Curly braces names					<b class="vimtag">*<a name="curly-braces-names">curly-braces-names</a>*</b>

In most places where you can use a variable, you can use a "curly braces name"
variable.  This is a regular variable name with one or more expressions
wrapped in braces <code class="special">{}</code> like this:
<code class="example">	my_<code class="special">{adjective}</code>_variable</code>
<code class="example"></code>
When Vim encounters this, it evaluates the expression inside the braces, puts
that in place of the expression, and re-interprets the whole as a variable
name.  So in the above example, if the variable "adjective" was set to
"noisy", then the reference would be to "my_noisy_variable", whereas if
"adjective" was set to "quiet", then it would be to "my_quiet_variable".

One application for this is to create a set of variables governed by an option
value.	For example, the statement
<code class="example">	echo my_<code class="special">{&amp;background}</code>_message</code>
<code class="example"></code>
would output the contents of "my_dark_message" or "my_light_message" depending
on the current value of 'background'.

You can use multiple brace pairs:
<code class="example">	echo my_<code class="special">{adverb}</code>_<code class="special">{adjective}</code>_message</code>
..or even nest them:
<code class="example">	echo my_<code class="special">{ad{end_of_word}</code>}_message</code>
where "end_of_word" is either "verb" or "jective".

However, the expression inside the braces must evaluate to a valid single
variable name, e.g. this is invalid:
<code class="example">	:let foo='a + b'</code>
<code class="example">	:echo c<code class="special">{foo}</code>d</code>
.. since the result of expansion is "ca + bd", which is not a variable name.

						<b class="vimtag">*<a name="curly-braces-function-names">curly-braces-function-names</a>*</b>
You can call and define functions by an evaluated name in a similar way.
Example:
<code class="example">	:let func_end='whizz'</code>
<code class="example">	:call my_func_<code class="special">{func_end}</code>(parameter)</code>
<code class="example"></code>
This would call the function "my_func_whizz(parameter)".

This does NOT work:
<code class="example">  :let i = 3</code>
<code class="example">  :let @<code class="special">{i}</code> = ''  " error</code>
<code class="example">  :echo @<code class="special">{i}</code>      " error</code>
<code class="example"></code>
</pre><hr><pre>7. Commands						<b class="vimtag">*<a name="expression-commands">expression-commands</a>*</b>

:let <code class="special">{var-name}</code> = <code class="special">{expr1}</code>				<b class="vimtag">*<a name=":let">:let</a>*</b> <b class="vimtag">*<a name="E18">E18</a>*</b>
			Set internal variable <code class="special">{var-name}</code> to the result of the
			expression <code class="special">{expr1}</code>.  The variable will get the type
			from the <code class="special">{expr}</code>.  If <code class="special">{var-name}</code> didn't exist yet, it
			is created.

:let <code class="special">{var-name}</code>[<code class="special">{idx}</code>] = <code class="special">{expr1}</code>			<b class="vimtag">*<a name="E689">E689</a>*</b>
			Set a list item to the result of the expression
			<code class="special">{expr1}</code>.  <code class="special">{var-name}</code> must refer to a list and <code class="special">{idx}</code>
			must be a valid index in that list.  For nested list
			the index can be repeated.
			This cannot be used to add an item to a |<a href="eval.html#List">List</a>|.
			This cannot be used to set a byte in a String.	You
			can do that like this:
<code class="example">				:let var = var[0:2] . 'X' . var[4:]</code>

							<b class="vimtag">*<a name="E711">E711</a>*</b> <b class="vimtag">*<a name="E719">E719</a>*</b>
:let <code class="special">{var-name}</code>[<code class="special">{idx1}</code>:<code class="special">{idx2}</code>] = <code class="special">{expr1}</code>		<b class="vimtag">*<a name="E708">E708</a>*</b> <b class="vimtag">*<a name="E709">E709</a>*</b> <b class="vimtag">*<a name="E710">E710</a>*</b>
			Set a sequence of items in a |<a href="eval.html#List">List</a>| to the result of
			the expression <code class="special">{expr1}</code>, which must be a list with the
			correct number of items.
			<code class="special">{idx1}</code> can be omitted, zero is used instead.
			<code class="special">{idx2}</code> can be omitted, meaning the end of the list.
			When the selected range of items is partly past the
			end of the list, items will be added.

					<b class="vimtag">*<a name=":let+%20">:let+=</a>*</b> <b class="vimtag">*<a name=":let-%20">:let-=</a>*</b> <b class="vimtag">*<a name=":let.%20">:let.=</a>*</b> <b class="vimtag">*<a name="E734">E734</a>*</b>
:let <code class="special">{var}</code> += <code class="special">{expr1}</code>	Like ":let <code class="special">{var}</code> = <code class="special">{var}</code> + <code class="special">{expr1}</code>".
:let <code class="special">{var}</code> -= <code class="special">{expr1}</code>	Like ":let <code class="special">{var}</code> = <code class="special">{var}</code> - <code class="special">{expr1}</code>".
:let <code class="special">{var}</code> .= <code class="special">{expr1}</code>	Like ":let <code class="special">{var}</code> = <code class="special">{var}</code> . <code class="special">{expr1}</code>".
			These fail if <code class="special">{var}</code> was not set yet and when the type
			of <code class="special">{var}</code> and <code class="special">{expr1}</code> don't fit the operator.


:let $<code class="special">{env-name}</code> = <code class="special">{expr1}</code>			<b class="vimtag">*<a name=":let-environment">:let-environment</a>*</b> <b class="vimtag">*<a name=":let-$">:let-$</a>*</b>
			Set environment variable <code class="special">{env-name}</code> to the result of
			the expression <code class="special">{expr1}</code>.  The type is always String.
:let $<code class="special">{env-name}</code> .= <code class="special">{expr1}</code>
			Append <code class="special">{expr1}</code> to the environment variable <code class="special">{env-name}</code>.
			If the environment variable didn't exist yet this
			works like "=".

:let @<code class="special">{reg-name}</code> = <code class="special">{expr1}</code>			<b class="vimtag">*<a name=":let-register">:let-register</a>*</b> <b class="vimtag">*<a name=":let-@">:let-@</a>*</b>
			Write the result of the expression <code class="special">{expr1}</code> in register
			<code class="special">{reg-name}</code>.  <code class="special">{reg-name}</code> must be a single letter, and
			must be the name of a writable register (see
			|<a href="change.html#registers">registers</a>|).  "@@" can be used for the unnamed
			register, "@/" for the search pattern.
			If the result of <code class="special">{expr1}</code> ends in a <code class="special">&lt;CR&gt;</code> or <code class="special">&lt;NL&gt;</code>, the
			register will be linewise, otherwise it will be set to
			characterwise.
			This can be used to clear the last search pattern:
<code class="example">				:let @/ = ""</code>
			This is different from searching for an empty string,
			that would match everywhere.

:let @<code class="special">{reg-name}</code> .= <code class="special">{expr1}</code>
			Append <code class="special">{expr1}</code> to register <code class="special">{reg-name}</code>.	If the
			register was empty it's like setting it to <code class="special">{expr1}</code>.

:let &amp;<code class="special">{option-name}</code> = <code class="special">{expr1}</code>			<b class="vimtag">*<a name=":let-option">:let-option</a>*</b> <b class="vimtag">*<a name=":let-&">:let-&amp;</a>*</b>
			Set option <code class="special">{option-name}</code> to the result of the
			expression <code class="special">{expr1}</code>.  A String or Number value is
			always converted to the type of the option.
			For an option local to a window or buffer the effect
			is just like using the |<a href="options.html#:set">:set</a>| command: both the local
			value and the global value are changed.
			Example:
<code class="example">				:let &amp;path = &amp;path . ',/usr/local/include'</code>
<code class="example"></code>
:let &amp;<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
			For a string option: Append <code class="special">{expr1}</code> to the value.
			Does not insert a comma like |<a href="options.html#:set+%20">:set+=</a>|.

:let &amp;<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
			For a number or boolean option: Add or subtract
			<code class="special">{expr1}</code>.

:let &amp;l:<code class="special">{option-name}</code> = <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;l:<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
			Like above, but only set the local value of an option
			(if there is one).  Works like |<a href="options.html#:setlocal">:setlocal</a>|.

:let &amp;g:<code class="special">{option-name}</code> = <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> .= <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> += <code class="special">{expr1}</code>
:let &amp;g:<code class="special">{option-name}</code> -= <code class="special">{expr1}</code>
			Like above, but only set the global value of an option
			(if there is one).  Works like |<a href="options.html#:setglobal">:setglobal</a>|.

:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] = <code class="special">{expr1}</code>		<b class="vimtag">*<a name=":let-unpack">:let-unpack</a>*</b> <b class="vimtag">*<a name="E687">E687</a>*</b> <b class="vimtag">*<a name="E688">E688</a>*</b>
			<code class="special">{expr1}</code> must evaluate to a |<a href="eval.html#List">List</a>|.  The first item in
			the list is assigned to <code class="special">{name1}</code>, the second item to
			<code class="special">{name2}</code>, etc.
			The number of names must match the number of items in
			the |<a href="eval.html#List">List</a>|.
			Each name can be one of the items of the ":let"
			command as mentioned above.
			Example:
<code class="example">				:let [s, item] = GetItem(s)</code>
			Detail: <code class="special">{expr1}</code> is evaluated first, then the
			assignments are done in sequence.  This matters if
			<code class="special">{name2}</code> depends on <code class="special">{name1}</code>.  Example:
<code class="example">				:let x = [0, 1]</code>
<code class="example">				:let i = 0</code>
<code class="example">				:let [i, x[i]] = [1, 2]</code>
<code class="example">				:echo x</code>
			The result is [0, 2].

:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] .= <code class="special">{expr1}</code>
:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] += <code class="special">{expr1}</code>
:let [<code class="special">{name1}</code>, <code class="special">{name2}</code>, ...] -= <code class="special">{expr1}</code>
			Like above, but append/add/subtract the value for each
			|<a href="eval.html#List">List</a>| item.

:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] = <code class="special">{expr1}</code>
			Like |<a href="eval.html#:let-unpack">:let-unpack</a>| above, but the |<a href="eval.html#List">List</a>| may have more
			items than there are names.  A list of the remaining
			items is assigned to <code class="special">{lastname}</code>.  If there are no
			remaining items <code class="special">{lastname}</code> is set to an empty list.
			Example:
<code class="example">				:let [a, b; rest] = ["aval", "bval", 3, 4]</code>

:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] .= <code class="special">{expr1}</code>
:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] += <code class="special">{expr1}</code>
:let [<code class="special">{name}</code>, ..., ; <code class="special">{lastname}</code>] -= <code class="special">{expr1}</code>
			Like above, but append/add/subtract the value for each
			|<a href="eval.html#List">List</a>| item.

								<b class="vimtag">*<a name="E121">E121</a>*</b>
:let <code class="special">{var-name}</code>	..	List the value of variable <code class="special">{var-name}</code>.	Multiple
			variable names may be given.  Special names recognized
			here:				<b class="vimtag">*<a name="E738">E738</a>*</b>
			  g:	global variables
			  b:	local buffer variables
			  w:	local window variables
			  t:	local tab page variables
			  s:	script-local variables
			  l:	local function variables
			  v:	Vim variables.

:let			List the values of all variables.  The type of the
			variable is indicated before the value:
			    <code class="special">&lt;nothing&gt;</code>	String
				#	Number
				*	Funcref


:unl[et][!] <code class="special">{name}</code> ...				<b class="vimtag">*<a name=":unlet">:unlet</a>*</b> <b class="vimtag">*<a name=":unl">:unl</a>*</b> <b class="vimtag">*<a name="E108">E108</a>*</b> <b class="vimtag">*<a name="E795">E795</a>*</b>
			Remove the internal variable <code class="special">{name}</code>.  Several variable
			names can be given, they are all removed.  The name
			may also be a |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| item.
			With [!] no error message is given for non-existing
			variables.
			One or more items from a |<a href="eval.html#List">List</a>| can be removed:
<code class="example">				:unlet list[3]	  " remove fourth item</code>
<code class="example">				:unlet list[3:]   " remove fourth item to last</code>
&lt;			One item from a |<a href="eval.html#Dictionary">Dictionary</a>| can be removed at a time:
<code class="example">				:unlet dict['two']</code>
<code class="example">				:unlet dict.two</code>
			This is especially useful to clean up used global
			variables and script-local variables (these are not
			deleted when the script ends).  Function-local
			variables are automatically deleted when the function
			ends.

:lockv[ar][!] [depth] <code class="special">{name}</code> ...			<b class="vimtag">*<a name=":lockvar">:lockvar</a>*</b> <b class="vimtag">*<a name=":lockv">:lockv</a>*</b>
			Lock the internal variable <code class="special">{name}</code>.  Locking means that
			it can no longer be changed (until it is unlocked).
			A locked variable can be deleted:
<code class="example">				:lockvar v</code>
<code class="example">				:let v = 'asdf'		" fails!</code>
<code class="example">				:unlet v</code>
							<b class="vimtag">*<a name="E741">E741</a>*</b>
			If you try to change a locked variable you get an
			error message: "E741: Value is locked: <code class="special">{name}</code>"

			[depth] is relevant when locking a |<a href="eval.html#List">List</a>| or
			|<a href="eval.html#Dictionary">Dictionary</a>|.  It specifies how deep the locking goes:
				1	Lock the |<a href="eval.html#List">List</a>| or |<a href="eval.html#Dictionary">Dictionary</a>| itself,
					cannot add or remove items, but can
					still change their values.
				2	Also lock the values, cannot change
					the items.  If an item is a |<a href="eval.html#List">List</a>| or
					|<a href="eval.html#Dictionary">Dictionary</a>|, cannot add or remove
					items, but can still change the
					values.
				3	Like 2 but for the |<a href="eval.html#List">List</a>| /
					|<a href="eval.html#Dictionary">Dictionary</a>| in the |<a href="eval.html#List">List</a>| /
					|<a href="eval.html#Dictionary">Dictionary</a>|, one level deeper.
			The default [depth] is 2, thus when <code class="special">{name}</code> is a |<a href="eval.html#List">List</a>|
			or |<a href="eval.html#Dictionary">Dictionary</a>| the values cannot be changed.
								<b class="vimtag">*<a name="E743">E743</a>*</b>
			For unlimited depth use [!] and omit [depth].
			However, there is a maximum depth of 100 to catch
			loops.

			<code class="note">Note</code> that when two variables refer to the same |<a href="eval.html#List">List</a>|
			and you lock one of them, the |<a href="eval.html#List">List</a>| will also be
			locked when used through the other variable.
			Example:
<code class="example">				:let l = [0, 1, 2, 3]</code>
<code class="example">				:let cl = l</code>
<code class="example">				:lockvar l</code>
<code class="example">				:let cl[1] = 99		" won't work!</code>
			You may want to make a copy of a list to avoid this.
			See |<a href="eval.html#deepcopy()">deepcopy()</a>|.


:unlo[ckvar][!] [depth] <code class="special">{name}</code> ...			<b class="vimtag">*<a name=":unlockvar">:unlockvar</a>*</b> <b class="vimtag">*<a name=":unlo">:unlo</a>*</b>
			Unlock the internal variable <code class="special">{name}</code>.  Does the
			opposite of |<a href="eval.html#:lockvar">:lockvar</a>|.


:if <code class="special">{expr1}</code>			<b class="vimtag">*<a name=":if">:if</a>*</b> <b class="vimtag">*<a name=":endif">:endif</a>*</b> <b class="vimtag">*<a name=":en">:en</a>*</b> <b class="vimtag">*<a name="E171">E171</a>*</b> <b class="vimtag">*<a name="E579">E579</a>*</b> <b class="vimtag">*<a name="E580">E580</a>*</b>
:en[dif]		Execute the commands until the next matching ":else"
			or ":endif" if <code class="special">{expr1}</code> evaluates to non-zero.

			From Vim version 4.5 until 5.0, every Ex command in
			between the ":if" and ":endif" is ignored.  These two
			commands were just to allow for future expansions in a
			backward compatible way.  Nesting was allowed.  <code class="note">Note</code>
			that any ":else" or ":elseif" was ignored, the "else"
			part was not executed either.

			You can use this to remain compatible with older
			versions:
<code class="example">				:if version &gt;= 500</code>
<code class="example">				:  version-5-specific-commands</code>
<code class="example">				:endif</code>
			The commands still need to be parsed to find the
			"endif".  Sometimes an older Vim has a problem with a
			new command.  For example, ":silent" is recognized as
			a ":substitute" command.  In that case ":execute" can
			avoid problems:
<code class="example">				:if version &gt;= 600</code>
<code class="example">				:  execute "silent 1,$delete"</code>
<code class="example">				:endif</code>

			<code class="note">NOTE:</code> The ":append" and ":insert" commands don't work
			properly in between ":if" and ":endif".

						<b class="vimtag">*<a name=":else">:else</a>*</b> <b class="vimtag">*<a name=":el">:el</a>*</b> <b class="vimtag">*<a name="E581">E581</a>*</b> <b class="vimtag">*<a name="E583">E583</a>*</b>
:el[se]			Execute the commands until the next matching ":else"
			or ":endif" if they previously were not being
			executed.

					<b class="vimtag">*<a name=":elseif">:elseif</a>*</b> <b class="vimtag">*<a name=":elsei">:elsei</a>*</b> <b class="vimtag">*<a name="E582">E582</a>*</b> <b class="vimtag">*<a name="E584">E584</a>*</b>
:elsei[f] <code class="special">{expr1}</code>	Short for ":else" ":if", with the addition that there
			is no extra ":endif".

:wh[ile] <code class="special">{expr1}</code>			<b class="vimtag">*<a name=":while">:while</a>*</b> <b class="vimtag">*<a name=":endwhile">:endwhile</a>*</b> <b class="vimtag">*<a name=":wh">:wh</a>*</b> <b class="vimtag">*<a name=":endw">:endw</a>*</b>
						<b class="vimtag">*<a name="E170">E170</a>*</b> <b class="vimtag">*<a name="E585">E585</a>*</b> <b class="vimtag">*<a name="E588">E588</a>*</b> <b class="vimtag">*<a name="E733">E733</a>*</b>
:endw[hile]		Repeat the commands between ":while" and ":endwhile",
			as long as <code class="special">{expr1}</code> evaluates to non-zero.
			When an error is detected from a command inside the
			loop, execution continues after the "endwhile".
			Example:
<code class="example">				:let lnum = 1</code>
<code class="example">				:while lnum &lt;= line("$")</code>
<code class="example">				   :call FixLine(lnum)</code>
<code class="example">				   :let lnum = lnum + 1</code>
<code class="example">				:endwhile</code>

			<code class="note">NOTE:</code> The ":append" and ":insert" commands don't work
			properly inside a ":while" and ":for" loop.

:for <code class="special">{var}</code> in <code class="special">{list}</code>					<b class="vimtag">*<a name=":for">:for</a>*</b> <b class="vimtag">*<a name="E690">E690</a>*</b> <b class="vimtag">*<a name="E732">E732</a>*</b>
:endfo[r]						<b class="vimtag">*<a name=":endfo">:endfo</a>*</b> <b class="vimtag">*<a name=":endfor">:endfor</a>*</b>
			Repeat the commands between ":for" and ":endfor" for
			each item in <code class="special">{list}</code>.  Variable <code class="special">{var}</code> is set to the
			value of each item.
			When an error is detected for a command inside the
			loop, execution continues after the "endfor".
			Changing <code class="special">{list}</code> inside the loop affects what items are
			used.  Make a copy if this is unwanted:
<code class="example">				:for item in copy(mylist)</code>
			When not making a copy, Vim stores a reference to the
			next item in the list, before executing the commands
			with the current item.	Thus the current item can be
			removed without effect.  Removing any later item means
			it will not be found.  Thus the following example
			works (an inefficient way to make a list empty):
<code class="example">				for item in mylist</code>
<code class="example">				   call remove(mylist, 0)</code>
<code class="example">				endfor</code>
			<code class="note">Note</code> that reordering the list (e.g., with sort() or
			reverse()) may have unexpected effects.

:for [<code class="special">{var1}</code>, <code class="special">{var2}</code>, ...] in <code class="special">{listlist}</code>
:endfo[r]
			Like ":for" above, but each item in <code class="special">{listlist}</code> must be
			a list, of which each item is assigned to <code class="special">{var1}</code>,
			<code class="special">{var2}</code>, etc.  Example:
<code class="example">				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]</code>
<code class="example">				   :echo getline(lnum)[col]</code>
<code class="example">				:endfor</code>

						<b class="vimtag">*<a name=":continue">:continue</a>*</b> <b class="vimtag">*<a name=":con">:con</a>*</b> <b class="vimtag">*<a name="E586">E586</a>*</b>
:con[tinue]		When used inside a ":while" or ":for" loop, jumps back
			to the start of the loop.
			If it is used after a |<a href="eval.html#:try">:try</a>| inside the loop but
			before the matching |<a href="eval.html#:finally">:finally</a>| (if present), the
			commands following the ":finally" up to the matching
			|<a href="eval.html#:endtry">:endtry</a>| are executed first.  This process applies to
			all nested ":try"s inside the loop.  The outermost
			":endtry" then jumps back to the start of the loop.

						<b class="vimtag">*<a name=":break">:break</a>*</b> <b class="vimtag">*<a name=":brea">:brea</a>*</b> <b class="vimtag">*<a name="E587">E587</a>*</b>
:brea[k]		When used inside a ":while" or ":for" loop, skips to
			the command after the matching ":endwhile" or
			":endfor".
			If it is used after a |<a href="eval.html#:try">:try</a>| inside the loop but
			before the matching |<a href="eval.html#:finally">:finally</a>| (if present), the
			commands following the ":finally" up to the matching
			|<a href="eval.html#:endtry">:endtry</a>| are executed first.  This process applies to
			all nested ":try"s inside the loop.  The outermost
			":endtry" then jumps to the command after the loop.

:try				<b class="vimtag">*<a name=":try">:try</a>*</b> <b class="vimtag">*<a name=":endt">:endt</a>*</b> <b class="vimtag">*<a name=":endtry">:endtry</a>*</b> <b class="vimtag">*<a name="E600">E600</a>*</b> <b class="vimtag">*<a name="E601">E601</a>*</b> <b class="vimtag">*<a name="E602">E602</a>*</b>
:endt[ry]		Change the error handling for the commands between
			":try" and ":endtry" including everything being
			executed across ":source" commands, function calls,
			or autocommand invocations.

			When an error or interrupt is detected and there is
			a |<a href="eval.html#:finally">:finally</a>| command following, execution continues
			after the ":finally".  Otherwise, or when the
			":endtry" is reached thereafter, the next
			(dynamically) surrounding ":try" is checked for
			a corresponding ":finally" etc.  Then the script
			processing is terminated.  (Whether a function
			definition has an "abort" argument does not matter.)
			Example:
<code class="example">		:try |<code class="badlink"> edit too much </code>| finally |<code class="badlink"> echo "cleanup" </code>| endtry</code>
<code class="example">		:echo "impossible"	" not reached, script terminated above</code>

			Moreover, an error or interrupt (dynamically) inside
			":try" and ":endtry" is converted to an exception.  It
			can be caught as if it were thrown by a |<a href="eval.html#:throw">:throw</a>|
			command (see |<a href="eval.html#:catch">:catch</a>|).  In this case, the script
			processing is not terminated.

			The value "Vim:Interrupt" is used for an interrupt
			exception.  An error in a Vim command is converted
			to a value of the form "Vim(<code class="special">{command}</code>):<code class="special">{errmsg}</code>",
			other errors are converted to a value of the form
			"Vim:<code class="special">{errmsg}</code>".  <code class="special">{command}</code> is the full command name,
			and <code class="special">{errmsg}</code> is the message that is displayed if the
			error exception is not caught, always beginning with
			the error number.
			Examples:
<code class="example">		:try |<code class="badlink"> sleep 100 </code>| catch /^Vim:Interrupt$/ | endtry</code>
<code class="example">		:try |<code class="badlink"> edit </code>| catch /^Vim(edit):E\d\+/ |<code class="badlink"> echo "error" </code>| endtry</code>

					<b class="vimtag">*<a name=":cat">:cat</a>*</b> <b class="vimtag">*<a name=":catch">:catch</a>*</b> <b class="vimtag">*<a name="E603">E603</a>*</b> <b class="vimtag">*<a name="E604">E604</a>*</b> <b class="vimtag">*<a name="E605">E605</a>*</b>
:cat[ch] /<code class="special">{pattern}</code>/	The following commands until the next |<a href="eval.html#:catch">:catch</a>|,
			|<a href="eval.html#:finally">:finally</a>|, or |<a href="eval.html#:endtry">:endtry</a>| that belongs to the same
			|<a href="eval.html#:try">:try</a>| as the ":catch" are executed when an exception
			matching <code class="special">{pattern}</code> is being thrown and has not yet
			been caught by a previous ":catch".  Otherwise, these
			commands are skipped.
			When <code class="special">{pattern}</code> is omitted all errors are caught.
			Examples:
<code class="example">		:catch /^Vim:Interrupt$/	" catch interrupts (<code class="keystroke">CTRL-C</code>)</code>
<code class="example">		:catch /^Vim\%((\a\+)\)\=:E/	" catch all Vim errors</code>
<code class="example">		:catch /^Vim\%((\a\+)\)\=:/	" catch errors and interrupts</code>
<code class="example">		:catch /^Vim(write):/		" catch all errors in :write</code>
<code class="example">		:catch /^Vim\%((\a\+)\)\=:E123/	" catch error E123</code>
<code class="example">		:catch /my-exception/		" catch user exception</code>
<code class="example">		:catch /.*/			" catch everything</code>
<code class="example">		:catch				" same as /.*/</code>

			Another character can be used instead of / around the
			<code class="special">{pattern}</code>, so long as it does not have a special
			meaning (e.g., '|' or '"') and doesn't occur inside
			<code class="special">{pattern}</code>.
			Information about the exception is available in
			|<a href="eval.html#v:exception">v:exception</a>|.  Also see |<a href="eval.html#throw-variables">throw-variables</a>|.
			<code class="note">NOTE:</code> It is not reliable to ":catch" the TEXT of
			an error message because it may vary in different
			locales.

					<b class="vimtag">*<a name=":fina">:fina</a>*</b> <b class="vimtag">*<a name=":finally">:finally</a>*</b> <b class="vimtag">*<a name="E606">E606</a>*</b> <b class="vimtag">*<a name="E607">E607</a>*</b>
:fina[lly]		The following commands until the matching |<a href="eval.html#:endtry">:endtry</a>|
			are executed whenever the part between the matching
			|<a href="eval.html#:try">:try</a>| and the ":finally" is left:  either by falling
			through to the ":finally" or by a |<a href="eval.html#:continue">:continue</a>|,
			|<a href="eval.html#:break">:break</a>|, |<a href="repeat.html#:finish">:finish</a>|, or |<a href="eval.html#:return">:return</a>|, or by an error or
			interrupt or exception (see |<a href="eval.html#:throw">:throw</a>|).

							<b class="vimtag">*<a name=":th">:th</a>*</b> <b class="vimtag">*<a name=":throw">:throw</a>*</b> <b class="vimtag">*<a name="E608">E608</a>*</b>
:th[row] <code class="special">{expr1}</code>	The <code class="special">{expr1}</code> is evaluated and thrown as an exception.
			If the ":throw" is used after a |<a href="eval.html#:try">:try</a>| but before the
			first corresponding |<a href="eval.html#:catch">:catch</a>|, commands are skipped
			until the first ":catch" matching <code class="special">{expr1}</code> is reached.
			If there is no such ":catch" or if the ":throw" is
			used after a ":catch" but before the |<a href="eval.html#:finally">:finally</a>|, the
			commands following the ":finally" (if present) up to
			the matching |<a href="eval.html#:endtry">:endtry</a>| are executed.  If the ":throw"
			is after the ":finally", commands up to the ":endtry"
			are skipped.  At the ":endtry", this process applies
			again for the next dynamically surrounding ":try"
			(which may be found in a calling function or sourcing
			script), until a matching ":catch" has been found.
			If the exception is not caught, the command processing
			is terminated.
			Example:
<code class="example">		:try |<code class="badlink"> throw "oops" </code>| catch /^oo/ |<code class="badlink"> echo "caught" </code>| endtry</code>
			<code class="note">Note</code> that "catch" may need to be on a separate line
			for when an error causes the parsing to skip the whole
			line and not see the "|" that separates the commands.

							<b class="vimtag">*<a name=":ec">:ec</a>*</b> <b class="vimtag">*<a name=":echo">:echo</a>*</b>
:ec[ho] <code class="special">{expr1}</code> ..	Echoes each <code class="special">{expr1}</code>, with a space in between.  The
			first <code class="special">{expr1}</code> starts on a new line.
			Also see |<a href="cmdline.html#:comment">:comment</a>|.
			Use "\n" to start a new line.  Use "\r" to move the
			cursor to the first column.
			Uses the highlighting set by the |<a href="eval.html#:echohl">:echohl</a>| command.
			Cannot be followed by a comment.
			Example:
<code class="example">		:echo "the value of 'shell' is" &amp;shell</code>
							<b class="vimtag">*<a name=":echo-redraw">:echo-redraw</a>*</b>
			A later redraw may make the message disappear again.
			And since Vim mostly postpones redrawing until it's
			finished with a sequence of commands this happens
			quite often.  To avoid that a command from before the
			":echo" causes a redraw afterwards (redraws are often
			postponed until you type something), force a redraw
			with the |<a href="various.html#:redraw">:redraw</a>| command.  Example:
<code class="example">		:new |<code class="badlink"> redraw </code>| echo "there is a new window"</code>

							<b class="vimtag">*<a name=":echon">:echon</a>*</b>
:echon <code class="special">{expr1}</code> ..	Echoes each <code class="special">{expr1}</code>, without anything added.  Also see
			|<a href="cmdline.html#:comment">:comment</a>|.
			Uses the highlighting set by the |<a href="eval.html#:echohl">:echohl</a>| command.
			Cannot be followed by a comment.
			Example:
<code class="example">				:echon "the value of 'shell' is " &amp;shell</code>

			<code class="note">Note</code> the difference between using ":echo", which is a
			Vim command, and ":!echo", which is an external shell
			command:
<code class="example">		:!echo %		--&gt; filename</code>
&lt;			The arguments of ":!" are expanded, see |<a href="cmdline.html#:_%">:_%</a>|.
<code class="example">		:!echo "%"		--&gt; filename or "filename"</code>
			Like the previous example.  Whether you see the double
			quotes or not depends on your 'shell'.
<code class="example">		:echo %			--&gt; nothing</code>
&lt;			The '%' is an illegal character in an expression.
<code class="example">		:echo "%"		--&gt; %</code>
&lt;			This just echoes the '%' character.
<code class="example">		:echo expand("%")	--&gt; filename</code>
			This calls the expand() function to expand the '%'.

							<b class="vimtag">*<a name=":echoh">:echoh</a>*</b> <b class="vimtag">*<a name=":echohl">:echohl</a>*</b>
:echoh[l] <code class="special">{name}</code>	Use the highlight group <code class="special">{name}</code> for the following
			|<a href="eval.html#:echo">:echo</a>|, |<a href="eval.html#:echon">:echon</a>| and |<a href="eval.html#:echomsg">:echomsg</a>| commands.  Also used
			for the |<a href="eval.html#input()">input()</a>| prompt.  Example:
<code class="example">		:echohl WarningMsg |<code class="badlink"> echo "Don't panic!" </code>| echohl None</code>
			Don't forget to set the group back to "None",
			otherwise all following echo's will be highlighted.

							<b class="vimtag">*<a name=":echom">:echom</a>*</b> <b class="vimtag">*<a name=":echomsg">:echomsg</a>*</b>
:echom[sg] <code class="special">{expr1}</code> ..	Echo the expression(s) as a true message, saving the
			message in the |<a href="message.html#message-history">message-history</a>|.
			Spaces are placed between the arguments as with the
			|<a href="eval.html#:echo">:echo</a>| command.  But unprintable characters are
			displayed, not interpreted.
			The parsing works slightly different from |<a href="eval.html#:echo">:echo</a>|,
			more like |<a href="eval.html#:execute">:execute</a>|.  All the expressions are first
			evaluated and concatenated before echoing anything.
			The expressions must evaluate to a Number or String, a
			Dictionary or List causes an error.
			Uses the highlighting set by the |<a href="eval.html#:echohl">:echohl</a>| command.
			Example:
<code class="example">		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."</code>
			See |<a href="eval.html#:echo-redraw">:echo-redraw</a>| to avoid the message disappearing
			when the screen is redrawn.
							<b class="vimtag">*<a name=":echoe">:echoe</a>*</b> <b class="vimtag">*<a name=":echoerr">:echoerr</a>*</b>
:echoe[rr] <code class="special">{expr1}</code> ..	Echo the expression(s) as an error message, saving the
			message in the |<a href="message.html#message-history">message-history</a>|.  When used in a
			script or function the line number will be added.
			Spaces are placed between the arguments as with the
			:echo command.	When used inside a try conditional,
			the message is raised as an error exception instead
			(see |<a href="eval.html#try-echoerr">try-echoerr</a>|).
			Example:
<code class="example">		:echoerr "This script just failed!"</code>
			If you just want a highlighted message use |<a href="eval.html#:echohl">:echohl</a>|.
			And to get a beep:
<code class="example">		:exe "normal \<code class="special">&lt;Esc&gt;</code>"</code>

							<b class="vimtag">*<a name=":exe">:exe</a>*</b> <b class="vimtag">*<a name=":execute">:execute</a>*</b>
:exe[cute] <code class="special">{expr1}</code> ..	Executes the string that results from the evaluation
			of <code class="special">{expr1}</code> as an Ex command.
			Multiple arguments are concatenated, with a space in
			between.  To avoid the extra space use the "."
			operator to concatenate strings into one argument.
			<code class="special">{expr1}</code> is used as the processed command, command line
			editing keys are not recognized.
			Cannot be followed by a comment.
			Examples:
<code class="example">		:execute "buffer" nextbuf</code>
<code class="example">		:execute "normal" count . "w"</code>

			":execute" can be used to append a command to commands
			that don't accept a '|'.  Example:
<code class="example">		:execute '!ls' | echo "theend"</code>
<code class="example"></code>
			":execute" is also a nice way to avoid having to type
			control characters in a Vim script for a ":normal"
			command:
<code class="example">		:execute "normal ixxx\<code class="special">&lt;Esc&gt;</code>"</code>
			This has an <code class="special">&lt;Esc&gt;</code> character, see |<a href="eval.html#expr-string">expr-string</a>|.

			Be careful to correctly escape special characters in
			file names.  The |<a href="eval.html#fnameescape()">fnameescape()</a>| function can be used
			for Vim commands, |<a href="eval.html#shellescape()">shellescape()</a>| for |<a href="various.html#:!">:!</a>| commands.
			Examples:
<code class="example">		:execute "e " . fnameescape(filename)</code>
<code class="example">		:execute "!ls " . shellescape(filename, 1)</code>

			<code class="note">Note:</code> The executed string may be any command-line, but
			starting or ending "if", "while" and "for" does not
			always work, because when commands are skipped the
			":execute" is not evaluated and Vim loses track of
			where blocks start and end.  Also "break" and
			"continue" should not be inside ":execute".
			This example does not work, because the ":execute" is
			not evaluated and Vim does not see the "while", and
			gives an error for finding an ":endwhile":
<code class="example">		:if 0</code>
<code class="example">		: execute 'while i &gt; 5'</code>
<code class="example">		:  echo "test"</code>
<code class="example">		: endwhile</code>
<code class="example">		:endif</code>

			It is allowed to have a "while" or "if" command
			completely in the executed string:
<code class="example">		:execute 'while i &lt; 5 |<code class="badlink"> echo i </code>| let i = i + 1 | endwhile'</code>


							<b class="vimtag">*<a name=":exe-comment">:exe-comment</a>*</b>
			":execute", ":echo" and ":echon" cannot be followed by
			a comment directly, because they see the '"' as the
			start of a string.  But, you can use '|' followed by a
			comment.  Example:
<code class="example">		:echo "foo" | "this is a comment</code>
<code class="example"></code>
</pre><hr><pre>8. Exception handling					<b class="vimtag">*<a name="exception-handling">exception-handling</a>*</b>

The Vim script language comprises an exception handling feature.  This section
explains how it can be used in a Vim script.

Exceptions may be raised by Vim on an error or on interrupt, see
|<a href="eval.html#catch-errors">catch-errors</a>| and |<a href="eval.html#catch-interrupt">catch-interrupt</a>|.  You can also explicitly throw an
exception by using the ":throw" command, see |<a href="eval.html#throw-catch">throw-catch</a>|.


TRY CONDITIONALS					<b class="vimtag">*<a name="try-conditionals">try-conditionals</a>*</b>

Exceptions can be caught or can cause cleanup code to be executed.  You can
use a try conditional to specify catch clauses (that catch exceptions) and/or
a finally clause (to be executed for cleanup).
   A try conditional begins with a |<a href="eval.html#:try">:try</a>| command and ends at the matching
|<a href="eval.html#:endtry">:endtry</a>| command.  In between, you can use a |<a href="eval.html#:catch">:catch</a>| command to start
a catch clause, or a |<a href="eval.html#:finally">:finally</a>| command to start a finally clause.  There may
be none or multiple catch clauses, but there is at most one finally clause,
which must not be followed by any catch clauses.  The lines before the catch
clauses and the finally clause is called a try block.
<code class="example"></code>
<code class="example">     :try</code>
<code class="example">     :	...</code>
<code class="example">     :	...				TRY BLOCK</code>
<code class="example">     :	...</code>
<code class="example">     :catch /<code class="special">{pattern}</code>/</code>
<code class="example">     :	...</code>
<code class="example">     :	...				CATCH CLAUSE</code>
<code class="example">     :	...</code>
<code class="example">     :catch /<code class="special">{pattern}</code>/</code>
<code class="example">     :	...</code>
<code class="example">     :	...				CATCH CLAUSE</code>
<code class="example">     :	...</code>
<code class="example">     :finally</code>
<code class="example">     :	...</code>
<code class="example">     :	...				FINALLY CLAUSE</code>
<code class="example">     :	...</code>
<code class="example">     :endtry</code>
<code class="example"></code>
The try conditional allows to watch code for exceptions and to take the
appropriate actions.  Exceptions from the try block may be caught.  Exceptions
from the try block and also the catch clauses may cause cleanup actions.
   When no exception is thrown during execution of the try block, the control
is transferred to the finally clause, if present.  After its execution, the
script continues with the line following the ":endtry".
   When an exception occurs during execution of the try block, the remaining
lines in the try block are skipped.  The exception is matched against the
patterns specified as arguments to the ":catch" commands.  The catch clause
after the first matching ":catch" is taken, other catch clauses are not
executed.  The catch clause ends when the next ":catch", ":finally", or
":endtry" command is reached - whatever is first.  Then, the finally clause
(if present) is executed.  When the ":endtry" is reached, the script execution
continues in the following line as usual.
   When an exception that does not match any of the patterns specified by the
":catch" commands is thrown in the try block, the exception is not caught by
that try conditional and none of the catch clauses is executed.  Only the
finally clause, if present, is taken.  The exception pends during execution of
the finally clause.  It is resumed at the ":endtry", so that commands after
the ":endtry" are not executed and the exception might be caught elsewhere,
see |<a href="eval.html#try-nesting">try-nesting</a>|.
   When during execution of a catch clause another exception is thrown, the
remaining lines in that catch clause are not executed.	The new exception is
not matched against the patterns in any of the ":catch" commands of the same
try conditional and none of its catch clauses is taken.  If there is, however,
a finally clause, it is executed, and the exception pends during its
execution.  The commands following the ":endtry" are not executed.  The new
exception might, however, be caught elsewhere, see |<a href="eval.html#try-nesting">try-nesting</a>|.
   When during execution of the finally clause (if present) an exception is
thrown, the remaining lines in the finally clause are skipped.	If the finally
clause has been taken because of an exception from the try block or one of the
catch clauses, the original (pending) exception is discarded.  The commands
following the ":endtry" are not executed, and the exception from the finally
clause is propagated and can be caught elsewhere, see |<a href="eval.html#try-nesting">try-nesting</a>|.

The finally clause is also executed, when a ":break" or ":continue" for
a ":while" loop enclosing the complete try conditional is executed from the
try block or a catch clause.  Or when a ":return" or ":finish" is executed
from the try block or a catch clause of a try conditional in a function or
sourced script, respectively.  The ":break", ":continue", ":return", or
":finish" pends during execution of the finally clause and is resumed when the
":endtry" is reached.  It is, however, discarded when an exception is thrown
from the finally clause.
   When a ":break" or ":continue" for a ":while" loop enclosing the complete
try conditional or when a ":return" or ":finish" is encountered in the finally
clause, the rest of the finally clause is skipped, and the ":break",
":continue", ":return" or ":finish" is executed as usual.  If the finally
clause has been taken because of an exception or an earlier ":break",
":continue", ":return", or ":finish" from the try block or a catch clause,
this pending exception or command is discarded.

For examples see |<a href="eval.html#throw-catch">throw-catch</a>| and |<a href="eval.html#try-finally">try-finally</a>|.


NESTING	OF TRY CONDITIONALS				<b class="vimtag">*<a name="try-nesting">try-nesting</a>*</b>

Try conditionals can be nested arbitrarily.  That is, a complete try
conditional can be put into the try block, a catch clause, or the finally
clause of another try conditional.  If the inner try conditional does not
catch an exception thrown in its try block or throws a new exception from one
of its catch clauses or its finally clause, the outer try conditional is
checked according to the rules above.  If the inner try conditional is in the
try block of the outer try conditional, its catch clauses are checked, but
otherwise only the finally clause is executed.	It does not matter for
nesting, whether the inner try conditional is directly contained in the outer
one, or whether the outer one sources a script or calls a function containing
the inner try conditional.

When none of the active try conditionals catches an exception, just their
finally clauses are executed.  Thereafter, the script processing terminates.
An error message is displayed in case of an uncaught exception explicitly
thrown by a ":throw" command.  For uncaught error and interrupt exceptions
implicitly raised by Vim, the error message(s) or interrupt message are shown
as usual.

For examples see |<a href="eval.html#throw-catch">throw-catch</a>|.


EXAMINING EXCEPTION HANDLING CODE			<b class="vimtag">*<a name="except-examine">except-examine</a>*</b>

Exception handling code can get tricky.  If you are in doubt what happens, set
'verbose' to 13 or use the ":13verbose" command modifier when sourcing your
script file.  Then you see when an exception is thrown, discarded, caught, or
finished.  When using a verbosity level of at least 14, things pending in
a finally clause are also shown.  This information is also given in debug mode
(see |<a href="repeat.html#debug-scripts">debug-scripts</a>|).


THROWING AND CATCHING EXCEPTIONS			<b class="vimtag">*<a name="throw-catch">throw-catch</a>*</b>

You can throw any number or string as an exception.  Use the |<a href="eval.html#:throw">:throw</a>| command
and pass the value to be thrown as argument:
<code class="example">	:throw 4711</code>
<code class="example">	:throw "string"</code>
							<b class="vimtag">*<a name="throw-expression">throw-expression</a>*</b>
You can also specify an expression argument.  The expression is then evaluated
first, and the result is thrown:
<code class="example">	:throw 4705 + strlen("string")</code>
<code class="example">	:throw strpart("strings", 0, 6)</code>
<code class="example"></code>
An exception might be thrown during evaluation of the argument of the ":throw"
command.  Unless it is caught there, the expression evaluation is abandoned.
The ":throw" command then does not throw a new exception.
   Example:
<code class="example"></code>
<code class="example">	:function! Foo(arg)</code>
<code class="example">	:  try</code>
<code class="example">	:    throw a:arg</code>
<code class="example">	:  catch /foo/</code>
<code class="example">	:  endtry</code>
<code class="example">	:  return 1</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:function! Bar()</code>
<code class="example">	:  echo "in Bar"</code>
<code class="example">	:  return 4710</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:throw Foo("arrgh") + Bar()</code>
<code class="example"></code>
This throws "arrgh", and "in Bar" is not displayed since Bar() is not
executed.
<code class="example">	:throw Foo("foo") + Bar()</code>
however displays "in Bar" and throws 4711.

Any other command that takes an expression as argument might also be
abandoned by an (uncaught) exception during the expression evaluation.	The
exception is then propagated to the caller of the command.
   Example:
<code class="example"></code>
<code class="example">	:if Foo("arrgh")</code>
<code class="example">	:  echo "then"</code>
<code class="example">	:else</code>
<code class="example">	:  echo "else"</code>
<code class="example">	:endif</code>
<code class="example"></code>
Here neither of "then" or "else" is displayed.

							<b class="vimtag">*<a name="catch-order">catch-order</a>*</b>
Exceptions can be caught by a try conditional with one or more |<a href="eval.html#:catch">:catch</a>|
commands, see |<a href="eval.html#try-conditionals">try-conditionals</a>|.   The values to be caught by each ":catch"
command can be specified as a pattern argument.  The subsequent catch clause
gets executed when a matching exception is caught.
   Example:
<code class="example"></code>
<code class="example">	:function! Foo(value)</code>
<code class="example">	:  try</code>
<code class="example">	:    throw a:value</code>
<code class="example">	:  catch /^\d\+$/</code>
<code class="example">	:    echo "Number thrown"</code>
<code class="example">	:  catch /.*/</code>
<code class="example">	:    echo "String thrown"</code>
<code class="example">	:  endtry</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:call Foo(0x1267)</code>
<code class="example">	:call Foo('string')</code>
<code class="example"></code>
The first call to Foo() displays "Number thrown", the second "String thrown".
An exception is matched against the ":catch" commands in the order they are
specified.  Only the first match counts.  So you should place the more
specific ":catch" first.  The following order does not make sense:
<code class="example"></code>
<code class="example">	:  catch /.*/</code>
<code class="example">	:    echo "String thrown"</code>
<code class="example">	:  catch /^\d\+$/</code>
<code class="example">	:    echo "Number thrown"</code>
<code class="example"></code>
The first ":catch" here matches always, so that the second catch clause is
never taken.

							<b class="vimtag">*<a name="throw-variables">throw-variables</a>*</b>
If you catch an exception by a general pattern, you may access the exact value
in the variable |<a href="eval.html#v:exception">v:exception</a>|:
<code class="example"></code>
<code class="example">	:  catch /^\d\+$/</code>
<code class="example">	:    echo "Number thrown.  Value is" v:exception</code>
<code class="example"></code>
You may also be interested where an exception was thrown.  This is stored in
|<a href="eval.html#v:throwpoint">v:throwpoint</a>|.  <code class="note">Note</code> that "v:exception" and "v:throwpoint" are valid for the
exception most recently caught as long it is not finished.
   Example:
<code class="example"></code>
<code class="example">	:function! Caught()</code>
<code class="example">	:  if v:exception != ""</code>
<code class="example">	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint</code>
<code class="example">	:  else</code>
<code class="example">	:    echo 'Nothing caught'</code>
<code class="example">	:  endif</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:function! Foo()</code>
<code class="example">	:  try</code>
<code class="example">	:    try</code>
<code class="example">	:      try</code>
<code class="example">	:	 throw 4711</code>
<code class="example">	:      finally</code>
<code class="example">	:	 call Caught()</code>
<code class="example">	:      endtry</code>
<code class="example">	:    catch /.*/</code>
<code class="example">	:      call Caught()</code>
<code class="example">	:      throw "oops"</code>
<code class="example">	:    endtry</code>
<code class="example">	:  catch /.*/</code>
<code class="example">	:    call Caught()</code>
<code class="example">	:  finally</code>
<code class="example">	:    call Caught()</code>
<code class="example">	:  endtry</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:call Foo()</code>
<code class="example"></code>
This displays
<code class="example"></code>
<code class="example">	Nothing caught</code>
<code class="example">	Caught "4711" in function Foo, line 4</code>
<code class="example">	Caught "oops" in function Foo, line 10</code>
<code class="example">	Nothing caught</code>
<code class="example"></code>
A practical example:  The following command ":LineNumber" displays the line
number in the script or function where it has been used:
<code class="example"></code>
<code class="example">	:function! LineNumber()</code>
<code class="example">	:    return substitute(v:throwpoint, '.<b class="vimtag">*<a name="\D\(\d\+\).">\D\(\d\+\).</a>*</b>', '\1', "")</code>
<code class="example">	:endfunction</code>
<code class="example">	:command! LineNumber try |<code class="badlink"> throw "" </code>| catch |<code class="badlink"> echo LineNumber() </code>| endtry</code>

							<b class="vimtag">*<a name="try-nested">try-nested</a>*</b>
An exception that is not caught by a try conditional can be caught by
a surrounding try conditional:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  try</code>
<code class="example">	:    throw "foo"</code>
<code class="example">	:  catch /foobar/</code>
<code class="example">	:    echo "foobar"</code>
<code class="example">	:  finally</code>
<code class="example">	:    echo "inner finally"</code>
<code class="example">	:  endtry</code>
<code class="example">	:catch /foo/</code>
<code class="example">	:  echo "foo"</code>
<code class="example">	:endtry</code>
<code class="example"></code>
The inner try conditional does not catch the exception, just its finally
clause is executed.  The exception is then caught by the outer try
conditional.  The example displays "inner finally" and then "foo".

							<b class="vimtag">*<a name="throw-from-catch">throw-from-catch</a>*</b>
You can catch an exception and throw a new one to be caught elsewhere from the
catch clause:
<code class="example"></code>
<code class="example">	:function! Foo()</code>
<code class="example">	:  throw "foo"</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:function! Bar()</code>
<code class="example">	:  try</code>
<code class="example">	:    call Foo()</code>
<code class="example">	:  catch /foo/</code>
<code class="example">	:    echo "Caught foo, throw bar"</code>
<code class="example">	:    throw "bar"</code>
<code class="example">	:  endtry</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:  call Bar()</code>
<code class="example">	:catch /.*/</code>
<code class="example">	:  echo "Caught" v:exception</code>
<code class="example">	:endtry</code>
<code class="example"></code>
This displays "Caught foo, throw bar" and then "Caught bar".

							<b class="vimtag">*<a name="rethrow">rethrow</a>*</b>
There is no real rethrow in the Vim script language, but you may throw
"v:exception" instead:
<code class="example"></code>
<code class="example">	:function! Bar()</code>
<code class="example">	:  try</code>
<code class="example">	:    call Foo()</code>
<code class="example">	:  catch /.*/</code>
<code class="example">	:    echo "Rethrow" v:exception</code>
<code class="example">	:    throw v:exception</code>
<code class="example">	:  endtry</code>
<code class="example">	:endfunction</code>
							<b class="vimtag">*<a name="try-echoerr">try-echoerr</a>*</b>
<code class="note">Note</code> that this method cannot be used to "rethrow" Vim error or interrupt
exceptions, because it is not possible to fake Vim internal exceptions.
Trying so causes an error exception.  You should throw your own exception
denoting the situation.  If you want to cause a Vim error exception containing
the original error exception value, you can use the |<a href="eval.html#:echoerr">:echoerr</a>| command:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  try</code>
<code class="example">	:    asdf</code>
<code class="example">	:  catch /.*/</code>
<code class="example">	:    echoerr v:exception</code>
<code class="example">	:  endtry</code>
<code class="example">	:catch /.*/</code>
<code class="example">	:  echo v:exception</code>
<code class="example">	:endtry</code>
<code class="example"></code>
This code displays

<code class="section">	Vim(echoerr):Vim:E492: Not an editor command:	asdf </code>


CLEANUP CODE						<b class="vimtag">*<a name="try-finally">try-finally</a>*</b>

Scripts often change global settings and restore them at their end.  If the
user however interrupts the script by pressing <code class="keystroke">CTRL-C</code>, the settings remain in
an inconsistent state.	The same may happen to you in the development phase of
a script when an error occurs or you explicitly throw an exception without
catching it.  You can solve these problems by using a try conditional with
a finally clause for restoring the settings.  Its execution is guaranteed on
normal control flow, on error, on an explicit ":throw", and on interrupt.
(<code class="note">Note</code> that errors and interrupts from inside the try conditional are converted
to exceptions.	When not caught, they terminate the script after the finally
clause has been executed.)
Example:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  let s:saved_ts = &amp;ts</code>
<code class="example">	:  set ts=17</code>
<code class="example">	:</code>
<code class="example">	:  " Do the hard work here.</code>
<code class="example">	:</code>
<code class="example">	:finally</code>
<code class="example">	:  let &amp;ts = s:saved_ts</code>
<code class="example">	:  unlet s:saved_ts</code>
<code class="example">	:endtry</code>
<code class="example"></code>
This method should be used locally whenever a function or part of a script
changes global settings which need to be restored on failure or normal exit of
that function or script part.

							<b class="vimtag">*<a name="break-finally">break-finally</a>*</b>
Cleanup code works also when the try block or a catch clause is left by
a ":continue", ":break", ":return", or ":finish".
   Example:
<code class="example"></code>
<code class="example">	:let first = 1</code>
<code class="example">	:while 1</code>
<code class="example">	:  try</code>
<code class="example">	:    if first</code>
<code class="example">	:      echo "first"</code>
<code class="example">	:      let first = 0</code>
<code class="example">	:      continue</code>
<code class="example">	:    else</code>
<code class="example">	:      throw "second"</code>
<code class="example">	:    endif</code>
<code class="example">	:  catch /.*/</code>
<code class="example">	:    echo v:exception</code>
<code class="example">	:    break</code>
<code class="example">	:  finally</code>
<code class="example">	:    echo "cleanup"</code>
<code class="example">	:  endtry</code>
<code class="example">	:  echo "still in while"</code>
<code class="example">	:endwhile</code>
<code class="example">	:echo "end"</code>
<code class="example"></code>
This displays "first", "cleanup", "second", "cleanup", and "end".
<code class="example"></code>
<code class="example">	:function! Foo()</code>
<code class="example">	:  try</code>
<code class="example">	:    return 4711</code>
<code class="example">	:  finally</code>
<code class="example">	:    echo "cleanup\n"</code>
<code class="example">	:  endtry</code>
<code class="example">	:  echo "Foo still active"</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:echo Foo() "returned by Foo"</code>
<code class="example"></code>
This displays "cleanup" and "4711 returned by Foo".  You don't need to add an
extra ":return" in the finally clause.	(Above all, this would override the
return value.)

							<b class="vimtag">*<a name="except-from-finally">except-from-finally</a>*</b>
Using either of ":continue", ":break", ":return", ":finish", or ":throw" in
a finally clause is possible, but not recommended since it abandons the
cleanup actions for the try conditional.  But, of course, interrupt and error
exceptions might get raised from a finally clause.
   Example where an error in the finally clause stops an interrupt from
working correctly:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  try</code>
<code class="example">	:    echo "Press <code class="keystroke">CTRL-C</code> for interrupt"</code>
<code class="example">	:    while 1</code>
<code class="example">	:    endwhile</code>
<code class="example">	:  finally</code>
<code class="example">	:    unlet novar</code>
<code class="example">	:  endtry</code>
<code class="example">	:catch /novar/</code>
<code class="example">	:endtry</code>
<code class="example">	:echo "Script still running"</code>
<code class="example">	:sleep 1</code>
<code class="example"></code>
If you need to put commands that could fail into a finally clause, you should
think about catching or ignoring the errors in these commands, see
|<a href="eval.html#catch-errors">catch-errors</a>| and |<a href="eval.html#ignore-errors">ignore-errors</a>|.


CATCHING ERRORS						<b class="vimtag">*<a name="catch-errors">catch-errors</a>*</b>

If you want to catch specific errors, you just have to put the code to be
watched in a try block and add a catch clause for the error message.  The
presence of the try conditional causes all errors to be converted to an
exception.  No message is displayed and |<a href="eval.html#v:errmsg">v:errmsg</a>| is not set then.  To find
the right pattern for the ":catch" command, you have to know how the format of
the error exception is.
   Error exceptions have the following format:
<code class="example"></code>
<code class="example">	Vim(<code class="special">{cmdname}</code>):<code class="special">{errmsg}</code></code>
or
<code class="example">	Vim:<code class="special">{errmsg}</code></code>
<code class="example"></code>
<code class="special">{cmdname}</code> is the name of the command that failed; the second form is used when
the command name is not known.	<code class="special">{errmsg}</code> is the error message usually produced
when the error occurs outside try conditionals.  It always begins with
a capital "E", followed by a two or three-digit error number, a colon, and
a space.

Examples:

The command
<code class="example">	:unlet novar</code>
normally produces the error message
<code class="example">	E108: No such variable: "novar"</code>
which is converted inside try conditionals to an exception
<code class="example">	Vim(unlet):E108: No such variable: "novar"</code>
<code class="example"></code>
The command
<code class="example">	:dwim</code>
normally produces the error message
<code class="example">	E492: Not an editor command: dwim</code>
which is converted inside try conditionals to an exception
<code class="example">	Vim:E492: Not an editor command: dwim</code>
<code class="example"></code>
You can catch all ":unlet" errors by a
<code class="example">	:catch /^Vim(unlet):/</code>
or all errors for misspelled command names by a
<code class="example">	:catch /^Vim:E492:/</code>
<code class="example"></code>
Some error messages may be produced by different commands:
<code class="example">	:function nofunc</code>
and
<code class="example">	:delfunction nofunc</code>
both produce the error message
<code class="example">	E128: Function name must start with a capital: nofunc</code>
which is converted inside try conditionals to an exception
<code class="example">	Vim(function):E128: Function name must start with a capital: nofunc</code>
or
<code class="example">	Vim(delfunction):E128: Function name must start with a capital: nofunc</code>
respectively.  You can catch the error by its number independently on the
command that caused it if you use the following pattern:
<code class="example">	:catch /^Vim(\a\+):E128:/</code>
<code class="example"></code>
Some commands like
<code class="example">	:let x = novar</code>
produce multiple error messages, here:
<code class="example">	E121: Undefined variable: novar</code>
<code class="example">	E15: Invalid expression:  novar</code>
Only the first is used for the exception value, since it is the most specific
one (see |<a href="eval.html#except-several-errors">except-several-errors</a>|).  So you can catch it by
<code class="example">	:catch /^Vim(\a\+):E121:/</code>
<code class="example"></code>
You can catch all errors related to the name "nofunc" by
<code class="example">	:catch /\<code class="special">&lt;nofunc\&gt;</code>/</code>
<code class="example"></code>
You can catch all Vim errors in the ":write" and ":read" commands by
<code class="example">	:catch /^Vim(\(write\|read\)):E\d\+:/</code>
<code class="example"></code>
You can catch all Vim errors by the pattern
<code class="example">	:catch /^Vim\((\a\+)\)\=:E\d\+:/</code>

							<b class="vimtag">*<a name="catch-text">catch-text</a>*</b>
<code class="note">NOTE:</code> You should never catch the error message text itself:
<code class="example">	:catch /No such variable/</code>
only works in the English locale, but not when the user has selected
a different language by the |<a href="mlang.html#:language">:language</a>| command.  It is however helpful to
cite the message text in a comment:
<code class="example">	:catch /^Vim(\a\+):E108:/   " No such variable</code>
<code class="example"></code>
<code class="example"></code>
IGNORING ERRORS						<b class="vimtag">*<a name="ignore-errors">ignore-errors</a>*</b>

You can ignore errors in a specific Vim command by catching them locally:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  write</code>
<code class="example">	:catch</code>
<code class="example">	:endtry</code>
<code class="example"></code>
But you are strongly recommended NOT to use this simple form, since it could
catch more than you want.  With the ":write" command, some autocommands could
be executed and cause errors not related to writing, for instance:
<code class="example"></code>
<code class="example">	:au BufWritePre * unlet novar</code>
<code class="example"></code>
There could even be such errors you are not responsible for as a script
writer: a user of your script might have defined such autocommands.  You would
then hide the error from the user.
   It is much better to use
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  write</code>
<code class="example">	:catch /^Vim(write):/</code>
<code class="example">	:endtry</code>
<code class="example"></code>
which only catches real write errors.  So catch only what you'd like to ignore
intentionally.

For a single command that does not cause execution of autocommands, you could
even suppress the conversion of errors to exceptions by the ":silent!"
command:
<code class="example">	:silent! nunmap k</code>
This works also when a try conditional is active.


CATCHING INTERRUPTS					<b class="vimtag">*<a name="catch-interrupt">catch-interrupt</a>*</b>

When there are active try conditionals, an interrupt (<code class="keystroke">CTRL-C</code>) is converted to
the exception "Vim:Interrupt".	You can catch it like every exception.	The
script is not terminated, then.
   Example:
<code class="example"></code>
<code class="example">	:function! TASK1()</code>
<code class="example">	:  sleep 10</code>
<code class="example">	:endfunction</code>
<code class="example"></code>
<code class="example">	:function! TASK2()</code>
<code class="example">	:  sleep 20</code>
<code class="example">	:endfunction</code>
<code class="example"></code>
<code class="example">	:while 1</code>
<code class="example">	:  let command = input("Type a command: ")</code>
<code class="example">	:  try</code>
<code class="example">	:    if command == ""</code>
<code class="example">	:      continue</code>
<code class="example">	:    elseif command == "END"</code>
<code class="example">	:      break</code>
<code class="example">	:    elseif command == "TASK1"</code>
<code class="example">	:      call TASK1()</code>
<code class="example">	:    elseif command == "TASK2"</code>
<code class="example">	:      call TASK2()</code>
<code class="example">	:    else</code>
<code class="example">	:      echo "\nIllegal command:" command</code>
<code class="example">	:      continue</code>
<code class="example">	:    endif</code>
<code class="example">	:  catch /^Vim:Interrupt$/</code>
<code class="example">	:    echo "\nCommand interrupted"</code>
<code class="example">	:    " Caught the interrupt.  Continue with next prompt.</code>
<code class="example">	:  endtry</code>
<code class="example">	:endwhile</code>
<code class="example"></code>
You can interrupt a task here by pressing <code class="keystroke">CTRL-C</code>; the script then asks for
a new command.	If you press <code class="keystroke">CTRL-C</code> at the prompt, the script is terminated.

For testing what happens when <code class="keystroke">CTRL-C</code> would be pressed on a specific line in
your script, use the debug mode and execute the |<a href="repeat.html#%3Equit">&gt;quit</a>| or |<a href="repeat.html#%3Einterrupt">&gt;interrupt</a>|
command on that line.  See |<a href="repeat.html#debug-scripts">debug-scripts</a>|.


CATCHING ALL						<b class="vimtag">*<a name="catch-all">catch-all</a>*</b>

The commands
<code class="example"></code>
<code class="example">	:catch /.*/</code>
<code class="example">	:catch //</code>
<code class="example">	:catch</code>
<code class="example"></code>
catch everything, error exceptions, interrupt exceptions and exceptions
explicitly thrown by the |<a href="eval.html#:throw">:throw</a>| command.  This is useful at the top level of
a script in order to catch unexpected things.
   Example:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:</code>
<code class="example">	:  " do the hard work here</code>
<code class="example">	:</code>
<code class="example">	:catch /MyException/</code>
<code class="example">	:</code>
<code class="example">	:  " handle known problem</code>
<code class="example">	:</code>
<code class="example">	:catch /^Vim:Interrupt$/</code>
<code class="example">	:    echo "Script interrupted"</code>
<code class="example">	:catch /.*/</code>
<code class="example">	:  echo "Internal error (" . v:exception . ")"</code>
<code class="example">	:  echo " - occurred at " . v:throwpoint</code>
<code class="example">	:endtry</code>
<code class="example">	:" end of script</code>
<code class="example"></code>
<code class="note">Note:</code> Catching all might catch more things than you want.  Thus, you are
strongly encouraged to catch only for problems that you can really handle by
specifying a pattern argument to the ":catch".
   Example: Catching all could make it nearly impossible to interrupt a script
by pressing <code class="keystroke">CTRL-C</code>:
<code class="example"></code>
<code class="example">	:while 1</code>
<code class="example">	:  try</code>
<code class="example">	:    sleep 1</code>
<code class="example">	:  catch</code>
<code class="example">	:  endtry</code>
<code class="example">	:endwhile</code>
<code class="example"></code>
<code class="example"></code>
EXCEPTIONS AND AUTOCOMMANDS				<b class="vimtag">*<a name="except-autocmd">except-autocmd</a>*</b>

Exceptions may be used during execution of autocommands.  Example:
<code class="example"></code>
<code class="example">	:autocmd User x try</code>
<code class="example">	:autocmd User x   throw "Oops!"</code>
<code class="example">	:autocmd User x catch</code>
<code class="example">	:autocmd User x   echo v:exception</code>
<code class="example">	:autocmd User x endtry</code>
<code class="example">	:autocmd User x throw "Arrgh!"</code>
<code class="example">	:autocmd User x echo "Should not be displayed"</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:  doautocmd User x</code>
<code class="example">	:catch</code>
<code class="example">	:  echo v:exception</code>
<code class="example">	:endtry</code>
<code class="example"></code>
This displays "Oops!" and "Arrgh!".

							<b class="vimtag">*<a name="except-autocmd-Pre">except-autocmd-Pre</a>*</b>
For some commands, autocommands get executed before the main action of the
command takes place.  If an exception is thrown and not caught in the sequence
of autocommands, the sequence and the command that caused its execution are
abandoned and the exception is propagated to the caller of the command.
   Example:
<code class="example"></code>
<code class="example">	:autocmd BufWritePre * throw "FAIL"</code>
<code class="example">	:autocmd BufWritePre * echo "Should not be displayed"</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:  write</code>
<code class="example">	:catch</code>
<code class="example">	:  echo "Caught:" v:exception "from" v:throwpoint</code>
<code class="example">	:endtry</code>
<code class="example"></code>
Here, the ":write" command does not write the file currently being edited (as
you can see by checking 'modified'), since the exception from the BufWritePre
autocommand abandons the ":write".  The exception is then caught and the
script displays:
<code class="example"></code>
<code class="example">	Caught: FAIL from BufWrite Auto commands for "*"</code>

							<b class="vimtag">*<a name="except-autocmd-Post">except-autocmd-Post</a>*</b>
For some commands, autocommands get executed after the main action of the
command has taken place.  If this main action fails and the command is inside
an active try conditional, the autocommands are skipped and an error exception
is thrown that can be caught by the caller of the command.
   Example:
<code class="example"></code>
<code class="example">	:autocmd BufWritePost * echo "File successfully written!"</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:  write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">	:catch</code>
<code class="example">	:  echo v:exception</code>
<code class="example">	:endtry</code>
<code class="example"></code>
This just displays:
<code class="example"></code>
<code class="example">	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)</code>
<code class="example"></code>
If you really need to execute the autocommands even when the main action
fails, trigger the event from the catch clause.
   Example:
<code class="example"></code>
<code class="example">	:autocmd BufWritePre  * set noreadonly</code>
<code class="example">	:autocmd BufWritePost * set readonly</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:  write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">	:catch</code>
<code class="example">	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">	:endtry</code>

You can also use ":silent!":
<code class="example"></code>
<code class="example">	:let x = "ok"</code>
<code class="example">	:let v:errmsg = ""</code>
<code class="example">	:autocmd BufWritePost * if v:errmsg != ""</code>
<code class="example">	:autocmd BufWritePost *   let x = "after fail"</code>
<code class="example">	:autocmd BufWritePost * endif</code>
<code class="example">	:try</code>
<code class="example">	:  silent! write /i/m/p/o/s/s/i/b/l/e</code>
<code class="example">	:catch</code>
<code class="example">	:endtry</code>
<code class="example">	:echo x</code>
<code class="example"></code>
This displays "after fail".

If the main action of the command does not fail, exceptions from the
autocommands will be catchable by the caller of the command:
<code class="example"></code>
<code class="example">	:autocmd BufWritePost * throw ":-("</code>
<code class="example">	:autocmd BufWritePost * echo "Should not be displayed"</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:  write</code>
<code class="example">	:catch</code>
<code class="example">	:  echo v:exception</code>
<code class="example">	:endtry</code>

							<b class="vimtag">*<a name="except-autocmd-Cmd">except-autocmd-Cmd</a>*</b>
For some commands, the normal action can be replaced by a sequence of
autocommands.  Exceptions from that sequence will be catchable by the caller
of the command.
   Example:  For the ":write" command, the caller cannot know whether the file
had actually been written when the exception occurred.	You need to tell it in
some way.
<code class="example"></code>
<code class="example">	:if !exists("cnt")</code>
<code class="example">	:  let cnt = 0</code>
<code class="example">	:</code>
<code class="example">	:  autocmd BufWriteCmd * if &amp;modified</code>
<code class="example">	:  autocmd BufWriteCmd *   let cnt = cnt + 1</code>
<code class="example">	:  autocmd BufWriteCmd *   if cnt % 3 == 2</code>
<code class="example">	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</code>
<code class="example">	:  autocmd BufWriteCmd *   endif</code>
<code class="example">	:  autocmd BufWriteCmd *   write | set nomodified</code>
<code class="example">	:  autocmd BufWriteCmd *   if cnt % 3 == 0</code>
<code class="example">	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</code>
<code class="example">	:  autocmd BufWriteCmd *   endif</code>
<code class="example">	:  autocmd BufWriteCmd *   echo "File successfully written!"</code>
<code class="example">	:  autocmd BufWriteCmd * endif</code>
<code class="example">	:endif</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:	write</code>
<code class="example">	:catch /^BufWriteCmdError$/</code>
<code class="example">	:  if &amp;modified</code>
<code class="example">	:    echo "Error on writing (file contents not changed)"</code>
<code class="example">	:  else</code>
<code class="example">	:    echo "Error after writing"</code>
<code class="example">	:  endif</code>
<code class="example">	:catch /^Vim(write):/</code>
<code class="example">	:    echo "Error on writing"</code>
<code class="example">	:endtry</code>
<code class="example"></code>
When this script is sourced several times after making changes, it displays
first
<code class="example">	File successfully written!</code>
then
<code class="example">	Error on writing (file contents not changed)</code>
then
<code class="example">	Error after writing</code>
etc.

							<b class="vimtag">*<a name="except-autocmd-ill">except-autocmd-ill</a>*</b>
You cannot spread a try conditional over autocommands for different events.
The following code is ill-formed:
<code class="example"></code>
<code class="example">	:autocmd BufWritePre  * try</code>
<code class="example">	:</code>
<code class="example">	:autocmd BufWritePost * catch</code>
<code class="example">	:autocmd BufWritePost *   echo v:exception</code>
<code class="example">	:autocmd BufWritePost * endtry</code>
<code class="example">	:</code>
<code class="example">	:write</code>
<code class="example"></code>
<code class="example"></code>
EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	<b class="vimtag">*<a name="except-hier-param">except-hier-param</a>*</b>

Some programming languages allow to use hierarchies of exception classes or to
pass additional information with the object of an exception class.  You can do
similar things in Vim.
   In order to throw an exception from a hierarchy, just throw the complete
class name with the components separated by a colon, for instance throw the
string "EXCEPT:MATHERR:OVERFLOW" for an overflow in a mathematical library.
   When you want to pass additional information with your exception class, add
it in parentheses, for instance throw the string "EXCEPT:IO:WRITEERR(myfile)"
for an error when writing "myfile".
   With the appropriate patterns in the ":catch" command, you can catch for
base classes or derived classes of your hierarchy.  Additional information in
parentheses can be cut out from |<a href="eval.html#v:exception">v:exception</a>| with the ":substitute" command.
   Example:
<code class="example"></code>
<code class="example">	:function! CheckRange(a, func)</code>
<code class="example">	:  if a:a &lt; 0</code>
<code class="example">	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"</code>
<code class="example">	:  endif</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:function! Add(a, b)</code>
<code class="example">	:  call CheckRange(a:a, "Add")</code>
<code class="example">	:  call CheckRange(a:b, "Add")</code>
<code class="example">	:  let c = a:a + a:b</code>
<code class="example">	:  if c &lt; 0</code>
<code class="example">	:    throw "EXCEPT:MATHERR:OVERFLOW"</code>
<code class="example">	:  endif</code>
<code class="example">	:  return c</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:function! Div(a, b)</code>
<code class="example">	:  call CheckRange(a:a, "Div")</code>
<code class="example">	:  call CheckRange(a:b, "Div")</code>
<code class="example">	:  if (a:b == 0)</code>
<code class="example">	:    throw "EXCEPT:MATHERR:ZERODIV"</code>
<code class="example">	:  endif</code>
<code class="example">	:  return a:a / a:b</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:function! Write(file)</code>
<code class="example">	:  try</code>
<code class="example">	:    execute "write" fnameescape(a:file)</code>
<code class="example">	:  catch /^Vim(write):/</code>
<code class="example">	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"</code>
<code class="example">	:  endtry</code>
<code class="example">	:endfunction</code>
<code class="example">	:</code>
<code class="example">	:try</code>
<code class="example">	:</code>
<code class="example">	:  " something with arithmetics and I/O</code>
<code class="example">	:</code>
<code class="example">	:catch /^EXCEPT:MATHERR:RANGE/</code>
<code class="example">	:  let function = substitute(v:exception, '.<b class="vimtag">*<a name="(\(\a\+\)).">(\(\a\+\)).</a>*</b>', '\1', "")</code>
<code class="example">	:  echo "Range error in" function</code>
<code class="example">	:</code>
<code class="example">	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV</code>
<code class="example">	:  echo "Math error"</code>
<code class="example">	:</code>
<code class="example">	:catch /^EXCEPT:IO/</code>
<code class="example">	:  let dir = substitute(v:exception, '.<b class="vimtag">*<a name="(\(.\+\),\s">(\(.\+\),\s</a>*</b>.\+).*', '\1', "")</code>
<code class="example">	:  let file = substitute(v:exception, '.<b class="vimtag">*<a name="(.\+,\s">(.\+,\s</a>*</b>\(.\+\)).*', '\1', "")</code>
<code class="example">	:  if file !~ '^/'</code>
<code class="example">	:    let file = dir . "/" . file</code>
<code class="example">	:  endif</code>
<code class="example">	:  echo 'I/O error for "' . file . '"'</code>
<code class="example">	:</code>
<code class="example">	:catch /^EXCEPT/</code>
<code class="example">	:  echo "Unspecified error"</code>
<code class="example">	:</code>
<code class="example">	:endtry</code>
<code class="example"></code>
The exceptions raised by Vim itself (on error or when pressing <code class="keystroke">CTRL-C</code>) use
a flat hierarchy:  they are all in the "Vim" class.  You cannot throw yourself
exceptions with the "Vim" prefix; they are reserved for Vim.
   Vim error exceptions are parameterized with the name of the command that
failed, if known.  See |<a href="eval.html#catch-errors">catch-errors</a>|.


PECULIARITIES
							<b class="vimtag">*<a name="except-compat">except-compat</a>*</b>
The exception handling concept requires that the command sequence causing the
exception is aborted immediately and control is transferred to finally clauses
and/or a catch clause.

In the Vim script language there are cases where scripts and functions
continue after an error: in functions without the "abort" flag or in a command
after ":silent!", control flow goes to the following line, and outside
functions, control flow goes to the line following the outermost ":endwhile"
or ":endif".  On the other hand, errors should be catchable as exceptions
(thus, requiring the immediate abortion).

This problem has been solved by converting errors to exceptions and using
immediate abortion (if not suppressed by ":silent!") only when a try
conditional is active.	This is no restriction since an (error) exception can
be caught only from an active try conditional.	If you want an immediate
termination without catching the error, just use a try conditional without
catch clause.  (You can cause cleanup code being executed before termination
by specifying a finally clause.)

When no try conditional is active, the usual abortion and continuation
behavior is used instead of immediate abortion.  This ensures compatibility of
scripts written for Vim 6.1 and earlier.

However, when sourcing an existing script that does not use exception handling
commands (or when calling one of its functions) from inside an active try
conditional of a new script, you might change the control flow of the existing
script on error.  You get the immediate abortion on error and can catch the
error in the new script.  If however the sourced script suppresses error
messages by using the ":silent!" command (checking for errors by testing
|<a href="eval.html#v:errmsg">v:errmsg</a>| if appropriate), its execution path is not changed.	The error is
not converted to an exception.	(See |<a href="various.html#:silent">:silent</a>|.)  So the only remaining cause
where this happens is for scripts that don't care about errors and produce
error messages.  You probably won't want to use such code from your new
scripts.

							<b class="vimtag">*<a name="except-syntax-err">except-syntax-err</a>*</b>
Syntax errors in the exception handling commands are never caught by any of
the ":catch" commands of the try conditional they belong to.  Its finally
clauses, however, is executed.
   Example:
<code class="example"></code>
<code class="example">	:try</code>
<code class="example">	:  try</code>
<code class="example">	:    throw 4711</code>
<code class="example">	:  catch /\(/</code>
<code class="example">	:    echo "in catch with syntax error"</code>
<code class="example">	:  catch</code>
<code class="example">	:    echo "inner catch-all"</code>
<code class="example">	:  finally</code>
<code class="example">	:    echo "inner finally"</code>
<code class="example">	:  endtry</code>
<code class="example">	:catch</code>
<code class="example">	:  echo 'outer catch-all caught "' . v:exception . '"'</code>
<code class="example">	:  finally</code>
<code class="example">	:    echo "outer finally"</code>
<code class="example">	:endtry</code>
<code class="example"></code>
This displays:
<code class="example">    inner finally</code>
<code class="example">    outer catch-all caught "Vim(catch):E54: Unmatched \("</code>
<code class="example">    outer finally</code>
The original exception is discarded and an error exception is raised, instead.

							<b class="vimtag">*<a name="except-single-line">except-single-line</a>*</b>
The ":try", ":catch", ":finally", and ":endtry" commands can be put on
a single line, but then syntax errors may make it difficult to recognize the
"catch" line, thus you better avoid this.
   Example:
<code class="example">	:try |<code class="badlink"> unlet! foo # </code>| catch | endtry</code>
raises an error exception for the trailing characters after the ":unlet!"
argument, but does not see the ":catch" and ":endtry" commands, so that the
error exception is discarded and the "E488: Trailing characters" message gets
displayed.

							<b class="vimtag">*<a name="except-several-errors">except-several-errors</a>*</b>
When several errors appear in a single command, the first error message is
usually the most specific one and therefor converted to the error exception.
   Example:
<code class="example">	echo novar</code>
causes
<code class="example">	E121: Undefined variable: novar</code>
<code class="example">	E15: Invalid expression: novar</code>
The value of the error exception inside try conditionals is:
<code class="example">	Vim(echo):E121: Undefined variable: novar</code>
							<b class="vimtag">*<a name="except-syntax-error">except-syntax-error</a>*</b>
But when a syntax error is detected after a normal error in the same command,
the syntax error is used for the exception being thrown.
   Example:
<code class="example">	unlet novar #</code>
causes
<code class="example">	E108: No such variable: "novar"</code>
<code class="example">	E488: Trailing characters</code>
The value of the error exception inside try conditionals is:
<code class="example">	Vim(unlet):E488: Trailing characters</code>
This is done because the syntax error might change the execution path in a way
not intended by the user.  Example:
<code class="example">	try</code>
<code class="example">	    try |<code class="badlink"> unlet novar # </code>| catch |<code class="badlink"> echo v:exception </code>| endtry</code>
<code class="example">	catch /.*/</code>
<code class="example">	    echo "outer catch:" v:exception</code>
<code class="example">	endtry</code>
This displays "outer catch: Vim(unlet):E488: Trailing characters", and then
a "E600: Missing :endtry" error message is given, see |<a href="eval.html#except-single-line">except-single-line</a>|.

</pre><hr><pre>9. Examples						<b class="vimtag">*<a name="eval-examples">eval-examples</a>*</b>

<code class="section">Printing in Binary </code>

<code class="example">  :" The function Nr2Bin() returns the binary string representation of a number.</code>
<code class="example">  :func Nr2Bin(nr)</code>
<code class="example">  :  let n = a:nr</code>
<code class="example">  :  let r = ""</code>
<code class="example">  :  while n</code>
<code class="example">  :    let r = '01'[n % 2] . r</code>
<code class="example">  :    let n = n / 2</code>
<code class="example">  :  endwhile</code>
<code class="example">  :  return r</code>
<code class="example">  :endfunc</code>
<code class="example"></code>
<code class="example">  :" The function String2Bin() converts each character in a string to a</code>
<code class="example">  :" binary string, separated with dashes.</code>
<code class="example">  :func String2Bin(str)</code>
<code class="example">  :  let out = ''</code>
<code class="example">  :  for ix in range(strlen(a:str))</code>
<code class="example">  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))</code>
<code class="example">  :  endfor</code>
<code class="example">  :  return out[1:]</code>
<code class="example">  :endfunc</code>
<code class="example"></code>
Example of its use:
<code class="example">  :echo Nr2Bin(32)</code>
result: "100000"
<code class="example">  :echo String2Bin("32")</code>
result: "110011-110010"


<code class="section">Sorting lines </code>

This example sorts lines with a specific compare function.
<code class="example"></code>
<code class="example">  :func SortBuffer()</code>
<code class="example">  :  let lines = getline(1, '$')</code>
<code class="example">  :  call sort(lines, function("Strcmp"))</code>
<code class="example">  :  call setline(1, lines)</code>
<code class="example">  :endfunction</code>
<code class="example"></code>
As a one-liner:
<code class="example">  :call setline(1, sort(getline(1, '$'), function("Strcmp")))</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">scanf() replacement </code>
							<b class="vimtag">*<a name="sscanf">sscanf</a>*</b>
There is no sscanf() function in Vim.  If you need to extract parts from a
line, you can use matchstr() and substitute() to do it.  This example shows
how to get the file name, line number and column number out of a line like
"foobar.txt, 123, 45".
<code class="example">   :" Set up the match bit</code>
<code class="example">   :let mx='\(\f\+\),\s<b class="vimtag">*<a name="\(\d\+\),\s">\(\d\+\),\s</a>*</b>\(\d\+\)'</code>
<code class="example">   :"get the part matching the whole expression</code>
<code class="example">   :let l = matchstr(line, mx)</code>
<code class="example">   :"get each item out of the match</code>
<code class="example">   :let file = substitute(l, mx, '\1', '')</code>
<code class="example">   :let lnum = substitute(l, mx, '\2', '')</code>
<code class="example">   :let col = substitute(l, mx, '\3', '')</code>
<code class="example"></code>
The input is in the variable "line", the results in the variables "file",
"lnum" and "col". (idea from Michael Geddes)


<code class="section">getting the scriptnames in a Dictionary </code>
						<b class="vimtag">*<a name="scriptnames-dictionary">scriptnames-dictionary</a>*</b>
The |<a href="repeat.html#:scriptnames">:scriptnames</a>| command can be used to get a list of all script files that
have been sourced.  There is no equivalent function or variable for this
(because it's rarely needed).  In case you need to manipulate the list this
code can be used:
<code class="example">    " Get the output of ":scriptnames" in the scriptnames_output variable.</code>
<code class="example">    let scriptnames_output = ''</code>
<code class="example">    redir =&gt; scriptnames_output</code>
<code class="example">    silent scriptnames</code>
<code class="example">    redir END</code>
<code class="example"></code>
<code class="example">    " Split the output into lines and parse each line.	Add an entry to the</code>
<code class="example">    " "scripts" dictionary.</code>
<code class="example">    let scripts = <code class="special">{}</code></code>
<code class="example">    for line in split(scriptnames_output, "\n")</code>
<code class="example">      " Only do non-blank lines.</code>
<code class="example">      if line =~ '\S'</code>
<code class="example">	" Get the first number in the line.</code>
<code class="example">	let nr = matchstr(line, '\d\+')</code>
<code class="example">	" Get the file name, remove the script number " 123: ".</code>
<code class="example">	let name = substitute(line, '.\+:\s*', '', '')</code>
<code class="example">	" Add an item to the Dictionary</code>
<code class="example">	let scripts[nr] = name</code>
<code class="example">      endif</code>
<code class="example">    endfor</code>
<code class="example">    unlet scriptnames_output</code>
<code class="example"></code>
</pre><hr><pre>10. No +eval feature				<b class="vimtag">*<a name="no-eval-feature">no-eval-feature</a>*</b>

When the |<a href="various.html#+eval">+eval</a>| feature was disabled at compile time, none of the expression
evaluation commands are available.  To prevent this from causing Vim scripts
to generate all kinds of errors, the ":if" and ":endif" commands are still
recognized, though the argument of the ":if" and everything between the ":if"
and the matching ":endif" is ignored.  Nesting of ":if" blocks is allowed, but
only if the commands are at the start of the line.  The ":else" command is not
recognized.

Example of how to avoid executing commands when the |<a href="various.html#+eval">+eval</a>| feature is
missing:
<code class="example"></code>
<code class="example">	:if 1</code>
<code class="example">	:  echo "Expression evaluation is compiled in"</code>
<code class="example">	:else</code>
<code class="example">	:  echo "You will _never_ see this message"</code>
<code class="example">	:endif</code>
<code class="example"></code>
</pre><hr><pre>11. The sandbox					<b class="vimtag">*<a name="eval-sandbox">eval-sandbox</a>*</b> <b class="vimtag">*<a name="sandbox">sandbox</a>*</b> <b class="vimtag">*<a name="E48">E48</a>*</b>

The 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr', 'statusline' and
'foldtext' options may be evaluated in a sandbox.  This means that you are
protected from these expressions having nasty side effects.  This gives some
safety for when these options are set from a modeline.  It is also used when
the command from a tags file is executed and for <code class="keystroke">CTRL-R</code> = in the command line.
The sandbox is also used for the |<a href="eval.html#:sandbox">:sandbox</a>| command.

These items are not allowed in the sandbox:
	- changing the buffer text
	- defining or changing mapping, autocommands, functions, user commands
	- setting certain options (see |<a href="options.html#option-summary">option-summary</a>|)
	- setting certain v: variables (see |<a href="eval.html#v:var">v:var</a>|)  <b class="vimtag">*<a name="E794">E794</a>*</b>
	- executing a shell command
	- reading or writing a file
	- jumping to another buffer or editing a file
	- executing Python, Perl, etc. commands
This is not guaranteed 100% secure, but it should block most attacks.

							<b class="vimtag">*<a name=":san">:san</a>*</b> <b class="vimtag">*<a name=":sandbox">:sandbox</a>*</b>
:san[dbox] <code class="special">{cmd}</code>	Execute <code class="special">{cmd}</code> in the sandbox.  Useful to evaluate an
			option that may have been set from a modeline, e.g.
			'foldexpr'.

							<b class="vimtag">*<a name="sandbox-option">sandbox-option</a>*</b>
A few options contain an expression.  When this expression is evaluated it may
have to be done in the sandbox to avoid a security risk.  But the sandbox is
restrictive, thus this only happens when the option was set from an insecure
location.  Insecure in this context are:
- sourcing a .vimrc or .exrc in the current directory
- while executing in the sandbox
- value coming from a modeline

<code class="note">Note</code> that when in the sandbox and saving an option value and restoring it, the
option will still be marked as it was set in the sandbox.

</pre><hr><pre>12. Textlock							<b class="vimtag">*<a name="textlock">textlock</a>*</b>

In a few situations it is not allowed to change the text in the buffer, jump
to another window and some other things that might confuse or break what Vim
is currently doing.  This mostly applies to things that happen when Vim is
actually doing something else.	For example, evaluating the 'balloonexpr' may
happen any moment the mouse cursor is resting at some position.

This is not allowed when the textlock is active:
	- changing the buffer text
	- jumping to another buffer or window
	- editing another file
	- closing a window or quitting Vim
	- etc.


 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Mon, 02 May 2016 16:38:55</i></p>
</body>
</html>
